"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/cropperjs";
exports.ids = ["vendor-chunks/cropperjs"];
exports.modules = {

/***/ "(ssr)/./node_modules/cropperjs/dist/cropper.esm.js":
/*!****************************************************!*\
  !*** ./node_modules/cropperjs/dist/cropper.esm.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Cropper)\n/* harmony export */ });\n/*!\n * Cropper.js v1.6.1\n * https://fengyuanchen.github.io/cropperjs\n *\n * Copyright 2015-present Chen Fengyuan\n * Released under the MIT license\n *\n * Date: 2023-09-17T03:44:19.860Z\n */ function ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread2(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nfunction _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);\n    }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    Object.defineProperty(Constructor, \"prototype\", {\n        writable: false\n    });\n    return Constructor;\n}\nfunction _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _toConsumableArray(arr) {\n    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\nfunction _arrayWithoutHoles(arr) {\n    if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\nfunction _iterableToArray(iter) {\n    if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\nfunction _nonIterableSpread() {\n    throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _toPrimitive(input, hint) {\n    if (typeof input !== \"object\" || input === null) return input;\n    var prim = input[Symbol.toPrimitive];\n    if (prim !== undefined) {\n        var res = prim.call(input, hint || \"default\");\n        if (typeof res !== \"object\") return res;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (hint === \"string\" ? String : Number)(input);\n}\nfunction _toPropertyKey(arg) {\n    var key = _toPrimitive(arg, \"string\");\n    return typeof key === \"symbol\" ? key : String(key);\n}\nvar IS_BROWSER =  false && 0;\nvar WINDOW = IS_BROWSER ? window : {};\nvar IS_TOUCH_DEVICE = IS_BROWSER && WINDOW.document.documentElement ? \"ontouchstart\" in WINDOW.document.documentElement : false;\nvar HAS_POINTER_EVENT = IS_BROWSER ? \"PointerEvent\" in WINDOW : false;\nvar NAMESPACE = \"cropper\";\n// Actions\nvar ACTION_ALL = \"all\";\nvar ACTION_CROP = \"crop\";\nvar ACTION_MOVE = \"move\";\nvar ACTION_ZOOM = \"zoom\";\nvar ACTION_EAST = \"e\";\nvar ACTION_WEST = \"w\";\nvar ACTION_SOUTH = \"s\";\nvar ACTION_NORTH = \"n\";\nvar ACTION_NORTH_EAST = \"ne\";\nvar ACTION_NORTH_WEST = \"nw\";\nvar ACTION_SOUTH_EAST = \"se\";\nvar ACTION_SOUTH_WEST = \"sw\";\n// Classes\nvar CLASS_CROP = \"\".concat(NAMESPACE, \"-crop\");\nvar CLASS_DISABLED = \"\".concat(NAMESPACE, \"-disabled\");\nvar CLASS_HIDDEN = \"\".concat(NAMESPACE, \"-hidden\");\nvar CLASS_HIDE = \"\".concat(NAMESPACE, \"-hide\");\nvar CLASS_INVISIBLE = \"\".concat(NAMESPACE, \"-invisible\");\nvar CLASS_MODAL = \"\".concat(NAMESPACE, \"-modal\");\nvar CLASS_MOVE = \"\".concat(NAMESPACE, \"-move\");\n// Data keys\nvar DATA_ACTION = \"\".concat(NAMESPACE, \"Action\");\nvar DATA_PREVIEW = \"\".concat(NAMESPACE, \"Preview\");\n// Drag modes\nvar DRAG_MODE_CROP = \"crop\";\nvar DRAG_MODE_MOVE = \"move\";\nvar DRAG_MODE_NONE = \"none\";\n// Events\nvar EVENT_CROP = \"crop\";\nvar EVENT_CROP_END = \"cropend\";\nvar EVENT_CROP_MOVE = \"cropmove\";\nvar EVENT_CROP_START = \"cropstart\";\nvar EVENT_DBLCLICK = \"dblclick\";\nvar EVENT_TOUCH_START = IS_TOUCH_DEVICE ? \"touchstart\" : \"mousedown\";\nvar EVENT_TOUCH_MOVE = IS_TOUCH_DEVICE ? \"touchmove\" : \"mousemove\";\nvar EVENT_TOUCH_END = IS_TOUCH_DEVICE ? \"touchend touchcancel\" : \"mouseup\";\nvar EVENT_POINTER_DOWN = HAS_POINTER_EVENT ? \"pointerdown\" : EVENT_TOUCH_START;\nvar EVENT_POINTER_MOVE = HAS_POINTER_EVENT ? \"pointermove\" : EVENT_TOUCH_MOVE;\nvar EVENT_POINTER_UP = HAS_POINTER_EVENT ? \"pointerup pointercancel\" : EVENT_TOUCH_END;\nvar EVENT_READY = \"ready\";\nvar EVENT_RESIZE = \"resize\";\nvar EVENT_WHEEL = \"wheel\";\nvar EVENT_ZOOM = \"zoom\";\n// Mime types\nvar MIME_TYPE_JPEG = \"image/jpeg\";\n// RegExps\nvar REGEXP_ACTIONS = /^e|w|s|n|se|sw|ne|nw|all|crop|move|zoom$/;\nvar REGEXP_DATA_URL = /^data:/;\nvar REGEXP_DATA_URL_JPEG = /^data:image\\/jpeg;base64,/;\nvar REGEXP_TAG_NAME = /^img|canvas$/i;\n// Misc\n// Inspired by the default width and height of a canvas element.\nvar MIN_CONTAINER_WIDTH = 200;\nvar MIN_CONTAINER_HEIGHT = 100;\nvar DEFAULTS = {\n    // Define the view mode of the cropper\n    viewMode: 0,\n    // 0, 1, 2, 3\n    // Define the dragging mode of the cropper\n    dragMode: DRAG_MODE_CROP,\n    // 'crop', 'move' or 'none'\n    // Define the initial aspect ratio of the crop box\n    initialAspectRatio: NaN,\n    // Define the aspect ratio of the crop box\n    aspectRatio: NaN,\n    // An object with the previous cropping result data\n    data: null,\n    // A selector for adding extra containers to preview\n    preview: \"\",\n    // Re-render the cropper when resize the window\n    responsive: true,\n    // Restore the cropped area after resize the window\n    restore: true,\n    // Check if the current image is a cross-origin image\n    checkCrossOrigin: true,\n    // Check the current image's Exif Orientation information\n    checkOrientation: true,\n    // Show the black modal\n    modal: true,\n    // Show the dashed lines for guiding\n    guides: true,\n    // Show the center indicator for guiding\n    center: true,\n    // Show the white modal to highlight the crop box\n    highlight: true,\n    // Show the grid background\n    background: true,\n    // Enable to crop the image automatically when initialize\n    autoCrop: true,\n    // Define the percentage of automatic cropping area when initializes\n    autoCropArea: 0.8,\n    // Enable to move the image\n    movable: true,\n    // Enable to rotate the image\n    rotatable: true,\n    // Enable to scale the image\n    scalable: true,\n    // Enable to zoom the image\n    zoomable: true,\n    // Enable to zoom the image by dragging touch\n    zoomOnTouch: true,\n    // Enable to zoom the image by wheeling mouse\n    zoomOnWheel: true,\n    // Define zoom ratio when zoom the image by wheeling mouse\n    wheelZoomRatio: 0.1,\n    // Enable to move the crop box\n    cropBoxMovable: true,\n    // Enable to resize the crop box\n    cropBoxResizable: true,\n    // Toggle drag mode between \"crop\" and \"move\" when click twice on the cropper\n    toggleDragModeOnDblclick: true,\n    // Size limitation\n    minCanvasWidth: 0,\n    minCanvasHeight: 0,\n    minCropBoxWidth: 0,\n    minCropBoxHeight: 0,\n    minContainerWidth: MIN_CONTAINER_WIDTH,\n    minContainerHeight: MIN_CONTAINER_HEIGHT,\n    // Shortcuts of events\n    ready: null,\n    cropstart: null,\n    cropmove: null,\n    cropend: null,\n    crop: null,\n    zoom: null\n};\nvar TEMPLATE = '<div class=\"cropper-container\" touch-action=\"none\">' + '<div class=\"cropper-wrap-box\">' + '<div class=\"cropper-canvas\"></div>' + \"</div>\" + '<div class=\"cropper-drag-box\"></div>' + '<div class=\"cropper-crop-box\">' + '<span class=\"cropper-view-box\"></span>' + '<span class=\"cropper-dashed dashed-h\"></span>' + '<span class=\"cropper-dashed dashed-v\"></span>' + '<span class=\"cropper-center\"></span>' + '<span class=\"cropper-face\"></span>' + '<span class=\"cropper-line line-e\" data-cropper-action=\"e\"></span>' + '<span class=\"cropper-line line-n\" data-cropper-action=\"n\"></span>' + '<span class=\"cropper-line line-w\" data-cropper-action=\"w\"></span>' + '<span class=\"cropper-line line-s\" data-cropper-action=\"s\"></span>' + '<span class=\"cropper-point point-e\" data-cropper-action=\"e\"></span>' + '<span class=\"cropper-point point-n\" data-cropper-action=\"n\"></span>' + '<span class=\"cropper-point point-w\" data-cropper-action=\"w\"></span>' + '<span class=\"cropper-point point-s\" data-cropper-action=\"s\"></span>' + '<span class=\"cropper-point point-ne\" data-cropper-action=\"ne\"></span>' + '<span class=\"cropper-point point-nw\" data-cropper-action=\"nw\"></span>' + '<span class=\"cropper-point point-sw\" data-cropper-action=\"sw\"></span>' + '<span class=\"cropper-point point-se\" data-cropper-action=\"se\"></span>' + \"</div>\" + \"</div>\";\n/**\n * Check if the given value is not a number.\n */ var isNaN = Number.isNaN || WINDOW.isNaN;\n/**\n * Check if the given value is a number.\n * @param {*} value - The value to check.\n * @returns {boolean} Returns `true` if the given value is a number, else `false`.\n */ function isNumber(value) {\n    return typeof value === \"number\" && !isNaN(value);\n}\n/**\n * Check if the given value is a positive number.\n * @param {*} value - The value to check.\n * @returns {boolean} Returns `true` if the given value is a positive number, else `false`.\n */ var isPositiveNumber = function isPositiveNumber(value) {\n    return value > 0 && value < Infinity;\n};\n/**\n * Check if the given value is undefined.\n * @param {*} value - The value to check.\n * @returns {boolean} Returns `true` if the given value is undefined, else `false`.\n */ function isUndefined(value) {\n    return typeof value === \"undefined\";\n}\n/**\n * Check if the given value is an object.\n * @param {*} value - The value to check.\n * @returns {boolean} Returns `true` if the given value is an object, else `false`.\n */ function isObject(value) {\n    return _typeof(value) === \"object\" && value !== null;\n}\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n/**\n * Check if the given value is a plain object.\n * @param {*} value - The value to check.\n * @returns {boolean} Returns `true` if the given value is a plain object, else `false`.\n */ function isPlainObject(value) {\n    if (!isObject(value)) {\n        return false;\n    }\n    try {\n        var _constructor = value.constructor;\n        var prototype = _constructor.prototype;\n        return _constructor && prototype && hasOwnProperty.call(prototype, \"isPrototypeOf\");\n    } catch (error) {\n        return false;\n    }\n}\n/**\n * Check if the given value is a function.\n * @param {*} value - The value to check.\n * @returns {boolean} Returns `true` if the given value is a function, else `false`.\n */ function isFunction(value) {\n    return typeof value === \"function\";\n}\nvar slice = Array.prototype.slice;\n/**\n * Convert array-like or iterable object to an array.\n * @param {*} value - The value to convert.\n * @returns {Array} Returns a new array.\n */ function toArray(value) {\n    return Array.from ? Array.from(value) : slice.call(value);\n}\n/**\n * Iterate the given data.\n * @param {*} data - The data to iterate.\n * @param {Function} callback - The process function for each element.\n * @returns {*} The original data.\n */ function forEach(data, callback) {\n    if (data && isFunction(callback)) {\n        if (Array.isArray(data) || isNumber(data.length)) {\n            toArray(data).forEach(function(value, key) {\n                callback.call(data, value, key, data);\n            });\n        } else if (isObject(data)) {\n            Object.keys(data).forEach(function(key) {\n                callback.call(data, data[key], key, data);\n            });\n        }\n    }\n    return data;\n}\n/**\n * Extend the given object.\n * @param {*} target - The target object to extend.\n * @param {*} args - The rest objects for merging to the target object.\n * @returns {Object} The extended object.\n */ var assign = Object.assign || function assign(target) {\n    for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n        args[_key - 1] = arguments[_key];\n    }\n    if (isObject(target) && args.length > 0) {\n        args.forEach(function(arg) {\n            if (isObject(arg)) {\n                Object.keys(arg).forEach(function(key) {\n                    target[key] = arg[key];\n                });\n            }\n        });\n    }\n    return target;\n};\nvar REGEXP_DECIMALS = /\\.\\d*(?:0|9){12}\\d*$/;\n/**\n * Normalize decimal number.\n * Check out {@link https://0.30000000000000004.com/}\n * @param {number} value - The value to normalize.\n * @param {number} [times=100000000000] - The times for normalizing.\n * @returns {number} Returns the normalized number.\n */ function normalizeDecimalNumber(value) {\n    var times = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100000000000;\n    return REGEXP_DECIMALS.test(value) ? Math.round(value * times) / times : value;\n}\nvar REGEXP_SUFFIX = /^width|height|left|top|marginLeft|marginTop$/;\n/**\n * Apply styles to the given element.\n * @param {Element} element - The target element.\n * @param {Object} styles - The styles for applying.\n */ function setStyle(element, styles) {\n    var style = element.style;\n    forEach(styles, function(value, property) {\n        if (REGEXP_SUFFIX.test(property) && isNumber(value)) {\n            value = \"\".concat(value, \"px\");\n        }\n        style[property] = value;\n    });\n}\n/**\n * Check if the given element has a special class.\n * @param {Element} element - The element to check.\n * @param {string} value - The class to search.\n * @returns {boolean} Returns `true` if the special class was found.\n */ function hasClass(element, value) {\n    return element.classList ? element.classList.contains(value) : element.className.indexOf(value) > -1;\n}\n/**\n * Add classes to the given element.\n * @param {Element} element - The target element.\n * @param {string} value - The classes to be added.\n */ function addClass(element, value) {\n    if (!value) {\n        return;\n    }\n    if (isNumber(element.length)) {\n        forEach(element, function(elem) {\n            addClass(elem, value);\n        });\n        return;\n    }\n    if (element.classList) {\n        element.classList.add(value);\n        return;\n    }\n    var className = element.className.trim();\n    if (!className) {\n        element.className = value;\n    } else if (className.indexOf(value) < 0) {\n        element.className = \"\".concat(className, \" \").concat(value);\n    }\n}\n/**\n * Remove classes from the given element.\n * @param {Element} element - The target element.\n * @param {string} value - The classes to be removed.\n */ function removeClass(element, value) {\n    if (!value) {\n        return;\n    }\n    if (isNumber(element.length)) {\n        forEach(element, function(elem) {\n            removeClass(elem, value);\n        });\n        return;\n    }\n    if (element.classList) {\n        element.classList.remove(value);\n        return;\n    }\n    if (element.className.indexOf(value) >= 0) {\n        element.className = element.className.replace(value, \"\");\n    }\n}\n/**\n * Add or remove classes from the given element.\n * @param {Element} element - The target element.\n * @param {string} value - The classes to be toggled.\n * @param {boolean} added - Add only.\n */ function toggleClass(element, value, added) {\n    if (!value) {\n        return;\n    }\n    if (isNumber(element.length)) {\n        forEach(element, function(elem) {\n            toggleClass(elem, value, added);\n        });\n        return;\n    }\n    // IE10-11 doesn't support the second parameter of `classList.toggle`\n    if (added) {\n        addClass(element, value);\n    } else {\n        removeClass(element, value);\n    }\n}\nvar REGEXP_CAMEL_CASE = /([a-z\\d])([A-Z])/g;\n/**\n * Transform the given string from camelCase to kebab-case\n * @param {string} value - The value to transform.\n * @returns {string} The transformed value.\n */ function toParamCase(value) {\n    return value.replace(REGEXP_CAMEL_CASE, \"$1-$2\").toLowerCase();\n}\n/**\n * Get data from the given element.\n * @param {Element} element - The target element.\n * @param {string} name - The data key to get.\n * @returns {string} The data value.\n */ function getData(element, name) {\n    if (isObject(element[name])) {\n        return element[name];\n    }\n    if (element.dataset) {\n        return element.dataset[name];\n    }\n    return element.getAttribute(\"data-\".concat(toParamCase(name)));\n}\n/**\n * Set data to the given element.\n * @param {Element} element - The target element.\n * @param {string} name - The data key to set.\n * @param {string} data - The data value.\n */ function setData(element, name, data) {\n    if (isObject(data)) {\n        element[name] = data;\n    } else if (element.dataset) {\n        element.dataset[name] = data;\n    } else {\n        element.setAttribute(\"data-\".concat(toParamCase(name)), data);\n    }\n}\n/**\n * Remove data from the given element.\n * @param {Element} element - The target element.\n * @param {string} name - The data key to remove.\n */ function removeData(element, name) {\n    if (isObject(element[name])) {\n        try {\n            delete element[name];\n        } catch (error) {\n            element[name] = undefined;\n        }\n    } else if (element.dataset) {\n        // #128 Safari not allows to delete dataset property\n        try {\n            delete element.dataset[name];\n        } catch (error) {\n            element.dataset[name] = undefined;\n        }\n    } else {\n        element.removeAttribute(\"data-\".concat(toParamCase(name)));\n    }\n}\nvar REGEXP_SPACES = /\\s\\s*/;\nvar onceSupported = function() {\n    var supported = false;\n    if (IS_BROWSER) {\n        var once = false;\n        var listener = function listener() {};\n        var options = Object.defineProperty({}, \"once\", {\n            get: function get() {\n                supported = true;\n                return once;\n            },\n            /**\n       * This setter can fix a `TypeError` in strict mode\n       * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Getter_only}\n       * @param {boolean} value - The value to set\n       */ set: function set(value) {\n                once = value;\n            }\n        });\n        WINDOW.addEventListener(\"test\", listener, options);\n        WINDOW.removeEventListener(\"test\", listener, options);\n    }\n    return supported;\n}();\n/**\n * Remove event listener from the target element.\n * @param {Element} element - The event target.\n * @param {string} type - The event type(s).\n * @param {Function} listener - The event listener.\n * @param {Object} options - The event options.\n */ function removeListener(element, type, listener) {\n    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    var handler = listener;\n    type.trim().split(REGEXP_SPACES).forEach(function(event) {\n        if (!onceSupported) {\n            var listeners = element.listeners;\n            if (listeners && listeners[event] && listeners[event][listener]) {\n                handler = listeners[event][listener];\n                delete listeners[event][listener];\n                if (Object.keys(listeners[event]).length === 0) {\n                    delete listeners[event];\n                }\n                if (Object.keys(listeners).length === 0) {\n                    delete element.listeners;\n                }\n            }\n        }\n        element.removeEventListener(event, handler, options);\n    });\n}\n/**\n * Add event listener to the target element.\n * @param {Element} element - The event target.\n * @param {string} type - The event type(s).\n * @param {Function} listener - The event listener.\n * @param {Object} options - The event options.\n */ function addListener(element, type, listener) {\n    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    var _handler = listener;\n    type.trim().split(REGEXP_SPACES).forEach(function(event) {\n        if (options.once && !onceSupported) {\n            var _element$listeners = element.listeners, listeners = _element$listeners === void 0 ? {} : _element$listeners;\n            _handler = function handler() {\n                delete listeners[event][listener];\n                element.removeEventListener(event, _handler, options);\n                for(var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++){\n                    args[_key2] = arguments[_key2];\n                }\n                listener.apply(element, args);\n            };\n            if (!listeners[event]) {\n                listeners[event] = {};\n            }\n            if (listeners[event][listener]) {\n                element.removeEventListener(event, listeners[event][listener], options);\n            }\n            listeners[event][listener] = _handler;\n            element.listeners = listeners;\n        }\n        element.addEventListener(event, _handler, options);\n    });\n}\n/**\n * Dispatch event on the target element.\n * @param {Element} element - The event target.\n * @param {string} type - The event type(s).\n * @param {Object} data - The additional event data.\n * @returns {boolean} Indicate if the event is default prevented or not.\n */ function dispatchEvent(element, type, data) {\n    var event;\n    // Event and CustomEvent on IE9-11 are global objects, not constructors\n    if (isFunction(Event) && isFunction(CustomEvent)) {\n        event = new CustomEvent(type, {\n            detail: data,\n            bubbles: true,\n            cancelable: true\n        });\n    } else {\n        event = document.createEvent(\"CustomEvent\");\n        event.initCustomEvent(type, true, true, data);\n    }\n    return element.dispatchEvent(event);\n}\n/**\n * Get the offset base on the document.\n * @param {Element} element - The target element.\n * @returns {Object} The offset data.\n */ function getOffset(element) {\n    var box = element.getBoundingClientRect();\n    return {\n        left: box.left + (window.pageXOffset - document.documentElement.clientLeft),\n        top: box.top + (window.pageYOffset - document.documentElement.clientTop)\n    };\n}\nvar location = WINDOW.location;\nvar REGEXP_ORIGINS = /^(\\w+:)\\/\\/([^:/?#]*):?(\\d*)/i;\n/**\n * Check if the given URL is a cross origin URL.\n * @param {string} url - The target URL.\n * @returns {boolean} Returns `true` if the given URL is a cross origin URL, else `false`.\n */ function isCrossOriginURL(url) {\n    var parts = url.match(REGEXP_ORIGINS);\n    return parts !== null && (parts[1] !== location.protocol || parts[2] !== location.hostname || parts[3] !== location.port);\n}\n/**\n * Add timestamp to the given URL.\n * @param {string} url - The target URL.\n * @returns {string} The result URL.\n */ function addTimestamp(url) {\n    var timestamp = \"timestamp=\".concat(new Date().getTime());\n    return url + (url.indexOf(\"?\") === -1 ? \"?\" : \"&\") + timestamp;\n}\n/**\n * Get transforms base on the given object.\n * @param {Object} obj - The target object.\n * @returns {string} A string contains transform values.\n */ function getTransforms(_ref) {\n    var rotate = _ref.rotate, scaleX = _ref.scaleX, scaleY = _ref.scaleY, translateX = _ref.translateX, translateY = _ref.translateY;\n    var values = [];\n    if (isNumber(translateX) && translateX !== 0) {\n        values.push(\"translateX(\".concat(translateX, \"px)\"));\n    }\n    if (isNumber(translateY) && translateY !== 0) {\n        values.push(\"translateY(\".concat(translateY, \"px)\"));\n    }\n    // Rotate should come first before scale to match orientation transform\n    if (isNumber(rotate) && rotate !== 0) {\n        values.push(\"rotate(\".concat(rotate, \"deg)\"));\n    }\n    if (isNumber(scaleX) && scaleX !== 1) {\n        values.push(\"scaleX(\".concat(scaleX, \")\"));\n    }\n    if (isNumber(scaleY) && scaleY !== 1) {\n        values.push(\"scaleY(\".concat(scaleY, \")\"));\n    }\n    var transform = values.length ? values.join(\" \") : \"none\";\n    return {\n        WebkitTransform: transform,\n        msTransform: transform,\n        transform: transform\n    };\n}\n/**\n * Get the max ratio of a group of pointers.\n * @param {string} pointers - The target pointers.\n * @returns {number} The result ratio.\n */ function getMaxZoomRatio(pointers) {\n    var pointers2 = _objectSpread2({}, pointers);\n    var maxRatio = 0;\n    forEach(pointers, function(pointer, pointerId) {\n        delete pointers2[pointerId];\n        forEach(pointers2, function(pointer2) {\n            var x1 = Math.abs(pointer.startX - pointer2.startX);\n            var y1 = Math.abs(pointer.startY - pointer2.startY);\n            var x2 = Math.abs(pointer.endX - pointer2.endX);\n            var y2 = Math.abs(pointer.endY - pointer2.endY);\n            var z1 = Math.sqrt(x1 * x1 + y1 * y1);\n            var z2 = Math.sqrt(x2 * x2 + y2 * y2);\n            var ratio = (z2 - z1) / z1;\n            if (Math.abs(ratio) > Math.abs(maxRatio)) {\n                maxRatio = ratio;\n            }\n        });\n    });\n    return maxRatio;\n}\n/**\n * Get a pointer from an event object.\n * @param {Object} event - The target event object.\n * @param {boolean} endOnly - Indicates if only returns the end point coordinate or not.\n * @returns {Object} The result pointer contains start and/or end point coordinates.\n */ function getPointer(_ref2, endOnly) {\n    var pageX = _ref2.pageX, pageY = _ref2.pageY;\n    var end = {\n        endX: pageX,\n        endY: pageY\n    };\n    return endOnly ? end : _objectSpread2({\n        startX: pageX,\n        startY: pageY\n    }, end);\n}\n/**\n * Get the center point coordinate of a group of pointers.\n * @param {Object} pointers - The target pointers.\n * @returns {Object} The center point coordinate.\n */ function getPointersCenter(pointers) {\n    var pageX = 0;\n    var pageY = 0;\n    var count = 0;\n    forEach(pointers, function(_ref3) {\n        var startX = _ref3.startX, startY = _ref3.startY;\n        pageX += startX;\n        pageY += startY;\n        count += 1;\n    });\n    pageX /= count;\n    pageY /= count;\n    return {\n        pageX: pageX,\n        pageY: pageY\n    };\n}\n/**\n * Get the max sizes in a rectangle under the given aspect ratio.\n * @param {Object} data - The original sizes.\n * @param {string} [type='contain'] - The adjust type.\n * @returns {Object} The result sizes.\n */ function getAdjustedSizes(_ref4) {\n    var aspectRatio = _ref4.aspectRatio, height = _ref4.height, width = _ref4.width;\n    var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"contain\";\n    var isValidWidth = isPositiveNumber(width);\n    var isValidHeight = isPositiveNumber(height);\n    if (isValidWidth && isValidHeight) {\n        var adjustedWidth = height * aspectRatio;\n        if (type === \"contain\" && adjustedWidth > width || type === \"cover\" && adjustedWidth < width) {\n            height = width / aspectRatio;\n        } else {\n            width = height * aspectRatio;\n        }\n    } else if (isValidWidth) {\n        height = width / aspectRatio;\n    } else if (isValidHeight) {\n        width = height * aspectRatio;\n    }\n    return {\n        width: width,\n        height: height\n    };\n}\n/**\n * Get the new sizes of a rectangle after rotated.\n * @param {Object} data - The original sizes.\n * @returns {Object} The result sizes.\n */ function getRotatedSizes(_ref5) {\n    var width = _ref5.width, height = _ref5.height, degree = _ref5.degree;\n    degree = Math.abs(degree) % 180;\n    if (degree === 90) {\n        return {\n            width: height,\n            height: width\n        };\n    }\n    var arc = degree % 90 * Math.PI / 180;\n    var sinArc = Math.sin(arc);\n    var cosArc = Math.cos(arc);\n    var newWidth = width * cosArc + height * sinArc;\n    var newHeight = width * sinArc + height * cosArc;\n    return degree > 90 ? {\n        width: newHeight,\n        height: newWidth\n    } : {\n        width: newWidth,\n        height: newHeight\n    };\n}\n/**\n * Get a canvas which drew the given image.\n * @param {HTMLImageElement} image - The image for drawing.\n * @param {Object} imageData - The image data.\n * @param {Object} canvasData - The canvas data.\n * @param {Object} options - The options.\n * @returns {HTMLCanvasElement} The result canvas.\n */ function getSourceCanvas(image, _ref6, _ref7, _ref8) {\n    var imageAspectRatio = _ref6.aspectRatio, imageNaturalWidth = _ref6.naturalWidth, imageNaturalHeight = _ref6.naturalHeight, _ref6$rotate = _ref6.rotate, rotate = _ref6$rotate === void 0 ? 0 : _ref6$rotate, _ref6$scaleX = _ref6.scaleX, scaleX = _ref6$scaleX === void 0 ? 1 : _ref6$scaleX, _ref6$scaleY = _ref6.scaleY, scaleY = _ref6$scaleY === void 0 ? 1 : _ref6$scaleY;\n    var aspectRatio = _ref7.aspectRatio, naturalWidth = _ref7.naturalWidth, naturalHeight = _ref7.naturalHeight;\n    var _ref8$fillColor = _ref8.fillColor, fillColor = _ref8$fillColor === void 0 ? \"transparent\" : _ref8$fillColor, _ref8$imageSmoothingE = _ref8.imageSmoothingEnabled, imageSmoothingEnabled = _ref8$imageSmoothingE === void 0 ? true : _ref8$imageSmoothingE, _ref8$imageSmoothingQ = _ref8.imageSmoothingQuality, imageSmoothingQuality = _ref8$imageSmoothingQ === void 0 ? \"low\" : _ref8$imageSmoothingQ, _ref8$maxWidth = _ref8.maxWidth, maxWidth = _ref8$maxWidth === void 0 ? Infinity : _ref8$maxWidth, _ref8$maxHeight = _ref8.maxHeight, maxHeight = _ref8$maxHeight === void 0 ? Infinity : _ref8$maxHeight, _ref8$minWidth = _ref8.minWidth, minWidth = _ref8$minWidth === void 0 ? 0 : _ref8$minWidth, _ref8$minHeight = _ref8.minHeight, minHeight = _ref8$minHeight === void 0 ? 0 : _ref8$minHeight;\n    var canvas = document.createElement(\"canvas\");\n    var context = canvas.getContext(\"2d\");\n    var maxSizes = getAdjustedSizes({\n        aspectRatio: aspectRatio,\n        width: maxWidth,\n        height: maxHeight\n    });\n    var minSizes = getAdjustedSizes({\n        aspectRatio: aspectRatio,\n        width: minWidth,\n        height: minHeight\n    }, \"cover\");\n    var width = Math.min(maxSizes.width, Math.max(minSizes.width, naturalWidth));\n    var height = Math.min(maxSizes.height, Math.max(minSizes.height, naturalHeight));\n    // Note: should always use image's natural sizes for drawing as\n    // imageData.naturalWidth === canvasData.naturalHeight when rotate % 180 === 90\n    var destMaxSizes = getAdjustedSizes({\n        aspectRatio: imageAspectRatio,\n        width: maxWidth,\n        height: maxHeight\n    });\n    var destMinSizes = getAdjustedSizes({\n        aspectRatio: imageAspectRatio,\n        width: minWidth,\n        height: minHeight\n    }, \"cover\");\n    var destWidth = Math.min(destMaxSizes.width, Math.max(destMinSizes.width, imageNaturalWidth));\n    var destHeight = Math.min(destMaxSizes.height, Math.max(destMinSizes.height, imageNaturalHeight));\n    var params = [\n        -destWidth / 2,\n        -destHeight / 2,\n        destWidth,\n        destHeight\n    ];\n    canvas.width = normalizeDecimalNumber(width);\n    canvas.height = normalizeDecimalNumber(height);\n    context.fillStyle = fillColor;\n    context.fillRect(0, 0, width, height);\n    context.save();\n    context.translate(width / 2, height / 2);\n    context.rotate(rotate * Math.PI / 180);\n    context.scale(scaleX, scaleY);\n    context.imageSmoothingEnabled = imageSmoothingEnabled;\n    context.imageSmoothingQuality = imageSmoothingQuality;\n    context.drawImage.apply(context, [\n        image\n    ].concat(_toConsumableArray(params.map(function(param) {\n        return Math.floor(normalizeDecimalNumber(param));\n    }))));\n    context.restore();\n    return canvas;\n}\nvar fromCharCode = String.fromCharCode;\n/**\n * Get string from char code in data view.\n * @param {DataView} dataView - The data view for read.\n * @param {number} start - The start index.\n * @param {number} length - The read length.\n * @returns {string} The read result.\n */ function getStringFromCharCode(dataView, start, length) {\n    var str = \"\";\n    length += start;\n    for(var i = start; i < length; i += 1){\n        str += fromCharCode(dataView.getUint8(i));\n    }\n    return str;\n}\nvar REGEXP_DATA_URL_HEAD = /^data:.*,/;\n/**\n * Transform Data URL to array buffer.\n * @param {string} dataURL - The Data URL to transform.\n * @returns {ArrayBuffer} The result array buffer.\n */ function dataURLToArrayBuffer(dataURL) {\n    var base64 = dataURL.replace(REGEXP_DATA_URL_HEAD, \"\");\n    var binary = atob(base64);\n    var arrayBuffer = new ArrayBuffer(binary.length);\n    var uint8 = new Uint8Array(arrayBuffer);\n    forEach(uint8, function(value, i) {\n        uint8[i] = binary.charCodeAt(i);\n    });\n    return arrayBuffer;\n}\n/**\n * Transform array buffer to Data URL.\n * @param {ArrayBuffer} arrayBuffer - The array buffer to transform.\n * @param {string} mimeType - The mime type of the Data URL.\n * @returns {string} The result Data URL.\n */ function arrayBufferToDataURL(arrayBuffer, mimeType) {\n    var chunks = [];\n    // Chunk Typed Array for better performance (#435)\n    var chunkSize = 8192;\n    var uint8 = new Uint8Array(arrayBuffer);\n    while(uint8.length > 0){\n        // XXX: Babel's `toConsumableArray` helper will throw error in IE or Safari 9\n        // eslint-disable-next-line prefer-spread\n        chunks.push(fromCharCode.apply(null, toArray(uint8.subarray(0, chunkSize))));\n        uint8 = uint8.subarray(chunkSize);\n    }\n    return \"data:\".concat(mimeType, \";base64,\").concat(btoa(chunks.join(\"\")));\n}\n/**\n * Get orientation value from given array buffer.\n * @param {ArrayBuffer} arrayBuffer - The array buffer to read.\n * @returns {number} The read orientation value.\n */ function resetAndGetOrientation(arrayBuffer) {\n    var dataView = new DataView(arrayBuffer);\n    var orientation;\n    // Ignores range error when the image does not have correct Exif information\n    try {\n        var littleEndian;\n        var app1Start;\n        var ifdStart;\n        // Only handle JPEG image (start by 0xFFD8)\n        if (dataView.getUint8(0) === 0xFF && dataView.getUint8(1) === 0xD8) {\n            var length = dataView.byteLength;\n            var offset = 2;\n            while(offset + 1 < length){\n                if (dataView.getUint8(offset) === 0xFF && dataView.getUint8(offset + 1) === 0xE1) {\n                    app1Start = offset;\n                    break;\n                }\n                offset += 1;\n            }\n        }\n        if (app1Start) {\n            var exifIDCode = app1Start + 4;\n            var tiffOffset = app1Start + 10;\n            if (getStringFromCharCode(dataView, exifIDCode, 4) === \"Exif\") {\n                var endianness = dataView.getUint16(tiffOffset);\n                littleEndian = endianness === 0x4949;\n                if (littleEndian || endianness === 0x4D4D /* bigEndian */ ) {\n                    if (dataView.getUint16(tiffOffset + 2, littleEndian) === 0x002A) {\n                        var firstIFDOffset = dataView.getUint32(tiffOffset + 4, littleEndian);\n                        if (firstIFDOffset >= 0x00000008) {\n                            ifdStart = tiffOffset + firstIFDOffset;\n                        }\n                    }\n                }\n            }\n        }\n        if (ifdStart) {\n            var _length = dataView.getUint16(ifdStart, littleEndian);\n            var _offset;\n            var i;\n            for(i = 0; i < _length; i += 1){\n                _offset = ifdStart + i * 12 + 2;\n                if (dataView.getUint16(_offset, littleEndian) === 0x0112 /* Orientation */ ) {\n                    // 8 is the offset of the current tag's value\n                    _offset += 8;\n                    // Get the original orientation value\n                    orientation = dataView.getUint16(_offset, littleEndian);\n                    // Override the orientation with its default value\n                    dataView.setUint16(_offset, 1, littleEndian);\n                    break;\n                }\n            }\n        }\n    } catch (error) {\n        orientation = 1;\n    }\n    return orientation;\n}\n/**\n * Parse Exif Orientation value.\n * @param {number} orientation - The orientation to parse.\n * @returns {Object} The parsed result.\n */ function parseOrientation(orientation) {\n    var rotate = 0;\n    var scaleX = 1;\n    var scaleY = 1;\n    switch(orientation){\n        // Flip horizontal\n        case 2:\n            scaleX = -1;\n            break;\n        // Rotate left 180°\n        case 3:\n            rotate = -180;\n            break;\n        // Flip vertical\n        case 4:\n            scaleY = -1;\n            break;\n        // Flip vertical and rotate right 90°\n        case 5:\n            rotate = 90;\n            scaleY = -1;\n            break;\n        // Rotate right 90°\n        case 6:\n            rotate = 90;\n            break;\n        // Flip horizontal and rotate right 90°\n        case 7:\n            rotate = 90;\n            scaleX = -1;\n            break;\n        // Rotate left 90°\n        case 8:\n            rotate = -90;\n            break;\n    }\n    return {\n        rotate: rotate,\n        scaleX: scaleX,\n        scaleY: scaleY\n    };\n}\nvar render = {\n    render: function render() {\n        this.initContainer();\n        this.initCanvas();\n        this.initCropBox();\n        this.renderCanvas();\n        if (this.cropped) {\n            this.renderCropBox();\n        }\n    },\n    initContainer: function initContainer() {\n        var element = this.element, options = this.options, container = this.container, cropper = this.cropper;\n        var minWidth = Number(options.minContainerWidth);\n        var minHeight = Number(options.minContainerHeight);\n        addClass(cropper, CLASS_HIDDEN);\n        removeClass(element, CLASS_HIDDEN);\n        var containerData = {\n            width: Math.max(container.offsetWidth, minWidth >= 0 ? minWidth : MIN_CONTAINER_WIDTH),\n            height: Math.max(container.offsetHeight, minHeight >= 0 ? minHeight : MIN_CONTAINER_HEIGHT)\n        };\n        this.containerData = containerData;\n        setStyle(cropper, {\n            width: containerData.width,\n            height: containerData.height\n        });\n        addClass(element, CLASS_HIDDEN);\n        removeClass(cropper, CLASS_HIDDEN);\n    },\n    // Canvas (image wrapper)\n    initCanvas: function initCanvas() {\n        var containerData = this.containerData, imageData = this.imageData;\n        var viewMode = this.options.viewMode;\n        var rotated = Math.abs(imageData.rotate) % 180 === 90;\n        var naturalWidth = rotated ? imageData.naturalHeight : imageData.naturalWidth;\n        var naturalHeight = rotated ? imageData.naturalWidth : imageData.naturalHeight;\n        var aspectRatio = naturalWidth / naturalHeight;\n        var canvasWidth = containerData.width;\n        var canvasHeight = containerData.height;\n        if (containerData.height * aspectRatio > containerData.width) {\n            if (viewMode === 3) {\n                canvasWidth = containerData.height * aspectRatio;\n            } else {\n                canvasHeight = containerData.width / aspectRatio;\n            }\n        } else if (viewMode === 3) {\n            canvasHeight = containerData.width / aspectRatio;\n        } else {\n            canvasWidth = containerData.height * aspectRatio;\n        }\n        var canvasData = {\n            aspectRatio: aspectRatio,\n            naturalWidth: naturalWidth,\n            naturalHeight: naturalHeight,\n            width: canvasWidth,\n            height: canvasHeight\n        };\n        this.canvasData = canvasData;\n        this.limited = viewMode === 1 || viewMode === 2;\n        this.limitCanvas(true, true);\n        canvasData.width = Math.min(Math.max(canvasData.width, canvasData.minWidth), canvasData.maxWidth);\n        canvasData.height = Math.min(Math.max(canvasData.height, canvasData.minHeight), canvasData.maxHeight);\n        canvasData.left = (containerData.width - canvasData.width) / 2;\n        canvasData.top = (containerData.height - canvasData.height) / 2;\n        canvasData.oldLeft = canvasData.left;\n        canvasData.oldTop = canvasData.top;\n        this.initialCanvasData = assign({}, canvasData);\n    },\n    limitCanvas: function limitCanvas(sizeLimited, positionLimited) {\n        var options = this.options, containerData = this.containerData, canvasData = this.canvasData, cropBoxData = this.cropBoxData;\n        var viewMode = options.viewMode;\n        var aspectRatio = canvasData.aspectRatio;\n        var cropped = this.cropped && cropBoxData;\n        if (sizeLimited) {\n            var minCanvasWidth = Number(options.minCanvasWidth) || 0;\n            var minCanvasHeight = Number(options.minCanvasHeight) || 0;\n            if (viewMode > 1) {\n                minCanvasWidth = Math.max(minCanvasWidth, containerData.width);\n                minCanvasHeight = Math.max(minCanvasHeight, containerData.height);\n                if (viewMode === 3) {\n                    if (minCanvasHeight * aspectRatio > minCanvasWidth) {\n                        minCanvasWidth = minCanvasHeight * aspectRatio;\n                    } else {\n                        minCanvasHeight = minCanvasWidth / aspectRatio;\n                    }\n                }\n            } else if (viewMode > 0) {\n                if (minCanvasWidth) {\n                    minCanvasWidth = Math.max(minCanvasWidth, cropped ? cropBoxData.width : 0);\n                } else if (minCanvasHeight) {\n                    minCanvasHeight = Math.max(minCanvasHeight, cropped ? cropBoxData.height : 0);\n                } else if (cropped) {\n                    minCanvasWidth = cropBoxData.width;\n                    minCanvasHeight = cropBoxData.height;\n                    if (minCanvasHeight * aspectRatio > minCanvasWidth) {\n                        minCanvasWidth = minCanvasHeight * aspectRatio;\n                    } else {\n                        minCanvasHeight = minCanvasWidth / aspectRatio;\n                    }\n                }\n            }\n            var _getAdjustedSizes = getAdjustedSizes({\n                aspectRatio: aspectRatio,\n                width: minCanvasWidth,\n                height: minCanvasHeight\n            });\n            minCanvasWidth = _getAdjustedSizes.width;\n            minCanvasHeight = _getAdjustedSizes.height;\n            canvasData.minWidth = minCanvasWidth;\n            canvasData.minHeight = minCanvasHeight;\n            canvasData.maxWidth = Infinity;\n            canvasData.maxHeight = Infinity;\n        }\n        if (positionLimited) {\n            if (viewMode > (cropped ? 0 : 1)) {\n                var newCanvasLeft = containerData.width - canvasData.width;\n                var newCanvasTop = containerData.height - canvasData.height;\n                canvasData.minLeft = Math.min(0, newCanvasLeft);\n                canvasData.minTop = Math.min(0, newCanvasTop);\n                canvasData.maxLeft = Math.max(0, newCanvasLeft);\n                canvasData.maxTop = Math.max(0, newCanvasTop);\n                if (cropped && this.limited) {\n                    canvasData.minLeft = Math.min(cropBoxData.left, cropBoxData.left + (cropBoxData.width - canvasData.width));\n                    canvasData.minTop = Math.min(cropBoxData.top, cropBoxData.top + (cropBoxData.height - canvasData.height));\n                    canvasData.maxLeft = cropBoxData.left;\n                    canvasData.maxTop = cropBoxData.top;\n                    if (viewMode === 2) {\n                        if (canvasData.width >= containerData.width) {\n                            canvasData.minLeft = Math.min(0, newCanvasLeft);\n                            canvasData.maxLeft = Math.max(0, newCanvasLeft);\n                        }\n                        if (canvasData.height >= containerData.height) {\n                            canvasData.minTop = Math.min(0, newCanvasTop);\n                            canvasData.maxTop = Math.max(0, newCanvasTop);\n                        }\n                    }\n                }\n            } else {\n                canvasData.minLeft = -canvasData.width;\n                canvasData.minTop = -canvasData.height;\n                canvasData.maxLeft = containerData.width;\n                canvasData.maxTop = containerData.height;\n            }\n        }\n    },\n    renderCanvas: function renderCanvas(changed, transformed) {\n        var canvasData = this.canvasData, imageData = this.imageData;\n        if (transformed) {\n            var _getRotatedSizes = getRotatedSizes({\n                width: imageData.naturalWidth * Math.abs(imageData.scaleX || 1),\n                height: imageData.naturalHeight * Math.abs(imageData.scaleY || 1),\n                degree: imageData.rotate || 0\n            }), naturalWidth = _getRotatedSizes.width, naturalHeight = _getRotatedSizes.height;\n            var width = canvasData.width * (naturalWidth / canvasData.naturalWidth);\n            var height = canvasData.height * (naturalHeight / canvasData.naturalHeight);\n            canvasData.left -= (width - canvasData.width) / 2;\n            canvasData.top -= (height - canvasData.height) / 2;\n            canvasData.width = width;\n            canvasData.height = height;\n            canvasData.aspectRatio = naturalWidth / naturalHeight;\n            canvasData.naturalWidth = naturalWidth;\n            canvasData.naturalHeight = naturalHeight;\n            this.limitCanvas(true, false);\n        }\n        if (canvasData.width > canvasData.maxWidth || canvasData.width < canvasData.minWidth) {\n            canvasData.left = canvasData.oldLeft;\n        }\n        if (canvasData.height > canvasData.maxHeight || canvasData.height < canvasData.minHeight) {\n            canvasData.top = canvasData.oldTop;\n        }\n        canvasData.width = Math.min(Math.max(canvasData.width, canvasData.minWidth), canvasData.maxWidth);\n        canvasData.height = Math.min(Math.max(canvasData.height, canvasData.minHeight), canvasData.maxHeight);\n        this.limitCanvas(false, true);\n        canvasData.left = Math.min(Math.max(canvasData.left, canvasData.minLeft), canvasData.maxLeft);\n        canvasData.top = Math.min(Math.max(canvasData.top, canvasData.minTop), canvasData.maxTop);\n        canvasData.oldLeft = canvasData.left;\n        canvasData.oldTop = canvasData.top;\n        setStyle(this.canvas, assign({\n            width: canvasData.width,\n            height: canvasData.height\n        }, getTransforms({\n            translateX: canvasData.left,\n            translateY: canvasData.top\n        })));\n        this.renderImage(changed);\n        if (this.cropped && this.limited) {\n            this.limitCropBox(true, true);\n        }\n    },\n    renderImage: function renderImage(changed) {\n        var canvasData = this.canvasData, imageData = this.imageData;\n        var width = imageData.naturalWidth * (canvasData.width / canvasData.naturalWidth);\n        var height = imageData.naturalHeight * (canvasData.height / canvasData.naturalHeight);\n        assign(imageData, {\n            width: width,\n            height: height,\n            left: (canvasData.width - width) / 2,\n            top: (canvasData.height - height) / 2\n        });\n        setStyle(this.image, assign({\n            width: imageData.width,\n            height: imageData.height\n        }, getTransforms(assign({\n            translateX: imageData.left,\n            translateY: imageData.top\n        }, imageData))));\n        if (changed) {\n            this.output();\n        }\n    },\n    initCropBox: function initCropBox() {\n        var options = this.options, canvasData = this.canvasData;\n        var aspectRatio = options.aspectRatio || options.initialAspectRatio;\n        var autoCropArea = Number(options.autoCropArea) || 0.8;\n        var cropBoxData = {\n            width: canvasData.width,\n            height: canvasData.height\n        };\n        if (aspectRatio) {\n            if (canvasData.height * aspectRatio > canvasData.width) {\n                cropBoxData.height = cropBoxData.width / aspectRatio;\n            } else {\n                cropBoxData.width = cropBoxData.height * aspectRatio;\n            }\n        }\n        this.cropBoxData = cropBoxData;\n        this.limitCropBox(true, true);\n        // Initialize auto crop area\n        cropBoxData.width = Math.min(Math.max(cropBoxData.width, cropBoxData.minWidth), cropBoxData.maxWidth);\n        cropBoxData.height = Math.min(Math.max(cropBoxData.height, cropBoxData.minHeight), cropBoxData.maxHeight);\n        // The width/height of auto crop area must large than \"minWidth/Height\"\n        cropBoxData.width = Math.max(cropBoxData.minWidth, cropBoxData.width * autoCropArea);\n        cropBoxData.height = Math.max(cropBoxData.minHeight, cropBoxData.height * autoCropArea);\n        cropBoxData.left = canvasData.left + (canvasData.width - cropBoxData.width) / 2;\n        cropBoxData.top = canvasData.top + (canvasData.height - cropBoxData.height) / 2;\n        cropBoxData.oldLeft = cropBoxData.left;\n        cropBoxData.oldTop = cropBoxData.top;\n        this.initialCropBoxData = assign({}, cropBoxData);\n    },\n    limitCropBox: function limitCropBox(sizeLimited, positionLimited) {\n        var options = this.options, containerData = this.containerData, canvasData = this.canvasData, cropBoxData = this.cropBoxData, limited = this.limited;\n        var aspectRatio = options.aspectRatio;\n        if (sizeLimited) {\n            var minCropBoxWidth = Number(options.minCropBoxWidth) || 0;\n            var minCropBoxHeight = Number(options.minCropBoxHeight) || 0;\n            var maxCropBoxWidth = limited ? Math.min(containerData.width, canvasData.width, canvasData.width + canvasData.left, containerData.width - canvasData.left) : containerData.width;\n            var maxCropBoxHeight = limited ? Math.min(containerData.height, canvasData.height, canvasData.height + canvasData.top, containerData.height - canvasData.top) : containerData.height;\n            // The min/maxCropBoxWidth/Height must be less than container's width/height\n            minCropBoxWidth = Math.min(minCropBoxWidth, containerData.width);\n            minCropBoxHeight = Math.min(minCropBoxHeight, containerData.height);\n            if (aspectRatio) {\n                if (minCropBoxWidth && minCropBoxHeight) {\n                    if (minCropBoxHeight * aspectRatio > minCropBoxWidth) {\n                        minCropBoxHeight = minCropBoxWidth / aspectRatio;\n                    } else {\n                        minCropBoxWidth = minCropBoxHeight * aspectRatio;\n                    }\n                } else if (minCropBoxWidth) {\n                    minCropBoxHeight = minCropBoxWidth / aspectRatio;\n                } else if (minCropBoxHeight) {\n                    minCropBoxWidth = minCropBoxHeight * aspectRatio;\n                }\n                if (maxCropBoxHeight * aspectRatio > maxCropBoxWidth) {\n                    maxCropBoxHeight = maxCropBoxWidth / aspectRatio;\n                } else {\n                    maxCropBoxWidth = maxCropBoxHeight * aspectRatio;\n                }\n            }\n            // The minWidth/Height must be less than maxWidth/Height\n            cropBoxData.minWidth = Math.min(minCropBoxWidth, maxCropBoxWidth);\n            cropBoxData.minHeight = Math.min(minCropBoxHeight, maxCropBoxHeight);\n            cropBoxData.maxWidth = maxCropBoxWidth;\n            cropBoxData.maxHeight = maxCropBoxHeight;\n        }\n        if (positionLimited) {\n            if (limited) {\n                cropBoxData.minLeft = Math.max(0, canvasData.left);\n                cropBoxData.minTop = Math.max(0, canvasData.top);\n                cropBoxData.maxLeft = Math.min(containerData.width, canvasData.left + canvasData.width) - cropBoxData.width;\n                cropBoxData.maxTop = Math.min(containerData.height, canvasData.top + canvasData.height) - cropBoxData.height;\n            } else {\n                cropBoxData.minLeft = 0;\n                cropBoxData.minTop = 0;\n                cropBoxData.maxLeft = containerData.width - cropBoxData.width;\n                cropBoxData.maxTop = containerData.height - cropBoxData.height;\n            }\n        }\n    },\n    renderCropBox: function renderCropBox() {\n        var options = this.options, containerData = this.containerData, cropBoxData = this.cropBoxData;\n        if (cropBoxData.width > cropBoxData.maxWidth || cropBoxData.width < cropBoxData.minWidth) {\n            cropBoxData.left = cropBoxData.oldLeft;\n        }\n        if (cropBoxData.height > cropBoxData.maxHeight || cropBoxData.height < cropBoxData.minHeight) {\n            cropBoxData.top = cropBoxData.oldTop;\n        }\n        cropBoxData.width = Math.min(Math.max(cropBoxData.width, cropBoxData.minWidth), cropBoxData.maxWidth);\n        cropBoxData.height = Math.min(Math.max(cropBoxData.height, cropBoxData.minHeight), cropBoxData.maxHeight);\n        this.limitCropBox(false, true);\n        cropBoxData.left = Math.min(Math.max(cropBoxData.left, cropBoxData.minLeft), cropBoxData.maxLeft);\n        cropBoxData.top = Math.min(Math.max(cropBoxData.top, cropBoxData.minTop), cropBoxData.maxTop);\n        cropBoxData.oldLeft = cropBoxData.left;\n        cropBoxData.oldTop = cropBoxData.top;\n        if (options.movable && options.cropBoxMovable) {\n            // Turn to move the canvas when the crop box is equal to the container\n            setData(this.face, DATA_ACTION, cropBoxData.width >= containerData.width && cropBoxData.height >= containerData.height ? ACTION_MOVE : ACTION_ALL);\n        }\n        setStyle(this.cropBox, assign({\n            width: cropBoxData.width,\n            height: cropBoxData.height\n        }, getTransforms({\n            translateX: cropBoxData.left,\n            translateY: cropBoxData.top\n        })));\n        if (this.cropped && this.limited) {\n            this.limitCanvas(true, true);\n        }\n        if (!this.disabled) {\n            this.output();\n        }\n    },\n    output: function output() {\n        this.preview();\n        dispatchEvent(this.element, EVENT_CROP, this.getData());\n    }\n};\nvar preview = {\n    initPreview: function initPreview() {\n        var element = this.element, crossOrigin = this.crossOrigin;\n        var preview = this.options.preview;\n        var url = crossOrigin ? this.crossOriginUrl : this.url;\n        var alt = element.alt || \"The image to preview\";\n        var image = document.createElement(\"img\");\n        if (crossOrigin) {\n            image.crossOrigin = crossOrigin;\n        }\n        image.src = url;\n        image.alt = alt;\n        this.viewBox.appendChild(image);\n        this.viewBoxImage = image;\n        if (!preview) {\n            return;\n        }\n        var previews = preview;\n        if (typeof preview === \"string\") {\n            previews = element.ownerDocument.querySelectorAll(preview);\n        } else if (preview.querySelector) {\n            previews = [\n                preview\n            ];\n        }\n        this.previews = previews;\n        forEach(previews, function(el) {\n            var img = document.createElement(\"img\");\n            // Save the original size for recover\n            setData(el, DATA_PREVIEW, {\n                width: el.offsetWidth,\n                height: el.offsetHeight,\n                html: el.innerHTML\n            });\n            if (crossOrigin) {\n                img.crossOrigin = crossOrigin;\n            }\n            img.src = url;\n            img.alt = alt;\n            /**\n       * Override img element styles\n       * Add `display:block` to avoid margin top issue\n       * Add `height:auto` to override `height` attribute on IE8\n       * (Occur only when margin-top <= -height)\n       */ img.style.cssText = \"display:block;\" + \"width:100%;\" + \"height:auto;\" + \"min-width:0!important;\" + \"min-height:0!important;\" + \"max-width:none!important;\" + \"max-height:none!important;\" + 'image-orientation:0deg!important;\"';\n            el.innerHTML = \"\";\n            el.appendChild(img);\n        });\n    },\n    resetPreview: function resetPreview() {\n        forEach(this.previews, function(element) {\n            var data = getData(element, DATA_PREVIEW);\n            setStyle(element, {\n                width: data.width,\n                height: data.height\n            });\n            element.innerHTML = data.html;\n            removeData(element, DATA_PREVIEW);\n        });\n    },\n    preview: function preview() {\n        var imageData = this.imageData, canvasData = this.canvasData, cropBoxData = this.cropBoxData;\n        var cropBoxWidth = cropBoxData.width, cropBoxHeight = cropBoxData.height;\n        var width = imageData.width, height = imageData.height;\n        var left = cropBoxData.left - canvasData.left - imageData.left;\n        var top = cropBoxData.top - canvasData.top - imageData.top;\n        if (!this.cropped || this.disabled) {\n            return;\n        }\n        setStyle(this.viewBoxImage, assign({\n            width: width,\n            height: height\n        }, getTransforms(assign({\n            translateX: -left,\n            translateY: -top\n        }, imageData))));\n        forEach(this.previews, function(element) {\n            var data = getData(element, DATA_PREVIEW);\n            var originalWidth = data.width;\n            var originalHeight = data.height;\n            var newWidth = originalWidth;\n            var newHeight = originalHeight;\n            var ratio = 1;\n            if (cropBoxWidth) {\n                ratio = originalWidth / cropBoxWidth;\n                newHeight = cropBoxHeight * ratio;\n            }\n            if (cropBoxHeight && newHeight > originalHeight) {\n                ratio = originalHeight / cropBoxHeight;\n                newWidth = cropBoxWidth * ratio;\n                newHeight = originalHeight;\n            }\n            setStyle(element, {\n                width: newWidth,\n                height: newHeight\n            });\n            setStyle(element.getElementsByTagName(\"img\")[0], assign({\n                width: width * ratio,\n                height: height * ratio\n            }, getTransforms(assign({\n                translateX: -left * ratio,\n                translateY: -top * ratio\n            }, imageData))));\n        });\n    }\n};\nvar events = {\n    bind: function bind() {\n        var element = this.element, options = this.options, cropper = this.cropper;\n        if (isFunction(options.cropstart)) {\n            addListener(element, EVENT_CROP_START, options.cropstart);\n        }\n        if (isFunction(options.cropmove)) {\n            addListener(element, EVENT_CROP_MOVE, options.cropmove);\n        }\n        if (isFunction(options.cropend)) {\n            addListener(element, EVENT_CROP_END, options.cropend);\n        }\n        if (isFunction(options.crop)) {\n            addListener(element, EVENT_CROP, options.crop);\n        }\n        if (isFunction(options.zoom)) {\n            addListener(element, EVENT_ZOOM, options.zoom);\n        }\n        addListener(cropper, EVENT_POINTER_DOWN, this.onCropStart = this.cropStart.bind(this));\n        if (options.zoomable && options.zoomOnWheel) {\n            addListener(cropper, EVENT_WHEEL, this.onWheel = this.wheel.bind(this), {\n                passive: false,\n                capture: true\n            });\n        }\n        if (options.toggleDragModeOnDblclick) {\n            addListener(cropper, EVENT_DBLCLICK, this.onDblclick = this.dblclick.bind(this));\n        }\n        addListener(element.ownerDocument, EVENT_POINTER_MOVE, this.onCropMove = this.cropMove.bind(this));\n        addListener(element.ownerDocument, EVENT_POINTER_UP, this.onCropEnd = this.cropEnd.bind(this));\n        if (options.responsive) {\n            addListener(window, EVENT_RESIZE, this.onResize = this.resize.bind(this));\n        }\n    },\n    unbind: function unbind() {\n        var element = this.element, options = this.options, cropper = this.cropper;\n        if (isFunction(options.cropstart)) {\n            removeListener(element, EVENT_CROP_START, options.cropstart);\n        }\n        if (isFunction(options.cropmove)) {\n            removeListener(element, EVENT_CROP_MOVE, options.cropmove);\n        }\n        if (isFunction(options.cropend)) {\n            removeListener(element, EVENT_CROP_END, options.cropend);\n        }\n        if (isFunction(options.crop)) {\n            removeListener(element, EVENT_CROP, options.crop);\n        }\n        if (isFunction(options.zoom)) {\n            removeListener(element, EVENT_ZOOM, options.zoom);\n        }\n        removeListener(cropper, EVENT_POINTER_DOWN, this.onCropStart);\n        if (options.zoomable && options.zoomOnWheel) {\n            removeListener(cropper, EVENT_WHEEL, this.onWheel, {\n                passive: false,\n                capture: true\n            });\n        }\n        if (options.toggleDragModeOnDblclick) {\n            removeListener(cropper, EVENT_DBLCLICK, this.onDblclick);\n        }\n        removeListener(element.ownerDocument, EVENT_POINTER_MOVE, this.onCropMove);\n        removeListener(element.ownerDocument, EVENT_POINTER_UP, this.onCropEnd);\n        if (options.responsive) {\n            removeListener(window, EVENT_RESIZE, this.onResize);\n        }\n    }\n};\nvar handlers = {\n    resize: function resize() {\n        if (this.disabled) {\n            return;\n        }\n        var options = this.options, container = this.container, containerData = this.containerData;\n        var ratioX = container.offsetWidth / containerData.width;\n        var ratioY = container.offsetHeight / containerData.height;\n        var ratio = Math.abs(ratioX - 1) > Math.abs(ratioY - 1) ? ratioX : ratioY;\n        // Resize when width changed or height changed\n        if (ratio !== 1) {\n            var canvasData;\n            var cropBoxData;\n            if (options.restore) {\n                canvasData = this.getCanvasData();\n                cropBoxData = this.getCropBoxData();\n            }\n            this.render();\n            if (options.restore) {\n                this.setCanvasData(forEach(canvasData, function(n, i) {\n                    canvasData[i] = n * ratio;\n                }));\n                this.setCropBoxData(forEach(cropBoxData, function(n, i) {\n                    cropBoxData[i] = n * ratio;\n                }));\n            }\n        }\n    },\n    dblclick: function dblclick() {\n        if (this.disabled || this.options.dragMode === DRAG_MODE_NONE) {\n            return;\n        }\n        this.setDragMode(hasClass(this.dragBox, CLASS_CROP) ? DRAG_MODE_MOVE : DRAG_MODE_CROP);\n    },\n    wheel: function wheel(event) {\n        var _this = this;\n        var ratio = Number(this.options.wheelZoomRatio) || 0.1;\n        var delta = 1;\n        if (this.disabled) {\n            return;\n        }\n        event.preventDefault();\n        // Limit wheel speed to prevent zoom too fast (#21)\n        if (this.wheeling) {\n            return;\n        }\n        this.wheeling = true;\n        setTimeout(function() {\n            _this.wheeling = false;\n        }, 50);\n        if (event.deltaY) {\n            delta = event.deltaY > 0 ? 1 : -1;\n        } else if (event.wheelDelta) {\n            delta = -event.wheelDelta / 120;\n        } else if (event.detail) {\n            delta = event.detail > 0 ? 1 : -1;\n        }\n        this.zoom(-delta * ratio, event);\n    },\n    cropStart: function cropStart(event) {\n        var buttons = event.buttons, button = event.button;\n        if (this.disabled || (event.type === \"mousedown\" || event.type === \"pointerdown\" && event.pointerType === \"mouse\") && // No primary button (Usually the left button)\n        (isNumber(buttons) && buttons !== 1 || isNumber(button) && button !== 0 || event.ctrlKey)) {\n            return;\n        }\n        var options = this.options, pointers = this.pointers;\n        var action;\n        if (event.changedTouches) {\n            // Handle touch event\n            forEach(event.changedTouches, function(touch) {\n                pointers[touch.identifier] = getPointer(touch);\n            });\n        } else {\n            // Handle mouse event and pointer event\n            pointers[event.pointerId || 0] = getPointer(event);\n        }\n        if (Object.keys(pointers).length > 1 && options.zoomable && options.zoomOnTouch) {\n            action = ACTION_ZOOM;\n        } else {\n            action = getData(event.target, DATA_ACTION);\n        }\n        if (!REGEXP_ACTIONS.test(action)) {\n            return;\n        }\n        if (dispatchEvent(this.element, EVENT_CROP_START, {\n            originalEvent: event,\n            action: action\n        }) === false) {\n            return;\n        }\n        // This line is required for preventing page zooming in iOS browsers\n        event.preventDefault();\n        this.action = action;\n        this.cropping = false;\n        if (action === ACTION_CROP) {\n            this.cropping = true;\n            addClass(this.dragBox, CLASS_MODAL);\n        }\n    },\n    cropMove: function cropMove(event) {\n        var action = this.action;\n        if (this.disabled || !action) {\n            return;\n        }\n        var pointers = this.pointers;\n        event.preventDefault();\n        if (dispatchEvent(this.element, EVENT_CROP_MOVE, {\n            originalEvent: event,\n            action: action\n        }) === false) {\n            return;\n        }\n        if (event.changedTouches) {\n            forEach(event.changedTouches, function(touch) {\n                // The first parameter should not be undefined (#432)\n                assign(pointers[touch.identifier] || {}, getPointer(touch, true));\n            });\n        } else {\n            assign(pointers[event.pointerId || 0] || {}, getPointer(event, true));\n        }\n        this.change(event);\n    },\n    cropEnd: function cropEnd(event) {\n        if (this.disabled) {\n            return;\n        }\n        var action = this.action, pointers = this.pointers;\n        if (event.changedTouches) {\n            forEach(event.changedTouches, function(touch) {\n                delete pointers[touch.identifier];\n            });\n        } else {\n            delete pointers[event.pointerId || 0];\n        }\n        if (!action) {\n            return;\n        }\n        event.preventDefault();\n        if (!Object.keys(pointers).length) {\n            this.action = \"\";\n        }\n        if (this.cropping) {\n            this.cropping = false;\n            toggleClass(this.dragBox, CLASS_MODAL, this.cropped && this.options.modal);\n        }\n        dispatchEvent(this.element, EVENT_CROP_END, {\n            originalEvent: event,\n            action: action\n        });\n    }\n};\nvar change = {\n    change: function change(event) {\n        var options = this.options, canvasData = this.canvasData, containerData = this.containerData, cropBoxData = this.cropBoxData, pointers = this.pointers;\n        var action = this.action;\n        var aspectRatio = options.aspectRatio;\n        var left = cropBoxData.left, top = cropBoxData.top, width = cropBoxData.width, height = cropBoxData.height;\n        var right = left + width;\n        var bottom = top + height;\n        var minLeft = 0;\n        var minTop = 0;\n        var maxWidth = containerData.width;\n        var maxHeight = containerData.height;\n        var renderable = true;\n        var offset;\n        // Locking aspect ratio in \"free mode\" by holding shift key\n        if (!aspectRatio && event.shiftKey) {\n            aspectRatio = width && height ? width / height : 1;\n        }\n        if (this.limited) {\n            minLeft = cropBoxData.minLeft;\n            minTop = cropBoxData.minTop;\n            maxWidth = minLeft + Math.min(containerData.width, canvasData.width, canvasData.left + canvasData.width);\n            maxHeight = minTop + Math.min(containerData.height, canvasData.height, canvasData.top + canvasData.height);\n        }\n        var pointer = pointers[Object.keys(pointers)[0]];\n        var range = {\n            x: pointer.endX - pointer.startX,\n            y: pointer.endY - pointer.startY\n        };\n        var check = function check(side) {\n            switch(side){\n                case ACTION_EAST:\n                    if (right + range.x > maxWidth) {\n                        range.x = maxWidth - right;\n                    }\n                    break;\n                case ACTION_WEST:\n                    if (left + range.x < minLeft) {\n                        range.x = minLeft - left;\n                    }\n                    break;\n                case ACTION_NORTH:\n                    if (top + range.y < minTop) {\n                        range.y = minTop - top;\n                    }\n                    break;\n                case ACTION_SOUTH:\n                    if (bottom + range.y > maxHeight) {\n                        range.y = maxHeight - bottom;\n                    }\n                    break;\n            }\n        };\n        switch(action){\n            // Move crop box\n            case ACTION_ALL:\n                left += range.x;\n                top += range.y;\n                break;\n            // Resize crop box\n            case ACTION_EAST:\n                if (range.x >= 0 && (right >= maxWidth || aspectRatio && (top <= minTop || bottom >= maxHeight))) {\n                    renderable = false;\n                    break;\n                }\n                check(ACTION_EAST);\n                width += range.x;\n                if (width < 0) {\n                    action = ACTION_WEST;\n                    width = -width;\n                    left -= width;\n                }\n                if (aspectRatio) {\n                    height = width / aspectRatio;\n                    top += (cropBoxData.height - height) / 2;\n                }\n                break;\n            case ACTION_NORTH:\n                if (range.y <= 0 && (top <= minTop || aspectRatio && (left <= minLeft || right >= maxWidth))) {\n                    renderable = false;\n                    break;\n                }\n                check(ACTION_NORTH);\n                height -= range.y;\n                top += range.y;\n                if (height < 0) {\n                    action = ACTION_SOUTH;\n                    height = -height;\n                    top -= height;\n                }\n                if (aspectRatio) {\n                    width = height * aspectRatio;\n                    left += (cropBoxData.width - width) / 2;\n                }\n                break;\n            case ACTION_WEST:\n                if (range.x <= 0 && (left <= minLeft || aspectRatio && (top <= minTop || bottom >= maxHeight))) {\n                    renderable = false;\n                    break;\n                }\n                check(ACTION_WEST);\n                width -= range.x;\n                left += range.x;\n                if (width < 0) {\n                    action = ACTION_EAST;\n                    width = -width;\n                    left -= width;\n                }\n                if (aspectRatio) {\n                    height = width / aspectRatio;\n                    top += (cropBoxData.height - height) / 2;\n                }\n                break;\n            case ACTION_SOUTH:\n                if (range.y >= 0 && (bottom >= maxHeight || aspectRatio && (left <= minLeft || right >= maxWidth))) {\n                    renderable = false;\n                    break;\n                }\n                check(ACTION_SOUTH);\n                height += range.y;\n                if (height < 0) {\n                    action = ACTION_NORTH;\n                    height = -height;\n                    top -= height;\n                }\n                if (aspectRatio) {\n                    width = height * aspectRatio;\n                    left += (cropBoxData.width - width) / 2;\n                }\n                break;\n            case ACTION_NORTH_EAST:\n                if (aspectRatio) {\n                    if (range.y <= 0 && (top <= minTop || right >= maxWidth)) {\n                        renderable = false;\n                        break;\n                    }\n                    check(ACTION_NORTH);\n                    height -= range.y;\n                    top += range.y;\n                    width = height * aspectRatio;\n                } else {\n                    check(ACTION_NORTH);\n                    check(ACTION_EAST);\n                    if (range.x >= 0) {\n                        if (right < maxWidth) {\n                            width += range.x;\n                        } else if (range.y <= 0 && top <= minTop) {\n                            renderable = false;\n                        }\n                    } else {\n                        width += range.x;\n                    }\n                    if (range.y <= 0) {\n                        if (top > minTop) {\n                            height -= range.y;\n                            top += range.y;\n                        }\n                    } else {\n                        height -= range.y;\n                        top += range.y;\n                    }\n                }\n                if (width < 0 && height < 0) {\n                    action = ACTION_SOUTH_WEST;\n                    height = -height;\n                    width = -width;\n                    top -= height;\n                    left -= width;\n                } else if (width < 0) {\n                    action = ACTION_NORTH_WEST;\n                    width = -width;\n                    left -= width;\n                } else if (height < 0) {\n                    action = ACTION_SOUTH_EAST;\n                    height = -height;\n                    top -= height;\n                }\n                break;\n            case ACTION_NORTH_WEST:\n                if (aspectRatio) {\n                    if (range.y <= 0 && (top <= minTop || left <= minLeft)) {\n                        renderable = false;\n                        break;\n                    }\n                    check(ACTION_NORTH);\n                    height -= range.y;\n                    top += range.y;\n                    width = height * aspectRatio;\n                    left += cropBoxData.width - width;\n                } else {\n                    check(ACTION_NORTH);\n                    check(ACTION_WEST);\n                    if (range.x <= 0) {\n                        if (left > minLeft) {\n                            width -= range.x;\n                            left += range.x;\n                        } else if (range.y <= 0 && top <= minTop) {\n                            renderable = false;\n                        }\n                    } else {\n                        width -= range.x;\n                        left += range.x;\n                    }\n                    if (range.y <= 0) {\n                        if (top > minTop) {\n                            height -= range.y;\n                            top += range.y;\n                        }\n                    } else {\n                        height -= range.y;\n                        top += range.y;\n                    }\n                }\n                if (width < 0 && height < 0) {\n                    action = ACTION_SOUTH_EAST;\n                    height = -height;\n                    width = -width;\n                    top -= height;\n                    left -= width;\n                } else if (width < 0) {\n                    action = ACTION_NORTH_EAST;\n                    width = -width;\n                    left -= width;\n                } else if (height < 0) {\n                    action = ACTION_SOUTH_WEST;\n                    height = -height;\n                    top -= height;\n                }\n                break;\n            case ACTION_SOUTH_WEST:\n                if (aspectRatio) {\n                    if (range.x <= 0 && (left <= minLeft || bottom >= maxHeight)) {\n                        renderable = false;\n                        break;\n                    }\n                    check(ACTION_WEST);\n                    width -= range.x;\n                    left += range.x;\n                    height = width / aspectRatio;\n                } else {\n                    check(ACTION_SOUTH);\n                    check(ACTION_WEST);\n                    if (range.x <= 0) {\n                        if (left > minLeft) {\n                            width -= range.x;\n                            left += range.x;\n                        } else if (range.y >= 0 && bottom >= maxHeight) {\n                            renderable = false;\n                        }\n                    } else {\n                        width -= range.x;\n                        left += range.x;\n                    }\n                    if (range.y >= 0) {\n                        if (bottom < maxHeight) {\n                            height += range.y;\n                        }\n                    } else {\n                        height += range.y;\n                    }\n                }\n                if (width < 0 && height < 0) {\n                    action = ACTION_NORTH_EAST;\n                    height = -height;\n                    width = -width;\n                    top -= height;\n                    left -= width;\n                } else if (width < 0) {\n                    action = ACTION_SOUTH_EAST;\n                    width = -width;\n                    left -= width;\n                } else if (height < 0) {\n                    action = ACTION_NORTH_WEST;\n                    height = -height;\n                    top -= height;\n                }\n                break;\n            case ACTION_SOUTH_EAST:\n                if (aspectRatio) {\n                    if (range.x >= 0 && (right >= maxWidth || bottom >= maxHeight)) {\n                        renderable = false;\n                        break;\n                    }\n                    check(ACTION_EAST);\n                    width += range.x;\n                    height = width / aspectRatio;\n                } else {\n                    check(ACTION_SOUTH);\n                    check(ACTION_EAST);\n                    if (range.x >= 0) {\n                        if (right < maxWidth) {\n                            width += range.x;\n                        } else if (range.y >= 0 && bottom >= maxHeight) {\n                            renderable = false;\n                        }\n                    } else {\n                        width += range.x;\n                    }\n                    if (range.y >= 0) {\n                        if (bottom < maxHeight) {\n                            height += range.y;\n                        }\n                    } else {\n                        height += range.y;\n                    }\n                }\n                if (width < 0 && height < 0) {\n                    action = ACTION_NORTH_WEST;\n                    height = -height;\n                    width = -width;\n                    top -= height;\n                    left -= width;\n                } else if (width < 0) {\n                    action = ACTION_SOUTH_WEST;\n                    width = -width;\n                    left -= width;\n                } else if (height < 0) {\n                    action = ACTION_NORTH_EAST;\n                    height = -height;\n                    top -= height;\n                }\n                break;\n            // Move canvas\n            case ACTION_MOVE:\n                this.move(range.x, range.y);\n                renderable = false;\n                break;\n            // Zoom canvas\n            case ACTION_ZOOM:\n                this.zoom(getMaxZoomRatio(pointers), event);\n                renderable = false;\n                break;\n            // Create crop box\n            case ACTION_CROP:\n                if (!range.x || !range.y) {\n                    renderable = false;\n                    break;\n                }\n                offset = getOffset(this.cropper);\n                left = pointer.startX - offset.left;\n                top = pointer.startY - offset.top;\n                width = cropBoxData.minWidth;\n                height = cropBoxData.minHeight;\n                if (range.x > 0) {\n                    action = range.y > 0 ? ACTION_SOUTH_EAST : ACTION_NORTH_EAST;\n                } else if (range.x < 0) {\n                    left -= width;\n                    action = range.y > 0 ? ACTION_SOUTH_WEST : ACTION_NORTH_WEST;\n                }\n                if (range.y < 0) {\n                    top -= height;\n                }\n                // Show the crop box if is hidden\n                if (!this.cropped) {\n                    removeClass(this.cropBox, CLASS_HIDDEN);\n                    this.cropped = true;\n                    if (this.limited) {\n                        this.limitCropBox(true, true);\n                    }\n                }\n                break;\n        }\n        if (renderable) {\n            cropBoxData.width = width;\n            cropBoxData.height = height;\n            cropBoxData.left = left;\n            cropBoxData.top = top;\n            this.action = action;\n            this.renderCropBox();\n        }\n        // Override\n        forEach(pointers, function(p) {\n            p.startX = p.endX;\n            p.startY = p.endY;\n        });\n    }\n};\nvar methods = {\n    // Show the crop box manually\n    crop: function crop() {\n        if (this.ready && !this.cropped && !this.disabled) {\n            this.cropped = true;\n            this.limitCropBox(true, true);\n            if (this.options.modal) {\n                addClass(this.dragBox, CLASS_MODAL);\n            }\n            removeClass(this.cropBox, CLASS_HIDDEN);\n            this.setCropBoxData(this.initialCropBoxData);\n        }\n        return this;\n    },\n    // Reset the image and crop box to their initial states\n    reset: function reset() {\n        if (this.ready && !this.disabled) {\n            this.imageData = assign({}, this.initialImageData);\n            this.canvasData = assign({}, this.initialCanvasData);\n            this.cropBoxData = assign({}, this.initialCropBoxData);\n            this.renderCanvas();\n            if (this.cropped) {\n                this.renderCropBox();\n            }\n        }\n        return this;\n    },\n    // Clear the crop box\n    clear: function clear() {\n        if (this.cropped && !this.disabled) {\n            assign(this.cropBoxData, {\n                left: 0,\n                top: 0,\n                width: 0,\n                height: 0\n            });\n            this.cropped = false;\n            this.renderCropBox();\n            this.limitCanvas(true, true);\n            // Render canvas after crop box rendered\n            this.renderCanvas();\n            removeClass(this.dragBox, CLASS_MODAL);\n            addClass(this.cropBox, CLASS_HIDDEN);\n        }\n        return this;\n    },\n    /**\n   * Replace the image's src and rebuild the cropper\n   * @param {string} url - The new URL.\n   * @param {boolean} [hasSameSize] - Indicate if the new image has the same size as the old one.\n   * @returns {Cropper} this\n   */ replace: function replace(url) {\n        var hasSameSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n        if (!this.disabled && url) {\n            if (this.isImg) {\n                this.element.src = url;\n            }\n            if (hasSameSize) {\n                this.url = url;\n                this.image.src = url;\n                if (this.ready) {\n                    this.viewBoxImage.src = url;\n                    forEach(this.previews, function(element) {\n                        element.getElementsByTagName(\"img\")[0].src = url;\n                    });\n                }\n            } else {\n                if (this.isImg) {\n                    this.replaced = true;\n                }\n                this.options.data = null;\n                this.uncreate();\n                this.load(url);\n            }\n        }\n        return this;\n    },\n    // Enable (unfreeze) the cropper\n    enable: function enable() {\n        if (this.ready && this.disabled) {\n            this.disabled = false;\n            removeClass(this.cropper, CLASS_DISABLED);\n        }\n        return this;\n    },\n    // Disable (freeze) the cropper\n    disable: function disable() {\n        if (this.ready && !this.disabled) {\n            this.disabled = true;\n            addClass(this.cropper, CLASS_DISABLED);\n        }\n        return this;\n    },\n    /**\n   * Destroy the cropper and remove the instance from the image\n   * @returns {Cropper} this\n   */ destroy: function destroy() {\n        var element = this.element;\n        if (!element[NAMESPACE]) {\n            return this;\n        }\n        element[NAMESPACE] = undefined;\n        if (this.isImg && this.replaced) {\n            element.src = this.originalUrl;\n        }\n        this.uncreate();\n        return this;\n    },\n    /**\n   * Move the canvas with relative offsets\n   * @param {number} offsetX - The relative offset distance on the x-axis.\n   * @param {number} [offsetY=offsetX] - The relative offset distance on the y-axis.\n   * @returns {Cropper} this\n   */ move: function move(offsetX) {\n        var offsetY = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : offsetX;\n        var _this$canvasData = this.canvasData, left = _this$canvasData.left, top = _this$canvasData.top;\n        return this.moveTo(isUndefined(offsetX) ? offsetX : left + Number(offsetX), isUndefined(offsetY) ? offsetY : top + Number(offsetY));\n    },\n    /**\n   * Move the canvas to an absolute point\n   * @param {number} x - The x-axis coordinate.\n   * @param {number} [y=x] - The y-axis coordinate.\n   * @returns {Cropper} this\n   */ moveTo: function moveTo(x) {\n        var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : x;\n        var canvasData = this.canvasData;\n        var changed = false;\n        x = Number(x);\n        y = Number(y);\n        if (this.ready && !this.disabled && this.options.movable) {\n            if (isNumber(x)) {\n                canvasData.left = x;\n                changed = true;\n            }\n            if (isNumber(y)) {\n                canvasData.top = y;\n                changed = true;\n            }\n            if (changed) {\n                this.renderCanvas(true);\n            }\n        }\n        return this;\n    },\n    /**\n   * Zoom the canvas with a relative ratio\n   * @param {number} ratio - The target ratio.\n   * @param {Event} _originalEvent - The original event if any.\n   * @returns {Cropper} this\n   */ zoom: function zoom(ratio, _originalEvent) {\n        var canvasData = this.canvasData;\n        ratio = Number(ratio);\n        if (ratio < 0) {\n            ratio = 1 / (1 - ratio);\n        } else {\n            ratio = 1 + ratio;\n        }\n        return this.zoomTo(canvasData.width * ratio / canvasData.naturalWidth, null, _originalEvent);\n    },\n    /**\n   * Zoom the canvas to an absolute ratio\n   * @param {number} ratio - The target ratio.\n   * @param {Object} pivot - The zoom pivot point coordinate.\n   * @param {Event} _originalEvent - The original event if any.\n   * @returns {Cropper} this\n   */ zoomTo: function zoomTo(ratio, pivot, _originalEvent) {\n        var options = this.options, canvasData = this.canvasData;\n        var width = canvasData.width, height = canvasData.height, naturalWidth = canvasData.naturalWidth, naturalHeight = canvasData.naturalHeight;\n        ratio = Number(ratio);\n        if (ratio >= 0 && this.ready && !this.disabled && options.zoomable) {\n            var newWidth = naturalWidth * ratio;\n            var newHeight = naturalHeight * ratio;\n            if (dispatchEvent(this.element, EVENT_ZOOM, {\n                ratio: ratio,\n                oldRatio: width / naturalWidth,\n                originalEvent: _originalEvent\n            }) === false) {\n                return this;\n            }\n            if (_originalEvent) {\n                var pointers = this.pointers;\n                var offset = getOffset(this.cropper);\n                var center = pointers && Object.keys(pointers).length ? getPointersCenter(pointers) : {\n                    pageX: _originalEvent.pageX,\n                    pageY: _originalEvent.pageY\n                };\n                // Zoom from the triggering point of the event\n                canvasData.left -= (newWidth - width) * ((center.pageX - offset.left - canvasData.left) / width);\n                canvasData.top -= (newHeight - height) * ((center.pageY - offset.top - canvasData.top) / height);\n            } else if (isPlainObject(pivot) && isNumber(pivot.x) && isNumber(pivot.y)) {\n                canvasData.left -= (newWidth - width) * ((pivot.x - canvasData.left) / width);\n                canvasData.top -= (newHeight - height) * ((pivot.y - canvasData.top) / height);\n            } else {\n                // Zoom from the center of the canvas\n                canvasData.left -= (newWidth - width) / 2;\n                canvasData.top -= (newHeight - height) / 2;\n            }\n            canvasData.width = newWidth;\n            canvasData.height = newHeight;\n            this.renderCanvas(true);\n        }\n        return this;\n    },\n    /**\n   * Rotate the canvas with a relative degree\n   * @param {number} degree - The rotate degree.\n   * @returns {Cropper} this\n   */ rotate: function rotate(degree) {\n        return this.rotateTo((this.imageData.rotate || 0) + Number(degree));\n    },\n    /**\n   * Rotate the canvas to an absolute degree\n   * @param {number} degree - The rotate degree.\n   * @returns {Cropper} this\n   */ rotateTo: function rotateTo(degree) {\n        degree = Number(degree);\n        if (isNumber(degree) && this.ready && !this.disabled && this.options.rotatable) {\n            this.imageData.rotate = degree % 360;\n            this.renderCanvas(true, true);\n        }\n        return this;\n    },\n    /**\n   * Scale the image on the x-axis.\n   * @param {number} scaleX - The scale ratio on the x-axis.\n   * @returns {Cropper} this\n   */ scaleX: function scaleX(_scaleX) {\n        var scaleY = this.imageData.scaleY;\n        return this.scale(_scaleX, isNumber(scaleY) ? scaleY : 1);\n    },\n    /**\n   * Scale the image on the y-axis.\n   * @param {number} scaleY - The scale ratio on the y-axis.\n   * @returns {Cropper} this\n   */ scaleY: function scaleY(_scaleY) {\n        var scaleX = this.imageData.scaleX;\n        return this.scale(isNumber(scaleX) ? scaleX : 1, _scaleY);\n    },\n    /**\n   * Scale the image\n   * @param {number} scaleX - The scale ratio on the x-axis.\n   * @param {number} [scaleY=scaleX] - The scale ratio on the y-axis.\n   * @returns {Cropper} this\n   */ scale: function scale(scaleX) {\n        var scaleY = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : scaleX;\n        var imageData = this.imageData;\n        var transformed = false;\n        scaleX = Number(scaleX);\n        scaleY = Number(scaleY);\n        if (this.ready && !this.disabled && this.options.scalable) {\n            if (isNumber(scaleX)) {\n                imageData.scaleX = scaleX;\n                transformed = true;\n            }\n            if (isNumber(scaleY)) {\n                imageData.scaleY = scaleY;\n                transformed = true;\n            }\n            if (transformed) {\n                this.renderCanvas(true, true);\n            }\n        }\n        return this;\n    },\n    /**\n   * Get the cropped area position and size data (base on the original image)\n   * @param {boolean} [rounded=false] - Indicate if round the data values or not.\n   * @returns {Object} The result cropped data.\n   */ getData: function getData() {\n        var rounded = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n        var options = this.options, imageData = this.imageData, canvasData = this.canvasData, cropBoxData = this.cropBoxData;\n        var data;\n        if (this.ready && this.cropped) {\n            data = {\n                x: cropBoxData.left - canvasData.left,\n                y: cropBoxData.top - canvasData.top,\n                width: cropBoxData.width,\n                height: cropBoxData.height\n            };\n            var ratio = imageData.width / imageData.naturalWidth;\n            forEach(data, function(n, i) {\n                data[i] = n / ratio;\n            });\n            if (rounded) {\n                // In case rounding off leads to extra 1px in right or bottom border\n                // we should round the top-left corner and the dimension (#343).\n                var bottom = Math.round(data.y + data.height);\n                var right = Math.round(data.x + data.width);\n                data.x = Math.round(data.x);\n                data.y = Math.round(data.y);\n                data.width = right - data.x;\n                data.height = bottom - data.y;\n            }\n        } else {\n            data = {\n                x: 0,\n                y: 0,\n                width: 0,\n                height: 0\n            };\n        }\n        if (options.rotatable) {\n            data.rotate = imageData.rotate || 0;\n        }\n        if (options.scalable) {\n            data.scaleX = imageData.scaleX || 1;\n            data.scaleY = imageData.scaleY || 1;\n        }\n        return data;\n    },\n    /**\n   * Set the cropped area position and size with new data\n   * @param {Object} data - The new data.\n   * @returns {Cropper} this\n   */ setData: function setData(data) {\n        var options = this.options, imageData = this.imageData, canvasData = this.canvasData;\n        var cropBoxData = {};\n        if (this.ready && !this.disabled && isPlainObject(data)) {\n            var transformed = false;\n            if (options.rotatable) {\n                if (isNumber(data.rotate) && data.rotate !== imageData.rotate) {\n                    imageData.rotate = data.rotate;\n                    transformed = true;\n                }\n            }\n            if (options.scalable) {\n                if (isNumber(data.scaleX) && data.scaleX !== imageData.scaleX) {\n                    imageData.scaleX = data.scaleX;\n                    transformed = true;\n                }\n                if (isNumber(data.scaleY) && data.scaleY !== imageData.scaleY) {\n                    imageData.scaleY = data.scaleY;\n                    transformed = true;\n                }\n            }\n            if (transformed) {\n                this.renderCanvas(true, true);\n            }\n            var ratio = imageData.width / imageData.naturalWidth;\n            if (isNumber(data.x)) {\n                cropBoxData.left = data.x * ratio + canvasData.left;\n            }\n            if (isNumber(data.y)) {\n                cropBoxData.top = data.y * ratio + canvasData.top;\n            }\n            if (isNumber(data.width)) {\n                cropBoxData.width = data.width * ratio;\n            }\n            if (isNumber(data.height)) {\n                cropBoxData.height = data.height * ratio;\n            }\n            this.setCropBoxData(cropBoxData);\n        }\n        return this;\n    },\n    /**\n   * Get the container size data.\n   * @returns {Object} The result container data.\n   */ getContainerData: function getContainerData() {\n        return this.ready ? assign({}, this.containerData) : {};\n    },\n    /**\n   * Get the image position and size data.\n   * @returns {Object} The result image data.\n   */ getImageData: function getImageData() {\n        return this.sized ? assign({}, this.imageData) : {};\n    },\n    /**\n   * Get the canvas position and size data.\n   * @returns {Object} The result canvas data.\n   */ getCanvasData: function getCanvasData() {\n        var canvasData = this.canvasData;\n        var data = {};\n        if (this.ready) {\n            forEach([\n                \"left\",\n                \"top\",\n                \"width\",\n                \"height\",\n                \"naturalWidth\",\n                \"naturalHeight\"\n            ], function(n) {\n                data[n] = canvasData[n];\n            });\n        }\n        return data;\n    },\n    /**\n   * Set the canvas position and size with new data.\n   * @param {Object} data - The new canvas data.\n   * @returns {Cropper} this\n   */ setCanvasData: function setCanvasData(data) {\n        var canvasData = this.canvasData;\n        var aspectRatio = canvasData.aspectRatio;\n        if (this.ready && !this.disabled && isPlainObject(data)) {\n            if (isNumber(data.left)) {\n                canvasData.left = data.left;\n            }\n            if (isNumber(data.top)) {\n                canvasData.top = data.top;\n            }\n            if (isNumber(data.width)) {\n                canvasData.width = data.width;\n                canvasData.height = data.width / aspectRatio;\n            } else if (isNumber(data.height)) {\n                canvasData.height = data.height;\n                canvasData.width = data.height * aspectRatio;\n            }\n            this.renderCanvas(true);\n        }\n        return this;\n    },\n    /**\n   * Get the crop box position and size data.\n   * @returns {Object} The result crop box data.\n   */ getCropBoxData: function getCropBoxData() {\n        var cropBoxData = this.cropBoxData;\n        var data;\n        if (this.ready && this.cropped) {\n            data = {\n                left: cropBoxData.left,\n                top: cropBoxData.top,\n                width: cropBoxData.width,\n                height: cropBoxData.height\n            };\n        }\n        return data || {};\n    },\n    /**\n   * Set the crop box position and size with new data.\n   * @param {Object} data - The new crop box data.\n   * @returns {Cropper} this\n   */ setCropBoxData: function setCropBoxData(data) {\n        var cropBoxData = this.cropBoxData;\n        var aspectRatio = this.options.aspectRatio;\n        var widthChanged;\n        var heightChanged;\n        if (this.ready && this.cropped && !this.disabled && isPlainObject(data)) {\n            if (isNumber(data.left)) {\n                cropBoxData.left = data.left;\n            }\n            if (isNumber(data.top)) {\n                cropBoxData.top = data.top;\n            }\n            if (isNumber(data.width) && data.width !== cropBoxData.width) {\n                widthChanged = true;\n                cropBoxData.width = data.width;\n            }\n            if (isNumber(data.height) && data.height !== cropBoxData.height) {\n                heightChanged = true;\n                cropBoxData.height = data.height;\n            }\n            if (aspectRatio) {\n                if (widthChanged) {\n                    cropBoxData.height = cropBoxData.width / aspectRatio;\n                } else if (heightChanged) {\n                    cropBoxData.width = cropBoxData.height * aspectRatio;\n                }\n            }\n            this.renderCropBox();\n        }\n        return this;\n    },\n    /**\n   * Get a canvas drawn the cropped image.\n   * @param {Object} [options={}] - The config options.\n   * @returns {HTMLCanvasElement} - The result canvas.\n   */ getCroppedCanvas: function getCroppedCanvas() {\n        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        if (!this.ready || !window.HTMLCanvasElement) {\n            return null;\n        }\n        var canvasData = this.canvasData;\n        var source = getSourceCanvas(this.image, this.imageData, canvasData, options);\n        // Returns the source canvas if it is not cropped.\n        if (!this.cropped) {\n            return source;\n        }\n        var _this$getData = this.getData(options.rounded), initialX = _this$getData.x, initialY = _this$getData.y, initialWidth = _this$getData.width, initialHeight = _this$getData.height;\n        var ratio = source.width / Math.floor(canvasData.naturalWidth);\n        if (ratio !== 1) {\n            initialX *= ratio;\n            initialY *= ratio;\n            initialWidth *= ratio;\n            initialHeight *= ratio;\n        }\n        var aspectRatio = initialWidth / initialHeight;\n        var maxSizes = getAdjustedSizes({\n            aspectRatio: aspectRatio,\n            width: options.maxWidth || Infinity,\n            height: options.maxHeight || Infinity\n        });\n        var minSizes = getAdjustedSizes({\n            aspectRatio: aspectRatio,\n            width: options.minWidth || 0,\n            height: options.minHeight || 0\n        }, \"cover\");\n        var _getAdjustedSizes = getAdjustedSizes({\n            aspectRatio: aspectRatio,\n            width: options.width || (ratio !== 1 ? source.width : initialWidth),\n            height: options.height || (ratio !== 1 ? source.height : initialHeight)\n        }), width = _getAdjustedSizes.width, height = _getAdjustedSizes.height;\n        width = Math.min(maxSizes.width, Math.max(minSizes.width, width));\n        height = Math.min(maxSizes.height, Math.max(minSizes.height, height));\n        var canvas = document.createElement(\"canvas\");\n        var context = canvas.getContext(\"2d\");\n        canvas.width = normalizeDecimalNumber(width);\n        canvas.height = normalizeDecimalNumber(height);\n        context.fillStyle = options.fillColor || \"transparent\";\n        context.fillRect(0, 0, width, height);\n        var _options$imageSmoothi = options.imageSmoothingEnabled, imageSmoothingEnabled = _options$imageSmoothi === void 0 ? true : _options$imageSmoothi, imageSmoothingQuality = options.imageSmoothingQuality;\n        context.imageSmoothingEnabled = imageSmoothingEnabled;\n        if (imageSmoothingQuality) {\n            context.imageSmoothingQuality = imageSmoothingQuality;\n        }\n        // https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D.drawImage\n        var sourceWidth = source.width;\n        var sourceHeight = source.height;\n        // Source canvas parameters\n        var srcX = initialX;\n        var srcY = initialY;\n        var srcWidth;\n        var srcHeight;\n        // Destination canvas parameters\n        var dstX;\n        var dstY;\n        var dstWidth;\n        var dstHeight;\n        if (srcX <= -initialWidth || srcX > sourceWidth) {\n            srcX = 0;\n            srcWidth = 0;\n            dstX = 0;\n            dstWidth = 0;\n        } else if (srcX <= 0) {\n            dstX = -srcX;\n            srcX = 0;\n            srcWidth = Math.min(sourceWidth, initialWidth + srcX);\n            dstWidth = srcWidth;\n        } else if (srcX <= sourceWidth) {\n            dstX = 0;\n            srcWidth = Math.min(initialWidth, sourceWidth - srcX);\n            dstWidth = srcWidth;\n        }\n        if (srcWidth <= 0 || srcY <= -initialHeight || srcY > sourceHeight) {\n            srcY = 0;\n            srcHeight = 0;\n            dstY = 0;\n            dstHeight = 0;\n        } else if (srcY <= 0) {\n            dstY = -srcY;\n            srcY = 0;\n            srcHeight = Math.min(sourceHeight, initialHeight + srcY);\n            dstHeight = srcHeight;\n        } else if (srcY <= sourceHeight) {\n            dstY = 0;\n            srcHeight = Math.min(initialHeight, sourceHeight - srcY);\n            dstHeight = srcHeight;\n        }\n        var params = [\n            srcX,\n            srcY,\n            srcWidth,\n            srcHeight\n        ];\n        // Avoid \"IndexSizeError\"\n        if (dstWidth > 0 && dstHeight > 0) {\n            var scale = width / initialWidth;\n            params.push(dstX * scale, dstY * scale, dstWidth * scale, dstHeight * scale);\n        }\n        // All the numerical parameters should be integer for `drawImage`\n        // https://github.com/fengyuanchen/cropper/issues/476\n        context.drawImage.apply(context, [\n            source\n        ].concat(_toConsumableArray(params.map(function(param) {\n            return Math.floor(normalizeDecimalNumber(param));\n        }))));\n        return canvas;\n    },\n    /**\n   * Change the aspect ratio of the crop box.\n   * @param {number} aspectRatio - The new aspect ratio.\n   * @returns {Cropper} this\n   */ setAspectRatio: function setAspectRatio(aspectRatio) {\n        var options = this.options;\n        if (!this.disabled && !isUndefined(aspectRatio)) {\n            // 0 -> NaN\n            options.aspectRatio = Math.max(0, aspectRatio) || NaN;\n            if (this.ready) {\n                this.initCropBox();\n                if (this.cropped) {\n                    this.renderCropBox();\n                }\n            }\n        }\n        return this;\n    },\n    /**\n   * Change the drag mode.\n   * @param {string} mode - The new drag mode.\n   * @returns {Cropper} this\n   */ setDragMode: function setDragMode(mode) {\n        var options = this.options, dragBox = this.dragBox, face = this.face;\n        if (this.ready && !this.disabled) {\n            var croppable = mode === DRAG_MODE_CROP;\n            var movable = options.movable && mode === DRAG_MODE_MOVE;\n            mode = croppable || movable ? mode : DRAG_MODE_NONE;\n            options.dragMode = mode;\n            setData(dragBox, DATA_ACTION, mode);\n            toggleClass(dragBox, CLASS_CROP, croppable);\n            toggleClass(dragBox, CLASS_MOVE, movable);\n            if (!options.cropBoxMovable) {\n                // Sync drag mode to crop box when it is not movable\n                setData(face, DATA_ACTION, mode);\n                toggleClass(face, CLASS_CROP, croppable);\n                toggleClass(face, CLASS_MOVE, movable);\n            }\n        }\n        return this;\n    }\n};\nvar AnotherCropper = WINDOW.Cropper;\nvar Cropper = /*#__PURE__*/ function() {\n    /**\n   * Create a new Cropper.\n   * @param {Element} element - The target element for cropping.\n   * @param {Object} [options={}] - The configuration options.\n   */ function Cropper(element) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        _classCallCheck(this, Cropper);\n        if (!element || !REGEXP_TAG_NAME.test(element.tagName)) {\n            throw new Error(\"The first argument is required and must be an <img> or <canvas> element.\");\n        }\n        this.element = element;\n        this.options = assign({}, DEFAULTS, isPlainObject(options) && options);\n        this.cropped = false;\n        this.disabled = false;\n        this.pointers = {};\n        this.ready = false;\n        this.reloading = false;\n        this.replaced = false;\n        this.sized = false;\n        this.sizing = false;\n        this.init();\n    }\n    _createClass(Cropper, [\n        {\n            key: \"init\",\n            value: function init() {\n                var element = this.element;\n                var tagName = element.tagName.toLowerCase();\n                var url;\n                if (element[NAMESPACE]) {\n                    return;\n                }\n                element[NAMESPACE] = this;\n                if (tagName === \"img\") {\n                    this.isImg = true;\n                    // e.g.: \"img/picture.jpg\"\n                    url = element.getAttribute(\"src\") || \"\";\n                    this.originalUrl = url;\n                    // Stop when it's a blank image\n                    if (!url) {\n                        return;\n                    }\n                    // e.g.: \"https://example.com/img/picture.jpg\"\n                    url = element.src;\n                } else if (tagName === \"canvas\" && window.HTMLCanvasElement) {\n                    url = element.toDataURL();\n                }\n                this.load(url);\n            }\n        },\n        {\n            key: \"load\",\n            value: function load(url) {\n                var _this = this;\n                if (!url) {\n                    return;\n                }\n                this.url = url;\n                this.imageData = {};\n                var element = this.element, options = this.options;\n                if (!options.rotatable && !options.scalable) {\n                    options.checkOrientation = false;\n                }\n                // Only IE10+ supports Typed Arrays\n                if (!options.checkOrientation || !window.ArrayBuffer) {\n                    this.clone();\n                    return;\n                }\n                // Detect the mime type of the image directly if it is a Data URL\n                if (REGEXP_DATA_URL.test(url)) {\n                    // Read ArrayBuffer from Data URL of JPEG images directly for better performance\n                    if (REGEXP_DATA_URL_JPEG.test(url)) {\n                        this.read(dataURLToArrayBuffer(url));\n                    } else {\n                        // Only a JPEG image may contains Exif Orientation information,\n                        // the rest types of Data URLs are not necessary to check orientation at all.\n                        this.clone();\n                    }\n                    return;\n                }\n                // 1. Detect the mime type of the image by a XMLHttpRequest.\n                // 2. Load the image as ArrayBuffer for reading orientation if its a JPEG image.\n                var xhr = new XMLHttpRequest();\n                var clone = this.clone.bind(this);\n                this.reloading = true;\n                this.xhr = xhr;\n                // 1. Cross origin requests are only supported for protocol schemes:\n                // http, https, data, chrome, chrome-extension.\n                // 2. Access to XMLHttpRequest from a Data URL will be blocked by CORS policy\n                // in some browsers as IE11 and Safari.\n                xhr.onabort = clone;\n                xhr.onerror = clone;\n                xhr.ontimeout = clone;\n                xhr.onprogress = function() {\n                    // Abort the request directly if it not a JPEG image for better performance\n                    if (xhr.getResponseHeader(\"content-type\") !== MIME_TYPE_JPEG) {\n                        xhr.abort();\n                    }\n                };\n                xhr.onload = function() {\n                    _this.read(xhr.response);\n                };\n                xhr.onloadend = function() {\n                    _this.reloading = false;\n                    _this.xhr = null;\n                };\n                // Bust cache when there is a \"crossOrigin\" property to avoid browser cache error\n                if (options.checkCrossOrigin && isCrossOriginURL(url) && element.crossOrigin) {\n                    url = addTimestamp(url);\n                }\n                // The third parameter is required for avoiding side-effect (#682)\n                xhr.open(\"GET\", url, true);\n                xhr.responseType = \"arraybuffer\";\n                xhr.withCredentials = element.crossOrigin === \"use-credentials\";\n                xhr.send();\n            }\n        },\n        {\n            key: \"read\",\n            value: function read(arrayBuffer) {\n                var options = this.options, imageData = this.imageData;\n                // Reset the orientation value to its default value 1\n                // as some iOS browsers will render image with its orientation\n                var orientation = resetAndGetOrientation(arrayBuffer);\n                var rotate = 0;\n                var scaleX = 1;\n                var scaleY = 1;\n                if (orientation > 1) {\n                    // Generate a new URL which has the default orientation value\n                    this.url = arrayBufferToDataURL(arrayBuffer, MIME_TYPE_JPEG);\n                    var _parseOrientation = parseOrientation(orientation);\n                    rotate = _parseOrientation.rotate;\n                    scaleX = _parseOrientation.scaleX;\n                    scaleY = _parseOrientation.scaleY;\n                }\n                if (options.rotatable) {\n                    imageData.rotate = rotate;\n                }\n                if (options.scalable) {\n                    imageData.scaleX = scaleX;\n                    imageData.scaleY = scaleY;\n                }\n                this.clone();\n            }\n        },\n        {\n            key: \"clone\",\n            value: function clone() {\n                var element = this.element, url = this.url;\n                var crossOrigin = element.crossOrigin;\n                var crossOriginUrl = url;\n                if (this.options.checkCrossOrigin && isCrossOriginURL(url)) {\n                    if (!crossOrigin) {\n                        crossOrigin = \"anonymous\";\n                    }\n                    // Bust cache when there is not a \"crossOrigin\" property (#519)\n                    crossOriginUrl = addTimestamp(url);\n                }\n                this.crossOrigin = crossOrigin;\n                this.crossOriginUrl = crossOriginUrl;\n                var image = document.createElement(\"img\");\n                if (crossOrigin) {\n                    image.crossOrigin = crossOrigin;\n                }\n                image.src = crossOriginUrl || url;\n                image.alt = element.alt || \"The image to crop\";\n                this.image = image;\n                image.onload = this.start.bind(this);\n                image.onerror = this.stop.bind(this);\n                addClass(image, CLASS_HIDE);\n                element.parentNode.insertBefore(image, element.nextSibling);\n            }\n        },\n        {\n            key: \"start\",\n            value: function start() {\n                var _this2 = this;\n                var image = this.image;\n                image.onload = null;\n                image.onerror = null;\n                this.sizing = true;\n                // Match all browsers that use WebKit as the layout engine in iOS devices,\n                // such as Safari for iOS, Chrome for iOS, and in-app browsers.\n                var isIOSWebKit = WINDOW.navigator && /(?:iPad|iPhone|iPod).*?AppleWebKit/i.test(WINDOW.navigator.userAgent);\n                var done = function done(naturalWidth, naturalHeight) {\n                    assign(_this2.imageData, {\n                        naturalWidth: naturalWidth,\n                        naturalHeight: naturalHeight,\n                        aspectRatio: naturalWidth / naturalHeight\n                    });\n                    _this2.initialImageData = assign({}, _this2.imageData);\n                    _this2.sizing = false;\n                    _this2.sized = true;\n                    _this2.build();\n                };\n                // Most modern browsers (excepts iOS WebKit)\n                if (image.naturalWidth && !isIOSWebKit) {\n                    done(image.naturalWidth, image.naturalHeight);\n                    return;\n                }\n                var sizingImage = document.createElement(\"img\");\n                var body = document.body || document.documentElement;\n                this.sizingImage = sizingImage;\n                sizingImage.onload = function() {\n                    done(sizingImage.width, sizingImage.height);\n                    if (!isIOSWebKit) {\n                        body.removeChild(sizingImage);\n                    }\n                };\n                sizingImage.src = image.src;\n                // iOS WebKit will convert the image automatically\n                // with its orientation once append it into DOM (#279)\n                if (!isIOSWebKit) {\n                    sizingImage.style.cssText = \"left:0;\" + \"max-height:none!important;\" + \"max-width:none!important;\" + \"min-height:0!important;\" + \"min-width:0!important;\" + \"opacity:0;\" + \"position:absolute;\" + \"top:0;\" + \"z-index:-1;\";\n                    body.appendChild(sizingImage);\n                }\n            }\n        },\n        {\n            key: \"stop\",\n            value: function stop() {\n                var image = this.image;\n                image.onload = null;\n                image.onerror = null;\n                image.parentNode.removeChild(image);\n                this.image = null;\n            }\n        },\n        {\n            key: \"build\",\n            value: function build() {\n                if (!this.sized || this.ready) {\n                    return;\n                }\n                var element = this.element, options = this.options, image = this.image;\n                // Create cropper elements\n                var container = element.parentNode;\n                var template = document.createElement(\"div\");\n                template.innerHTML = TEMPLATE;\n                var cropper = template.querySelector(\".\".concat(NAMESPACE, \"-container\"));\n                var canvas = cropper.querySelector(\".\".concat(NAMESPACE, \"-canvas\"));\n                var dragBox = cropper.querySelector(\".\".concat(NAMESPACE, \"-drag-box\"));\n                var cropBox = cropper.querySelector(\".\".concat(NAMESPACE, \"-crop-box\"));\n                var face = cropBox.querySelector(\".\".concat(NAMESPACE, \"-face\"));\n                this.container = container;\n                this.cropper = cropper;\n                this.canvas = canvas;\n                this.dragBox = dragBox;\n                this.cropBox = cropBox;\n                this.viewBox = cropper.querySelector(\".\".concat(NAMESPACE, \"-view-box\"));\n                this.face = face;\n                canvas.appendChild(image);\n                // Hide the original image\n                addClass(element, CLASS_HIDDEN);\n                // Inserts the cropper after to the current image\n                container.insertBefore(cropper, element.nextSibling);\n                // Show the hidden image\n                removeClass(image, CLASS_HIDE);\n                this.initPreview();\n                this.bind();\n                options.initialAspectRatio = Math.max(0, options.initialAspectRatio) || NaN;\n                options.aspectRatio = Math.max(0, options.aspectRatio) || NaN;\n                options.viewMode = Math.max(0, Math.min(3, Math.round(options.viewMode))) || 0;\n                addClass(cropBox, CLASS_HIDDEN);\n                if (!options.guides) {\n                    addClass(cropBox.getElementsByClassName(\"\".concat(NAMESPACE, \"-dashed\")), CLASS_HIDDEN);\n                }\n                if (!options.center) {\n                    addClass(cropBox.getElementsByClassName(\"\".concat(NAMESPACE, \"-center\")), CLASS_HIDDEN);\n                }\n                if (options.background) {\n                    addClass(cropper, \"\".concat(NAMESPACE, \"-bg\"));\n                }\n                if (!options.highlight) {\n                    addClass(face, CLASS_INVISIBLE);\n                }\n                if (options.cropBoxMovable) {\n                    addClass(face, CLASS_MOVE);\n                    setData(face, DATA_ACTION, ACTION_ALL);\n                }\n                if (!options.cropBoxResizable) {\n                    addClass(cropBox.getElementsByClassName(\"\".concat(NAMESPACE, \"-line\")), CLASS_HIDDEN);\n                    addClass(cropBox.getElementsByClassName(\"\".concat(NAMESPACE, \"-point\")), CLASS_HIDDEN);\n                }\n                this.render();\n                this.ready = true;\n                this.setDragMode(options.dragMode);\n                if (options.autoCrop) {\n                    this.crop();\n                }\n                this.setData(options.data);\n                if (isFunction(options.ready)) {\n                    addListener(element, EVENT_READY, options.ready, {\n                        once: true\n                    });\n                }\n                dispatchEvent(element, EVENT_READY);\n            }\n        },\n        {\n            key: \"unbuild\",\n            value: function unbuild() {\n                if (!this.ready) {\n                    return;\n                }\n                this.ready = false;\n                this.unbind();\n                this.resetPreview();\n                var parentNode = this.cropper.parentNode;\n                if (parentNode) {\n                    parentNode.removeChild(this.cropper);\n                }\n                removeClass(this.element, CLASS_HIDDEN);\n            }\n        },\n        {\n            key: \"uncreate\",\n            value: function uncreate() {\n                if (this.ready) {\n                    this.unbuild();\n                    this.ready = false;\n                    this.cropped = false;\n                } else if (this.sizing) {\n                    this.sizingImage.onload = null;\n                    this.sizing = false;\n                    this.sized = false;\n                } else if (this.reloading) {\n                    this.xhr.onabort = null;\n                    this.xhr.abort();\n                } else if (this.image) {\n                    this.stop();\n                }\n            }\n        }\n    ], [\n        {\n            key: \"noConflict\",\n            value: function noConflict() {\n                window.Cropper = AnotherCropper;\n                return Cropper;\n            }\n        },\n        {\n            key: \"setDefaults\",\n            value: function setDefaults(options) {\n                assign(DEFAULTS, isPlainObject(options) && options);\n            }\n        }\n    ]);\n    return Cropper;\n}();\nassign(Cropper.prototype, render, preview, events, handlers, change, methods);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY3JvcHBlcmpzL2Rpc3QvY3JvcHBlci5lc20uanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBOzs7Ozs7OztDQVFDLEdBRUQsU0FBU0EsUUFBUUMsQ0FBQyxFQUFFQyxDQUFDO0lBQ25CLElBQUlDLElBQUlDLE9BQU9DLElBQUksQ0FBQ0o7SUFDcEIsSUFBSUcsT0FBT0UscUJBQXFCLEVBQUU7UUFDaEMsSUFBSUMsSUFBSUgsT0FBT0UscUJBQXFCLENBQUNMO1FBQ3JDQyxLQUFNSyxDQUFBQSxJQUFJQSxFQUFFQyxNQUFNLENBQUMsU0FBVU4sQ0FBQztZQUM1QixPQUFPRSxPQUFPSyx3QkFBd0IsQ0FBQ1IsR0FBR0MsR0FBR1EsVUFBVTtRQUN6RCxFQUFDLEdBQUlQLEVBQUVRLElBQUksQ0FBQ0MsS0FBSyxDQUFDVCxHQUFHSTtJQUN2QjtJQUNBLE9BQU9KO0FBQ1Q7QUFDQSxTQUFTVSxlQUFlWixDQUFDO0lBQ3ZCLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJWSxVQUFVQyxNQUFNLEVBQUViLElBQUs7UUFDekMsSUFBSUMsSUFBSSxRQUFRVyxTQUFTLENBQUNaLEVBQUUsR0FBR1ksU0FBUyxDQUFDWixFQUFFLEdBQUcsQ0FBQztRQUMvQ0EsSUFBSSxJQUFJRixRQUFRSSxPQUFPRCxJQUFJLENBQUMsR0FBR2EsT0FBTyxDQUFDLFNBQVVkLENBQUM7WUFDaERlLGdCQUFnQmhCLEdBQUdDLEdBQUdDLENBQUMsQ0FBQ0QsRUFBRTtRQUM1QixLQUFLRSxPQUFPYyx5QkFBeUIsR0FBR2QsT0FBT2UsZ0JBQWdCLENBQUNsQixHQUFHRyxPQUFPYyx5QkFBeUIsQ0FBQ2YsTUFBTUgsUUFBUUksT0FBT0QsSUFBSWEsT0FBTyxDQUFDLFNBQVVkLENBQUM7WUFDOUlFLE9BQU9nQixjQUFjLENBQUNuQixHQUFHQyxHQUFHRSxPQUFPSyx3QkFBd0IsQ0FBQ04sR0FBR0Q7UUFDakU7SUFDRjtJQUNBLE9BQU9EO0FBQ1Q7QUFDQSxTQUFTb0IsUUFB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RGhqQixLQUFLO1lBQ0xLLE9BQU8sU0FBU3FsQixZQUFZNVosT0FBTztnQkFDakM1QyxPQUFPdkQsVUFBVWlELGNBQWNrRCxZQUFZQTtZQUM3QztRQUNGO0tBQUU7SUFDRixPQUFPa1g7QUFDVDtBQUNBOVosT0FBTzhaLFFBQVE3akIsU0FBUyxFQUFFOFksUUFBUS9SLFNBQVNrVyxRQUFRaUIsVUFBVTBCLFFBQVFZO0FBRXZDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLWVjb21tZXJjZS11aXQvLi9ub2RlX21vZHVsZXMvY3JvcHBlcmpzL2Rpc3QvY3JvcHBlci5lc20uanM/NTNjMyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIENyb3BwZXIuanMgdjEuNi4xXG4gKiBodHRwczovL2Zlbmd5dWFuY2hlbi5naXRodWIuaW8vY3JvcHBlcmpzXG4gKlxuICogQ29weXJpZ2h0IDIwMTUtcHJlc2VudCBDaGVuIEZlbmd5dWFuXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqXG4gKiBEYXRlOiAyMDIzLTA5LTE3VDAzOjQ0OjE5Ljg2MFpcbiAqL1xuXG5mdW5jdGlvbiBvd25LZXlzKGUsIHIpIHtcbiAgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTtcbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7XG4gICAgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlO1xuICAgIH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pO1xuICB9XG4gIHJldHVybiB0O1xufVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZDIoZSkge1xuICBmb3IgKHZhciByID0gMTsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKykge1xuICAgIHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTtcbiAgICByICUgMiA/IG93bktleXMoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikge1xuICAgICAgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pO1xuICAgIH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzKE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBlO1xufVxuZnVuY3Rpb24gX3R5cGVvZihvKSB7XG4gIFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjtcblxuICByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBvO1xuICB9IDogZnVuY3Rpb24gKG8pIHtcbiAgICByZXR1cm4gbyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbztcbiAgfSwgX3R5cGVvZihvKTtcbn1cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBfdG9Qcm9wZXJ0eUtleShkZXNjcmlwdG9yLmtleSksIGRlc2NyaXB0b3IpO1xuICB9XG59XG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIiwge1xuICAgIHdyaXRhYmxlOiBmYWxzZVxuICB9KTtcbiAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkge1xuICBrZXkgPSBfdG9Qcm9wZXJ0eUtleShrZXkpO1xuICBpZiAoa2V5IGluIG9iaikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4gb2JqO1xufVxuZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikge1xuICByZXR1cm4gX2FycmF5V2l0aG91dEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheShhcnIpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIpIHx8IF9ub25JdGVyYWJsZVNwcmVhZCgpO1xufVxuZnVuY3Rpb24gX2FycmF5V2l0aG91dEhvbGVzKGFycikge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkoYXJyKTtcbn1cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXkoaXRlcikge1xuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBpdGVyW1N5bWJvbC5pdGVyYXRvcl0gIT0gbnVsbCB8fCBpdGVyW1wiQEBpdGVyYXRvclwiXSAhPSBudWxsKSByZXR1cm4gQXJyYXkuZnJvbShpdGVyKTtcbn1cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHtcbiAgaWYgKCFvKSByZXR1cm47XG4gIGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG4gIHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTtcbiAgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTtcbiAgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7XG4gIGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbn1cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7XG4gIGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIGFycjJbaV0gPSBhcnJbaV07XG4gIHJldHVybiBhcnIyO1xufVxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbn1cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZShpbnB1dCwgaGludCkge1xuICBpZiAodHlwZW9mIGlucHV0ICE9PSBcIm9iamVjdFwiIHx8IGlucHV0ID09PSBudWxsKSByZXR1cm4gaW5wdXQ7XG4gIHZhciBwcmltID0gaW5wdXRbU3ltYm9sLnRvUHJpbWl0aXZlXTtcbiAgaWYgKHByaW0gIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciByZXMgPSBwcmltLmNhbGwoaW5wdXQsIGhpbnQgfHwgXCJkZWZhdWx0XCIpO1xuICAgIGlmICh0eXBlb2YgcmVzICE9PSBcIm9iamVjdFwiKSByZXR1cm4gcmVzO1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTtcbiAgfVxuICByZXR1cm4gKGhpbnQgPT09IFwic3RyaW5nXCIgPyBTdHJpbmcgOiBOdW1iZXIpKGlucHV0KTtcbn1cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KGFyZykge1xuICB2YXIga2V5ID0gX3RvUHJpbWl0aXZlKGFyZywgXCJzdHJpbmdcIik7XG4gIHJldHVybiB0eXBlb2Yga2V5ID09PSBcInN5bWJvbFwiID8ga2V5IDogU3RyaW5nKGtleSk7XG59XG5cbnZhciBJU19CUk9XU0VSID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCc7XG52YXIgV0lORE9XID0gSVNfQlJPV1NFUiA/IHdpbmRvdyA6IHt9O1xudmFyIElTX1RPVUNIX0RFVklDRSA9IElTX0JST1dTRVIgJiYgV0lORE9XLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudCA/ICdvbnRvdWNoc3RhcnQnIGluIFdJTkRPVy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgOiBmYWxzZTtcbnZhciBIQVNfUE9JTlRFUl9FVkVOVCA9IElTX0JST1dTRVIgPyAnUG9pbnRlckV2ZW50JyBpbiBXSU5ET1cgOiBmYWxzZTtcbnZhciBOQU1FU1BBQ0UgPSAnY3JvcHBlcic7XG5cbi8vIEFjdGlvbnNcbnZhciBBQ1RJT05fQUxMID0gJ2FsbCc7XG52YXIgQUNUSU9OX0NST1AgPSAnY3JvcCc7XG52YXIgQUNUSU9OX01PVkUgPSAnbW92ZSc7XG52YXIgQUNUSU9OX1pPT00gPSAnem9vbSc7XG52YXIgQUNUSU9OX0VBU1QgPSAnZSc7XG52YXIgQUNUSU9OX1dFU1QgPSAndyc7XG52YXIgQUNUSU9OX1NPVVRIID0gJ3MnO1xudmFyIEFDVElPTl9OT1JUSCA9ICduJztcbnZhciBBQ1RJT05fTk9SVEhfRUFTVCA9ICduZSc7XG52YXIgQUNUSU9OX05PUlRIX1dFU1QgPSAnbncnO1xudmFyIEFDVElPTl9TT1VUSF9FQVNUID0gJ3NlJztcbnZhciBBQ1RJT05fU09VVEhfV0VTVCA9ICdzdyc7XG5cbi8vIENsYXNzZXNcbnZhciBDTEFTU19DUk9QID0gXCJcIi5jb25jYXQoTkFNRVNQQUNFLCBcIi1jcm9wXCIpO1xudmFyIENMQVNTX0RJU0FCTEVEID0gXCJcIi5jb25jYXQoTkFNRVNQQUNFLCBcIi1kaXNhYmxlZFwiKTtcbnZhciBDTEFTU19ISURERU4gPSBcIlwiLmNvbmNhdChOQU1FU1BBQ0UsIFwiLWhpZGRlblwiKTtcbnZhciBDTEFTU19ISURFID0gXCJcIi5jb25jYXQoTkFNRVNQQUNFLCBcIi1oaWRlXCIpO1xudmFyIENMQVNTX0lOVklTSUJMRSA9IFwiXCIuY29uY2F0KE5BTUVTUEFDRSwgXCItaW52aXNpYmxlXCIpO1xudmFyIENMQVNTX01PREFMID0gXCJcIi5jb25jYXQoTkFNRVNQQUNFLCBcIi1tb2RhbFwiKTtcbnZhciBDTEFTU19NT1ZFID0gXCJcIi5jb25jYXQoTkFNRVNQQUNFLCBcIi1tb3ZlXCIpO1xuXG4vLyBEYXRhIGtleXNcbnZhciBEQVRBX0FDVElPTiA9IFwiXCIuY29uY2F0KE5BTUVTUEFDRSwgXCJBY3Rpb25cIik7XG52YXIgREFUQV9QUkVWSUVXID0gXCJcIi5jb25jYXQoTkFNRVNQQUNFLCBcIlByZXZpZXdcIik7XG5cbi8vIERyYWcgbW9kZXNcbnZhciBEUkFHX01PREVfQ1JPUCA9ICdjcm9wJztcbnZhciBEUkFHX01PREVfTU9WRSA9ICdtb3ZlJztcbnZhciBEUkFHX01PREVfTk9ORSA9ICdub25lJztcblxuLy8gRXZlbnRzXG52YXIgRVZFTlRfQ1JPUCA9ICdjcm9wJztcbnZhciBFVkVOVF9DUk9QX0VORCA9ICdjcm9wZW5kJztcbnZhciBFVkVOVF9DUk9QX01PVkUgPSAnY3JvcG1vdmUnO1xudmFyIEVWRU5UX0NST1BfU1RBUlQgPSAnY3JvcHN0YXJ0JztcbnZhciBFVkVOVF9EQkxDTElDSyA9ICdkYmxjbGljayc7XG52YXIgRVZFTlRfVE9VQ0hfU1RBUlQgPSBJU19UT1VDSF9ERVZJQ0UgPyAndG91Y2hzdGFydCcgOiAnbW91c2Vkb3duJztcbnZhciBFVkVOVF9UT1VDSF9NT1ZFID0gSVNfVE9VQ0hfREVWSUNFID8gJ3RvdWNobW92ZScgOiAnbW91c2Vtb3ZlJztcbnZhciBFVkVOVF9UT1VDSF9FTkQgPSBJU19UT1VDSF9ERVZJQ0UgPyAndG91Y2hlbmQgdG91Y2hjYW5jZWwnIDogJ21vdXNldXAnO1xudmFyIEVWRU5UX1BPSU5URVJfRE9XTiA9IEhBU19QT0lOVEVSX0VWRU5UID8gJ3BvaW50ZXJkb3duJyA6IEVWRU5UX1RPVUNIX1NUQVJUO1xudmFyIEVWRU5UX1BPSU5URVJfTU9WRSA9IEhBU19QT0lOVEVSX0VWRU5UID8gJ3BvaW50ZXJtb3ZlJyA6IEVWRU5UX1RPVUNIX01PVkU7XG52YXIgRVZFTlRfUE9JTlRFUl9VUCA9IEhBU19QT0lOVEVSX0VWRU5UID8gJ3BvaW50ZXJ1cCBwb2ludGVyY2FuY2VsJyA6IEVWRU5UX1RPVUNIX0VORDtcbnZhciBFVkVOVF9SRUFEWSA9ICdyZWFkeSc7XG52YXIgRVZFTlRfUkVTSVpFID0gJ3Jlc2l6ZSc7XG52YXIgRVZFTlRfV0hFRUwgPSAnd2hlZWwnO1xudmFyIEVWRU5UX1pPT00gPSAnem9vbSc7XG5cbi8vIE1pbWUgdHlwZXNcbnZhciBNSU1FX1RZUEVfSlBFRyA9ICdpbWFnZS9qcGVnJztcblxuLy8gUmVnRXhwc1xudmFyIFJFR0VYUF9BQ1RJT05TID0gL15lfHd8c3xufHNlfHN3fG5lfG53fGFsbHxjcm9wfG1vdmV8em9vbSQvO1xudmFyIFJFR0VYUF9EQVRBX1VSTCA9IC9eZGF0YTovO1xudmFyIFJFR0VYUF9EQVRBX1VSTF9KUEVHID0gL15kYXRhOmltYWdlXFwvanBlZztiYXNlNjQsLztcbnZhciBSRUdFWFBfVEFHX05BTUUgPSAvXmltZ3xjYW52YXMkL2k7XG5cbi8vIE1pc2Ncbi8vIEluc3BpcmVkIGJ5IHRoZSBkZWZhdWx0IHdpZHRoIGFuZCBoZWlnaHQgb2YgYSBjYW52YXMgZWxlbWVudC5cbnZhciBNSU5fQ09OVEFJTkVSX1dJRFRIID0gMjAwO1xudmFyIE1JTl9DT05UQUlORVJfSEVJR0hUID0gMTAwO1xuXG52YXIgREVGQVVMVFMgPSB7XG4gIC8vIERlZmluZSB0aGUgdmlldyBtb2RlIG9mIHRoZSBjcm9wcGVyXG4gIHZpZXdNb2RlOiAwLFxuICAvLyAwLCAxLCAyLCAzXG5cbiAgLy8gRGVmaW5lIHRoZSBkcmFnZ2luZyBtb2RlIG9mIHRoZSBjcm9wcGVyXG4gIGRyYWdNb2RlOiBEUkFHX01PREVfQ1JPUCxcbiAgLy8gJ2Nyb3AnLCAnbW92ZScgb3IgJ25vbmUnXG5cbiAgLy8gRGVmaW5lIHRoZSBpbml0aWFsIGFzcGVjdCByYXRpbyBvZiB0aGUgY3JvcCBib3hcbiAgaW5pdGlhbEFzcGVjdFJhdGlvOiBOYU4sXG4gIC8vIERlZmluZSB0aGUgYXNwZWN0IHJhdGlvIG9mIHRoZSBjcm9wIGJveFxuICBhc3BlY3RSYXRpbzogTmFOLFxuICAvLyBBbiBvYmplY3Qgd2l0aCB0aGUgcHJldmlvdXMgY3JvcHBpbmcgcmVzdWx0IGRhdGFcbiAgZGF0YTogbnVsbCxcbiAgLy8gQSBzZWxlY3RvciBmb3IgYWRkaW5nIGV4dHJhIGNvbnRhaW5lcnMgdG8gcHJldmlld1xuICBwcmV2aWV3OiAnJyxcbiAgLy8gUmUtcmVuZGVyIHRoZSBjcm9wcGVyIHdoZW4gcmVzaXplIHRoZSB3aW5kb3dcbiAgcmVzcG9uc2l2ZTogdHJ1ZSxcbiAgLy8gUmVzdG9yZSB0aGUgY3JvcHBlZCBhcmVhIGFmdGVyIHJlc2l6ZSB0aGUgd2luZG93XG4gIHJlc3RvcmU6IHRydWUsXG4gIC8vIENoZWNrIGlmIHRoZSBjdXJyZW50IGltYWdlIGlzIGEgY3Jvc3Mtb3JpZ2luIGltYWdlXG4gIGNoZWNrQ3Jvc3NPcmlnaW46IHRydWUsXG4gIC8vIENoZWNrIHRoZSBjdXJyZW50IGltYWdlJ3MgRXhpZiBPcmllbnRhdGlvbiBpbmZvcm1hdGlvblxuICBjaGVja09yaWVudGF0aW9uOiB0cnVlLFxuICAvLyBTaG93IHRoZSBibGFjayBtb2RhbFxuICBtb2RhbDogdHJ1ZSxcbiAgLy8gU2hvdyB0aGUgZGFzaGVkIGxpbmVzIGZvciBndWlkaW5nXG4gIGd1aWRlczogdHJ1ZSxcbiAgLy8gU2hvdyB0aGUgY2VudGVyIGluZGljYXRvciBmb3IgZ3VpZGluZ1xuICBjZW50ZXI6IHRydWUsXG4gIC8vIFNob3cgdGhlIHdoaXRlIG1vZGFsIHRvIGhpZ2hsaWdodCB0aGUgY3JvcCBib3hcbiAgaGlnaGxpZ2h0OiB0cnVlLFxuICAvLyBTaG93IHRoZSBncmlkIGJhY2tncm91bmRcbiAgYmFja2dyb3VuZDogdHJ1ZSxcbiAgLy8gRW5hYmxlIHRvIGNyb3AgdGhlIGltYWdlIGF1dG9tYXRpY2FsbHkgd2hlbiBpbml0aWFsaXplXG4gIGF1dG9Dcm9wOiB0cnVlLFxuICAvLyBEZWZpbmUgdGhlIHBlcmNlbnRhZ2Ugb2YgYXV0b21hdGljIGNyb3BwaW5nIGFyZWEgd2hlbiBpbml0aWFsaXplc1xuICBhdXRvQ3JvcEFyZWE6IDAuOCxcbiAgLy8gRW5hYmxlIHRvIG1vdmUgdGhlIGltYWdlXG4gIG1vdmFibGU6IHRydWUsXG4gIC8vIEVuYWJsZSB0byByb3RhdGUgdGhlIGltYWdlXG4gIHJvdGF0YWJsZTogdHJ1ZSxcbiAgLy8gRW5hYmxlIHRvIHNjYWxlIHRoZSBpbWFnZVxuICBzY2FsYWJsZTogdHJ1ZSxcbiAgLy8gRW5hYmxlIHRvIHpvb20gdGhlIGltYWdlXG4gIHpvb21hYmxlOiB0cnVlLFxuICAvLyBFbmFibGUgdG8gem9vbSB0aGUgaW1hZ2UgYnkgZHJhZ2dpbmcgdG91Y2hcbiAgem9vbU9uVG91Y2g6IHRydWUsXG4gIC8vIEVuYWJsZSB0byB6b29tIHRoZSBpbWFnZSBieSB3aGVlbGluZyBtb3VzZVxuICB6b29tT25XaGVlbDogdHJ1ZSxcbiAgLy8gRGVmaW5lIHpvb20gcmF0aW8gd2hlbiB6b29tIHRoZSBpbWFnZSBieSB3aGVlbGluZyBtb3VzZVxuICB3aGVlbFpvb21SYXRpbzogMC4xLFxuICAvLyBFbmFibGUgdG8gbW92ZSB0aGUgY3JvcCBib3hcbiAgY3JvcEJveE1vdmFibGU6IHRydWUsXG4gIC8vIEVuYWJsZSB0byByZXNpemUgdGhlIGNyb3AgYm94XG4gIGNyb3BCb3hSZXNpemFibGU6IHRydWUsXG4gIC8vIFRvZ2dsZSBkcmFnIG1vZGUgYmV0d2VlbiBcImNyb3BcIiBhbmQgXCJtb3ZlXCIgd2hlbiBjbGljayB0d2ljZSBvbiB0aGUgY3JvcHBlclxuICB0b2dnbGVEcmFnTW9kZU9uRGJsY2xpY2s6IHRydWUsXG4gIC8vIFNpemUgbGltaXRhdGlvblxuICBtaW5DYW52YXNXaWR0aDogMCxcbiAgbWluQ2FudmFzSGVpZ2h0OiAwLFxuICBtaW5Dcm9wQm94V2lkdGg6IDAsXG4gIG1pbkNyb3BCb3hIZWlnaHQ6IDAsXG4gIG1pbkNvbnRhaW5lcldpZHRoOiBNSU5fQ09OVEFJTkVSX1dJRFRILFxuICBtaW5Db250YWluZXJIZWlnaHQ6IE1JTl9DT05UQUlORVJfSEVJR0hULFxuICAvLyBTaG9ydGN1dHMgb2YgZXZlbnRzXG4gIHJlYWR5OiBudWxsLFxuICBjcm9wc3RhcnQ6IG51bGwsXG4gIGNyb3Btb3ZlOiBudWxsLFxuICBjcm9wZW5kOiBudWxsLFxuICBjcm9wOiBudWxsLFxuICB6b29tOiBudWxsXG59O1xuXG52YXIgVEVNUExBVEUgPSAnPGRpdiBjbGFzcz1cImNyb3BwZXItY29udGFpbmVyXCIgdG91Y2gtYWN0aW9uPVwibm9uZVwiPicgKyAnPGRpdiBjbGFzcz1cImNyb3BwZXItd3JhcC1ib3hcIj4nICsgJzxkaXYgY2xhc3M9XCJjcm9wcGVyLWNhbnZhc1wiPjwvZGl2PicgKyAnPC9kaXY+JyArICc8ZGl2IGNsYXNzPVwiY3JvcHBlci1kcmFnLWJveFwiPjwvZGl2PicgKyAnPGRpdiBjbGFzcz1cImNyb3BwZXItY3JvcC1ib3hcIj4nICsgJzxzcGFuIGNsYXNzPVwiY3JvcHBlci12aWV3LWJveFwiPjwvc3Bhbj4nICsgJzxzcGFuIGNsYXNzPVwiY3JvcHBlci1kYXNoZWQgZGFzaGVkLWhcIj48L3NwYW4+JyArICc8c3BhbiBjbGFzcz1cImNyb3BwZXItZGFzaGVkIGRhc2hlZC12XCI+PC9zcGFuPicgKyAnPHNwYW4gY2xhc3M9XCJjcm9wcGVyLWNlbnRlclwiPjwvc3Bhbj4nICsgJzxzcGFuIGNsYXNzPVwiY3JvcHBlci1mYWNlXCI+PC9zcGFuPicgKyAnPHNwYW4gY2xhc3M9XCJjcm9wcGVyLWxpbmUgbGluZS1lXCIgZGF0YS1jcm9wcGVyLWFjdGlvbj1cImVcIj48L3NwYW4+JyArICc8c3BhbiBjbGFzcz1cImNyb3BwZXItbGluZSBsaW5lLW5cIiBkYXRhLWNyb3BwZXItYWN0aW9uPVwiblwiPjwvc3Bhbj4nICsgJzxzcGFuIGNsYXNzPVwiY3JvcHBlci1saW5lIGxpbmUtd1wiIGRhdGEtY3JvcHBlci1hY3Rpb249XCJ3XCI+PC9zcGFuPicgKyAnPHNwYW4gY2xhc3M9XCJjcm9wcGVyLWxpbmUgbGluZS1zXCIgZGF0YS1jcm9wcGVyLWFjdGlvbj1cInNcIj48L3NwYW4+JyArICc8c3BhbiBjbGFzcz1cImNyb3BwZXItcG9pbnQgcG9pbnQtZVwiIGRhdGEtY3JvcHBlci1hY3Rpb249XCJlXCI+PC9zcGFuPicgKyAnPHNwYW4gY2xhc3M9XCJjcm9wcGVyLXBvaW50IHBvaW50LW5cIiBkYXRhLWNyb3BwZXItYWN0aW9uPVwiblwiPjwvc3Bhbj4nICsgJzxzcGFuIGNsYXNzPVwiY3JvcHBlci1wb2ludCBwb2ludC13XCIgZGF0YS1jcm9wcGVyLWFjdGlvbj1cIndcIj48L3NwYW4+JyArICc8c3BhbiBjbGFzcz1cImNyb3BwZXItcG9pbnQgcG9pbnQtc1wiIGRhdGEtY3JvcHBlci1hY3Rpb249XCJzXCI+PC9zcGFuPicgKyAnPHNwYW4gY2xhc3M9XCJjcm9wcGVyLXBvaW50IHBvaW50LW5lXCIgZGF0YS1jcm9wcGVyLWFjdGlvbj1cIm5lXCI+PC9zcGFuPicgKyAnPHNwYW4gY2xhc3M9XCJjcm9wcGVyLXBvaW50IHBvaW50LW53XCIgZGF0YS1jcm9wcGVyLWFjdGlvbj1cIm53XCI+PC9zcGFuPicgKyAnPHNwYW4gY2xhc3M9XCJjcm9wcGVyLXBvaW50IHBvaW50LXN3XCIgZGF0YS1jcm9wcGVyLWFjdGlvbj1cInN3XCI+PC9zcGFuPicgKyAnPHNwYW4gY2xhc3M9XCJjcm9wcGVyLXBvaW50IHBvaW50LXNlXCIgZGF0YS1jcm9wcGVyLWFjdGlvbj1cInNlXCI+PC9zcGFuPicgKyAnPC9kaXY+JyArICc8L2Rpdj4nO1xuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBub3QgYSBudW1iZXIuXG4gKi9cbnZhciBpc05hTiA9IE51bWJlci5pc05hTiB8fCBXSU5ET1cuaXNOYU47XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGEgbnVtYmVyLlxuICogQHBhcmFtIHsqfSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSBudW1iZXIsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNOdW1iZXIodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgIWlzTmFOKHZhbHVlKTtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSBwb3NpdGl2ZSBudW1iZXIuXG4gKiBAcGFyYW0geyp9IHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHBvc2l0aXZlIG51bWJlciwgZWxzZSBgZmFsc2VgLlxuICovXG52YXIgaXNQb3NpdGl2ZU51bWJlciA9IGZ1bmN0aW9uIGlzUG9zaXRpdmVOdW1iZXIodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID4gMCAmJiB2YWx1ZSA8IEluZmluaXR5O1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgdW5kZWZpbmVkLlxuICogQHBhcmFtIHsqfSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgdW5kZWZpbmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhbiBvYmplY3QuXG4gKiBAcGFyYW0geyp9IHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIF90eXBlb2YodmFsdWUpID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbDtcbn1cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGEgcGxhaW4gb2JqZWN0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSBwbGFpbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB0cnkge1xuICAgIHZhciBfY29uc3RydWN0b3IgPSB2YWx1ZS5jb25zdHJ1Y3RvcjtcbiAgICB2YXIgcHJvdG90eXBlID0gX2NvbnN0cnVjdG9yLnByb3RvdHlwZTtcbiAgICByZXR1cm4gX2NvbnN0cnVjdG9yICYmIHByb3RvdHlwZSAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3RvdHlwZSwgJ2lzUHJvdG90eXBlT2YnKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGEgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nO1xufVxudmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuXG4vKipcbiAqIENvbnZlcnQgYXJyYXktbGlrZSBvciBpdGVyYWJsZSBvYmplY3QgdG8gYW4gYXJyYXkuXG4gKiBAcGFyYW0geyp9IHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBuZXcgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIHRvQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIEFycmF5LmZyb20gPyBBcnJheS5mcm9tKHZhbHVlKSA6IHNsaWNlLmNhbGwodmFsdWUpO1xufVxuXG4vKipcbiAqIEl0ZXJhdGUgdGhlIGdpdmVuIGRhdGEuXG4gKiBAcGFyYW0geyp9IGRhdGEgLSBUaGUgZGF0YSB0byBpdGVyYXRlLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBUaGUgcHJvY2VzcyBmdW5jdGlvbiBmb3IgZWFjaCBlbGVtZW50LlxuICogQHJldHVybnMgeyp9IFRoZSBvcmlnaW5hbCBkYXRhLlxuICovXG5mdW5jdGlvbiBmb3JFYWNoKGRhdGEsIGNhbGxiYWNrKSB7XG4gIGlmIChkYXRhICYmIGlzRnVuY3Rpb24oY2FsbGJhY2spKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkgfHwgaXNOdW1iZXIoZGF0YS5sZW5ndGgpIC8qIGFycmF5LWxpa2UgKi8pIHtcbiAgICAgIHRvQXJyYXkoZGF0YSkuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgICBjYWxsYmFjay5jYWxsKGRhdGEsIHZhbHVlLCBrZXksIGRhdGEpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChpc09iamVjdChkYXRhKSkge1xuICAgICAgT2JqZWN0LmtleXMoZGF0YSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGNhbGxiYWNrLmNhbGwoZGF0YSwgZGF0YVtrZXldLCBrZXksIGRhdGEpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIEV4dGVuZCB0aGUgZ2l2ZW4gb2JqZWN0LlxuICogQHBhcmFtIHsqfSB0YXJnZXQgLSBUaGUgdGFyZ2V0IG9iamVjdCB0byBleHRlbmQuXG4gKiBAcGFyYW0geyp9IGFyZ3MgLSBUaGUgcmVzdCBvYmplY3RzIGZvciBtZXJnaW5nIHRvIHRoZSB0YXJnZXQgb2JqZWN0LlxuICogQHJldHVybnMge09iamVjdH0gVGhlIGV4dGVuZGVkIG9iamVjdC5cbiAqL1xudmFyIGFzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gYXNzaWduKHRhcmdldCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cbiAgaWYgKGlzT2JqZWN0KHRhcmdldCkgJiYgYXJncy5sZW5ndGggPiAwKSB7XG4gICAgYXJncy5mb3JFYWNoKGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgIGlmIChpc09iamVjdChhcmcpKSB7XG4gICAgICAgIE9iamVjdC5rZXlzKGFyZykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgdGFyZ2V0W2tleV0gPSBhcmdba2V5XTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn07XG52YXIgUkVHRVhQX0RFQ0lNQUxTID0gL1xcLlxcZCooPzowfDkpezEyfVxcZCokLztcblxuLyoqXG4gKiBOb3JtYWxpemUgZGVjaW1hbCBudW1iZXIuXG4gKiBDaGVjayBvdXQge0BsaW5rIGh0dHBzOi8vMC4zMDAwMDAwMDAwMDAwMDAwNC5jb20vfVxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIC0gVGhlIHZhbHVlIHRvIG5vcm1hbGl6ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbdGltZXM9MTAwMDAwMDAwMDAwXSAtIFRoZSB0aW1lcyBmb3Igbm9ybWFsaXppbmcuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBub3JtYWxpemVkIG51bWJlci5cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplRGVjaW1hbE51bWJlcih2YWx1ZSkge1xuICB2YXIgdGltZXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDEwMDAwMDAwMDAwMDtcbiAgcmV0dXJuIFJFR0VYUF9ERUNJTUFMUy50ZXN0KHZhbHVlKSA/IE1hdGgucm91bmQodmFsdWUgKiB0aW1lcykgLyB0aW1lcyA6IHZhbHVlO1xufVxudmFyIFJFR0VYUF9TVUZGSVggPSAvXndpZHRofGhlaWdodHxsZWZ0fHRvcHxtYXJnaW5MZWZ0fG1hcmdpblRvcCQvO1xuXG4vKipcbiAqIEFwcGx5IHN0eWxlcyB0byB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCAtIFRoZSB0YXJnZXQgZWxlbWVudC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdHlsZXMgLSBUaGUgc3R5bGVzIGZvciBhcHBseWluZy5cbiAqL1xuZnVuY3Rpb24gc2V0U3R5bGUoZWxlbWVudCwgc3R5bGVzKSB7XG4gIHZhciBzdHlsZSA9IGVsZW1lbnQuc3R5bGU7XG4gIGZvckVhY2goc3R5bGVzLCBmdW5jdGlvbiAodmFsdWUsIHByb3BlcnR5KSB7XG4gICAgaWYgKFJFR0VYUF9TVUZGSVgudGVzdChwcm9wZXJ0eSkgJiYgaXNOdW1iZXIodmFsdWUpKSB7XG4gICAgICB2YWx1ZSA9IFwiXCIuY29uY2F0KHZhbHVlLCBcInB4XCIpO1xuICAgIH1cbiAgICBzdHlsZVtwcm9wZXJ0eV0gPSB2YWx1ZTtcbiAgfSk7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIGVsZW1lbnQgaGFzIGEgc3BlY2lhbCBjbGFzcy5cbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCAtIFRoZSBlbGVtZW50IHRvIGNoZWNrLlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIC0gVGhlIGNsYXNzIHRvIHNlYXJjaC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgc3BlY2lhbCBjbGFzcyB3YXMgZm91bmQuXG4gKi9cbmZ1bmN0aW9uIGhhc0NsYXNzKGVsZW1lbnQsIHZhbHVlKSB7XG4gIHJldHVybiBlbGVtZW50LmNsYXNzTGlzdCA/IGVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKHZhbHVlKSA6IGVsZW1lbnQuY2xhc3NOYW1lLmluZGV4T2YodmFsdWUpID4gLTE7XG59XG5cbi8qKlxuICogQWRkIGNsYXNzZXMgdG8gdGhlIGdpdmVuIGVsZW1lbnQuXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgLSBUaGUgdGFyZ2V0IGVsZW1lbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgLSBUaGUgY2xhc3NlcyB0byBiZSBhZGRlZC5cbiAqL1xuZnVuY3Rpb24gYWRkQ2xhc3MoZWxlbWVudCwgdmFsdWUpIHtcbiAgaWYgKCF2YWx1ZSkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoaXNOdW1iZXIoZWxlbWVudC5sZW5ndGgpKSB7XG4gICAgZm9yRWFjaChlbGVtZW50LCBmdW5jdGlvbiAoZWxlbSkge1xuICAgICAgYWRkQ2xhc3MoZWxlbSwgdmFsdWUpO1xuICAgIH0pO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoZWxlbWVudC5jbGFzc0xpc3QpIHtcbiAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQodmFsdWUpO1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgY2xhc3NOYW1lID0gZWxlbWVudC5jbGFzc05hbWUudHJpbSgpO1xuICBpZiAoIWNsYXNzTmFtZSkge1xuICAgIGVsZW1lbnQuY2xhc3NOYW1lID0gdmFsdWU7XG4gIH0gZWxzZSBpZiAoY2xhc3NOYW1lLmluZGV4T2YodmFsdWUpIDwgMCkge1xuICAgIGVsZW1lbnQuY2xhc3NOYW1lID0gXCJcIi5jb25jYXQoY2xhc3NOYW1lLCBcIiBcIikuY29uY2F0KHZhbHVlKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZSBjbGFzc2VzIGZyb20gdGhlIGdpdmVuIGVsZW1lbnQuXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgLSBUaGUgdGFyZ2V0IGVsZW1lbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgLSBUaGUgY2xhc3NlcyB0byBiZSByZW1vdmVkLlxuICovXG5mdW5jdGlvbiByZW1vdmVDbGFzcyhlbGVtZW50LCB2YWx1ZSkge1xuICBpZiAoIXZhbHVlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChpc051bWJlcihlbGVtZW50Lmxlbmd0aCkpIHtcbiAgICBmb3JFYWNoKGVsZW1lbnQsIGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICByZW1vdmVDbGFzcyhlbGVtLCB2YWx1ZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChlbGVtZW50LmNsYXNzTGlzdCkge1xuICAgIGVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZSh2YWx1ZSk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChlbGVtZW50LmNsYXNzTmFtZS5pbmRleE9mKHZhbHVlKSA+PSAwKSB7XG4gICAgZWxlbWVudC5jbGFzc05hbWUgPSBlbGVtZW50LmNsYXNzTmFtZS5yZXBsYWNlKHZhbHVlLCAnJyk7XG4gIH1cbn1cblxuLyoqXG4gKiBBZGQgb3IgcmVtb3ZlIGNsYXNzZXMgZnJvbSB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCAtIFRoZSB0YXJnZXQgZWxlbWVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSAtIFRoZSBjbGFzc2VzIHRvIGJlIHRvZ2dsZWQuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGFkZGVkIC0gQWRkIG9ubHkuXG4gKi9cbmZ1bmN0aW9uIHRvZ2dsZUNsYXNzKGVsZW1lbnQsIHZhbHVlLCBhZGRlZCkge1xuICBpZiAoIXZhbHVlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChpc051bWJlcihlbGVtZW50Lmxlbmd0aCkpIHtcbiAgICBmb3JFYWNoKGVsZW1lbnQsIGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICB0b2dnbGVDbGFzcyhlbGVtLCB2YWx1ZSwgYWRkZWQpO1xuICAgIH0pO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIElFMTAtMTEgZG9lc24ndCBzdXBwb3J0IHRoZSBzZWNvbmQgcGFyYW1ldGVyIG9mIGBjbGFzc0xpc3QudG9nZ2xlYFxuICBpZiAoYWRkZWQpIHtcbiAgICBhZGRDbGFzcyhlbGVtZW50LCB2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgcmVtb3ZlQ2xhc3MoZWxlbWVudCwgdmFsdWUpO1xuICB9XG59XG52YXIgUkVHRVhQX0NBTUVMX0NBU0UgPSAvKFthLXpcXGRdKShbQS1aXSkvZztcblxuLyoqXG4gKiBUcmFuc2Zvcm0gdGhlIGdpdmVuIHN0cmluZyBmcm9tIGNhbWVsQ2FzZSB0byBrZWJhYi1jYXNlXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgLSBUaGUgdmFsdWUgdG8gdHJhbnNmb3JtLlxuICogQHJldHVybnMge3N0cmluZ30gVGhlIHRyYW5zZm9ybWVkIHZhbHVlLlxuICovXG5mdW5jdGlvbiB0b1BhcmFtQ2FzZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUucmVwbGFjZShSRUdFWFBfQ0FNRUxfQ0FTRSwgJyQxLSQyJykudG9Mb3dlckNhc2UoKTtcbn1cblxuLyoqXG4gKiBHZXQgZGF0YSBmcm9tIHRoZSBnaXZlbiBlbGVtZW50LlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IC0gVGhlIHRhcmdldCBlbGVtZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBUaGUgZGF0YSBrZXkgdG8gZ2V0LlxuICogQHJldHVybnMge3N0cmluZ30gVGhlIGRhdGEgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGdldERhdGEoZWxlbWVudCwgbmFtZSkge1xuICBpZiAoaXNPYmplY3QoZWxlbWVudFtuYW1lXSkpIHtcbiAgICByZXR1cm4gZWxlbWVudFtuYW1lXTtcbiAgfVxuICBpZiAoZWxlbWVudC5kYXRhc2V0KSB7XG4gICAgcmV0dXJuIGVsZW1lbnQuZGF0YXNldFtuYW1lXTtcbiAgfVxuICByZXR1cm4gZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJkYXRhLVwiLmNvbmNhdCh0b1BhcmFtQ2FzZShuYW1lKSkpO1xufVxuXG4vKipcbiAqIFNldCBkYXRhIHRvIHRoZSBnaXZlbiBlbGVtZW50LlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IC0gVGhlIHRhcmdldCBlbGVtZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBUaGUgZGF0YSBrZXkgdG8gc2V0LlxuICogQHBhcmFtIHtzdHJpbmd9IGRhdGEgLSBUaGUgZGF0YSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gc2V0RGF0YShlbGVtZW50LCBuYW1lLCBkYXRhKSB7XG4gIGlmIChpc09iamVjdChkYXRhKSkge1xuICAgIGVsZW1lbnRbbmFtZV0gPSBkYXRhO1xuICB9IGVsc2UgaWYgKGVsZW1lbnQuZGF0YXNldCkge1xuICAgIGVsZW1lbnQuZGF0YXNldFtuYW1lXSA9IGRhdGE7XG4gIH0gZWxzZSB7XG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJkYXRhLVwiLmNvbmNhdCh0b1BhcmFtQ2FzZShuYW1lKSksIGRhdGEpO1xuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlIGRhdGEgZnJvbSB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCAtIFRoZSB0YXJnZXQgZWxlbWVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gVGhlIGRhdGEga2V5IHRvIHJlbW92ZS5cbiAqL1xuZnVuY3Rpb24gcmVtb3ZlRGF0YShlbGVtZW50LCBuYW1lKSB7XG4gIGlmIChpc09iamVjdChlbGVtZW50W25hbWVdKSkge1xuICAgIHRyeSB7XG4gICAgICBkZWxldGUgZWxlbWVudFtuYW1lXTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgZWxlbWVudFtuYW1lXSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZWxlbWVudC5kYXRhc2V0KSB7XG4gICAgLy8gIzEyOCBTYWZhcmkgbm90IGFsbG93cyB0byBkZWxldGUgZGF0YXNldCBwcm9wZXJ0eVxuICAgIHRyeSB7XG4gICAgICBkZWxldGUgZWxlbWVudC5kYXRhc2V0W25hbWVdO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBlbGVtZW50LmRhdGFzZXRbbmFtZV0gPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKFwiZGF0YS1cIi5jb25jYXQodG9QYXJhbUNhc2UobmFtZSkpKTtcbiAgfVxufVxudmFyIFJFR0VYUF9TUEFDRVMgPSAvXFxzXFxzKi87XG52YXIgb25jZVN1cHBvcnRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN1cHBvcnRlZCA9IGZhbHNlO1xuICBpZiAoSVNfQlJPV1NFUikge1xuICAgIHZhciBvbmNlID0gZmFsc2U7XG4gICAgdmFyIGxpc3RlbmVyID0gZnVuY3Rpb24gbGlzdGVuZXIoKSB7fTtcbiAgICB2YXIgb3B0aW9ucyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ29uY2UnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgc3VwcG9ydGVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIG9uY2U7XG4gICAgICB9LFxuICAgICAgLyoqXG4gICAgICAgKiBUaGlzIHNldHRlciBjYW4gZml4IGEgYFR5cGVFcnJvcmAgaW4gc3RyaWN0IG1vZGVcbiAgICAgICAqIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9FcnJvcnMvR2V0dGVyX29ubHl9XG4gICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHZhbHVlIC0gVGhlIHZhbHVlIHRvIHNldFxuICAgICAgICovXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICBvbmNlID0gdmFsdWU7XG4gICAgICB9XG4gICAgfSk7XG4gICAgV0lORE9XLmFkZEV2ZW50TGlzdGVuZXIoJ3Rlc3QnLCBsaXN0ZW5lciwgb3B0aW9ucyk7XG4gICAgV0lORE9XLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Rlc3QnLCBsaXN0ZW5lciwgb3B0aW9ucyk7XG4gIH1cbiAgcmV0dXJuIHN1cHBvcnRlZDtcbn0oKTtcblxuLyoqXG4gKiBSZW1vdmUgZXZlbnQgbGlzdGVuZXIgZnJvbSB0aGUgdGFyZ2V0IGVsZW1lbnQuXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgLSBUaGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgLSBUaGUgZXZlbnQgdHlwZShzKS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGxpc3RlbmVyIC0gVGhlIGV2ZW50IGxpc3RlbmVyLlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBUaGUgZXZlbnQgb3B0aW9ucy5cbiAqL1xuZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIoZWxlbWVudCwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IHt9O1xuICB2YXIgaGFuZGxlciA9IGxpc3RlbmVyO1xuICB0eXBlLnRyaW0oKS5zcGxpdChSRUdFWFBfU1BBQ0VTKS5mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkge1xuICAgIGlmICghb25jZVN1cHBvcnRlZCkge1xuICAgICAgdmFyIGxpc3RlbmVycyA9IGVsZW1lbnQubGlzdGVuZXJzO1xuICAgICAgaWYgKGxpc3RlbmVycyAmJiBsaXN0ZW5lcnNbZXZlbnRdICYmIGxpc3RlbmVyc1tldmVudF1bbGlzdGVuZXJdKSB7XG4gICAgICAgIGhhbmRsZXIgPSBsaXN0ZW5lcnNbZXZlbnRdW2xpc3RlbmVyXTtcbiAgICAgICAgZGVsZXRlIGxpc3RlbmVyc1tldmVudF1bbGlzdGVuZXJdO1xuICAgICAgICBpZiAoT2JqZWN0LmtleXMobGlzdGVuZXJzW2V2ZW50XSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgZGVsZXRlIGxpc3RlbmVyc1tldmVudF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKGxpc3RlbmVycykubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgZGVsZXRlIGVsZW1lbnQubGlzdGVuZXJzO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlciwgb3B0aW9ucyk7XG4gIH0pO1xufVxuXG4vKipcbiAqIEFkZCBldmVudCBsaXN0ZW5lciB0byB0aGUgdGFyZ2V0IGVsZW1lbnQuXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgLSBUaGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgLSBUaGUgZXZlbnQgdHlwZShzKS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGxpc3RlbmVyIC0gVGhlIGV2ZW50IGxpc3RlbmVyLlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBUaGUgZXZlbnQgb3B0aW9ucy5cbiAqL1xuZnVuY3Rpb24gYWRkTGlzdGVuZXIoZWxlbWVudCwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IHt9O1xuICB2YXIgX2hhbmRsZXIgPSBsaXN0ZW5lcjtcbiAgdHlwZS50cmltKCkuc3BsaXQoUkVHRVhQX1NQQUNFUykuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBpZiAob3B0aW9ucy5vbmNlICYmICFvbmNlU3VwcG9ydGVkKSB7XG4gICAgICB2YXIgX2VsZW1lbnQkbGlzdGVuZXJzID0gZWxlbWVudC5saXN0ZW5lcnMsXG4gICAgICAgIGxpc3RlbmVycyA9IF9lbGVtZW50JGxpc3RlbmVycyA9PT0gdm9pZCAwID8ge30gOiBfZWxlbWVudCRsaXN0ZW5lcnM7XG4gICAgICBfaGFuZGxlciA9IGZ1bmN0aW9uIGhhbmRsZXIoKSB7XG4gICAgICAgIGRlbGV0ZSBsaXN0ZW5lcnNbZXZlbnRdW2xpc3RlbmVyXTtcbiAgICAgICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBfaGFuZGxlciwgb3B0aW9ucyk7XG4gICAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiksIF9rZXkyID0gMDsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICAgIGFyZ3NbX2tleTJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgICAgfVxuICAgICAgICBsaXN0ZW5lci5hcHBseShlbGVtZW50LCBhcmdzKTtcbiAgICAgIH07XG4gICAgICBpZiAoIWxpc3RlbmVyc1tldmVudF0pIHtcbiAgICAgICAgbGlzdGVuZXJzW2V2ZW50XSA9IHt9O1xuICAgICAgfVxuICAgICAgaWYgKGxpc3RlbmVyc1tldmVudF1bbGlzdGVuZXJdKSB7XG4gICAgICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgbGlzdGVuZXJzW2V2ZW50XVtsaXN0ZW5lcl0sIG9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgbGlzdGVuZXJzW2V2ZW50XVtsaXN0ZW5lcl0gPSBfaGFuZGxlcjtcbiAgICAgIGVsZW1lbnQubGlzdGVuZXJzID0gbGlzdGVuZXJzO1xuICAgIH1cbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIF9oYW5kbGVyLCBvcHRpb25zKTtcbiAgfSk7XG59XG5cbi8qKlxuICogRGlzcGF0Y2ggZXZlbnQgb24gdGhlIHRhcmdldCBlbGVtZW50LlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IC0gVGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIC0gVGhlIGV2ZW50IHR5cGUocykuXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YSAtIFRoZSBhZGRpdGlvbmFsIGV2ZW50IGRhdGEuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gSW5kaWNhdGUgaWYgdGhlIGV2ZW50IGlzIGRlZmF1bHQgcHJldmVudGVkIG9yIG5vdC5cbiAqL1xuZnVuY3Rpb24gZGlzcGF0Y2hFdmVudChlbGVtZW50LCB0eXBlLCBkYXRhKSB7XG4gIHZhciBldmVudDtcblxuICAvLyBFdmVudCBhbmQgQ3VzdG9tRXZlbnQgb24gSUU5LTExIGFyZSBnbG9iYWwgb2JqZWN0cywgbm90IGNvbnN0cnVjdG9yc1xuICBpZiAoaXNGdW5jdGlvbihFdmVudCkgJiYgaXNGdW5jdGlvbihDdXN0b21FdmVudCkpIHtcbiAgICBldmVudCA9IG5ldyBDdXN0b21FdmVudCh0eXBlLCB7XG4gICAgICBkZXRhaWw6IGRhdGEsXG4gICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgY2FuY2VsYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0N1c3RvbUV2ZW50Jyk7XG4gICAgZXZlbnQuaW5pdEN1c3RvbUV2ZW50KHR5cGUsIHRydWUsIHRydWUsIGRhdGEpO1xuICB9XG4gIHJldHVybiBlbGVtZW50LmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xufVxuXG4vKipcbiAqIEdldCB0aGUgb2Zmc2V0IGJhc2Ugb24gdGhlIGRvY3VtZW50LlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IC0gVGhlIHRhcmdldCBlbGVtZW50LlxuICogQHJldHVybnMge09iamVjdH0gVGhlIG9mZnNldCBkYXRhLlxuICovXG5mdW5jdGlvbiBnZXRPZmZzZXQoZWxlbWVudCkge1xuICB2YXIgYm94ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgcmV0dXJuIHtcbiAgICBsZWZ0OiBib3gubGVmdCArICh3aW5kb3cucGFnZVhPZmZzZXQgLSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50TGVmdCksXG4gICAgdG9wOiBib3gudG9wICsgKHdpbmRvdy5wYWdlWU9mZnNldCAtIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRUb3ApXG4gIH07XG59XG52YXIgbG9jYXRpb24gPSBXSU5ET1cubG9jYXRpb247XG52YXIgUkVHRVhQX09SSUdJTlMgPSAvXihcXHcrOilcXC9cXC8oW146Lz8jXSopOj8oXFxkKikvaTtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgZ2l2ZW4gVVJMIGlzIGEgY3Jvc3Mgb3JpZ2luIFVSTC5cbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgLSBUaGUgdGFyZ2V0IFVSTC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZ2l2ZW4gVVJMIGlzIGEgY3Jvc3Mgb3JpZ2luIFVSTCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0Nyb3NzT3JpZ2luVVJMKHVybCkge1xuICB2YXIgcGFydHMgPSB1cmwubWF0Y2goUkVHRVhQX09SSUdJTlMpO1xuICByZXR1cm4gcGFydHMgIT09IG51bGwgJiYgKHBhcnRzWzFdICE9PSBsb2NhdGlvbi5wcm90b2NvbCB8fCBwYXJ0c1syXSAhPT0gbG9jYXRpb24uaG9zdG5hbWUgfHwgcGFydHNbM10gIT09IGxvY2F0aW9uLnBvcnQpO1xufVxuXG4vKipcbiAqIEFkZCB0aW1lc3RhbXAgdG8gdGhlIGdpdmVuIFVSTC5cbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgLSBUaGUgdGFyZ2V0IFVSTC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSByZXN1bHQgVVJMLlxuICovXG5mdW5jdGlvbiBhZGRUaW1lc3RhbXAodXJsKSB7XG4gIHZhciB0aW1lc3RhbXAgPSBcInRpbWVzdGFtcD1cIi5jb25jYXQobmV3IERhdGUoKS5nZXRUaW1lKCkpO1xuICByZXR1cm4gdXJsICsgKHVybC5pbmRleE9mKCc/JykgPT09IC0xID8gJz8nIDogJyYnKSArIHRpbWVzdGFtcDtcbn1cblxuLyoqXG4gKiBHZXQgdHJhbnNmb3JtcyBiYXNlIG9uIHRoZSBnaXZlbiBvYmplY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIC0gVGhlIHRhcmdldCBvYmplY3QuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBBIHN0cmluZyBjb250YWlucyB0cmFuc2Zvcm0gdmFsdWVzLlxuICovXG5mdW5jdGlvbiBnZXRUcmFuc2Zvcm1zKF9yZWYpIHtcbiAgdmFyIHJvdGF0ZSA9IF9yZWYucm90YXRlLFxuICAgIHNjYWxlWCA9IF9yZWYuc2NhbGVYLFxuICAgIHNjYWxlWSA9IF9yZWYuc2NhbGVZLFxuICAgIHRyYW5zbGF0ZVggPSBfcmVmLnRyYW5zbGF0ZVgsXG4gICAgdHJhbnNsYXRlWSA9IF9yZWYudHJhbnNsYXRlWTtcbiAgdmFyIHZhbHVlcyA9IFtdO1xuICBpZiAoaXNOdW1iZXIodHJhbnNsYXRlWCkgJiYgdHJhbnNsYXRlWCAhPT0gMCkge1xuICAgIHZhbHVlcy5wdXNoKFwidHJhbnNsYXRlWChcIi5jb25jYXQodHJhbnNsYXRlWCwgXCJweClcIikpO1xuICB9XG4gIGlmIChpc051bWJlcih0cmFuc2xhdGVZKSAmJiB0cmFuc2xhdGVZICE9PSAwKSB7XG4gICAgdmFsdWVzLnB1c2goXCJ0cmFuc2xhdGVZKFwiLmNvbmNhdCh0cmFuc2xhdGVZLCBcInB4KVwiKSk7XG4gIH1cblxuICAvLyBSb3RhdGUgc2hvdWxkIGNvbWUgZmlyc3QgYmVmb3JlIHNjYWxlIHRvIG1hdGNoIG9yaWVudGF0aW9uIHRyYW5zZm9ybVxuICBpZiAoaXNOdW1iZXIocm90YXRlKSAmJiByb3RhdGUgIT09IDApIHtcbiAgICB2YWx1ZXMucHVzaChcInJvdGF0ZShcIi5jb25jYXQocm90YXRlLCBcImRlZylcIikpO1xuICB9XG4gIGlmIChpc051bWJlcihzY2FsZVgpICYmIHNjYWxlWCAhPT0gMSkge1xuICAgIHZhbHVlcy5wdXNoKFwic2NhbGVYKFwiLmNvbmNhdChzY2FsZVgsIFwiKVwiKSk7XG4gIH1cbiAgaWYgKGlzTnVtYmVyKHNjYWxlWSkgJiYgc2NhbGVZICE9PSAxKSB7XG4gICAgdmFsdWVzLnB1c2goXCJzY2FsZVkoXCIuY29uY2F0KHNjYWxlWSwgXCIpXCIpKTtcbiAgfVxuICB2YXIgdHJhbnNmb3JtID0gdmFsdWVzLmxlbmd0aCA/IHZhbHVlcy5qb2luKCcgJykgOiAnbm9uZSc7XG4gIHJldHVybiB7XG4gICAgV2Via2l0VHJhbnNmb3JtOiB0cmFuc2Zvcm0sXG4gICAgbXNUcmFuc2Zvcm06IHRyYW5zZm9ybSxcbiAgICB0cmFuc2Zvcm06IHRyYW5zZm9ybVxuICB9O1xufVxuXG4vKipcbiAqIEdldCB0aGUgbWF4IHJhdGlvIG9mIGEgZ3JvdXAgb2YgcG9pbnRlcnMuXG4gKiBAcGFyYW0ge3N0cmluZ30gcG9pbnRlcnMgLSBUaGUgdGFyZ2V0IHBvaW50ZXJzLlxuICogQHJldHVybnMge251bWJlcn0gVGhlIHJlc3VsdCByYXRpby5cbiAqL1xuZnVuY3Rpb24gZ2V0TWF4Wm9vbVJhdGlvKHBvaW50ZXJzKSB7XG4gIHZhciBwb2ludGVyczIgPSBfb2JqZWN0U3ByZWFkMih7fSwgcG9pbnRlcnMpO1xuICB2YXIgbWF4UmF0aW8gPSAwO1xuICBmb3JFYWNoKHBvaW50ZXJzLCBmdW5jdGlvbiAocG9pbnRlciwgcG9pbnRlcklkKSB7XG4gICAgZGVsZXRlIHBvaW50ZXJzMltwb2ludGVySWRdO1xuICAgIGZvckVhY2gocG9pbnRlcnMyLCBmdW5jdGlvbiAocG9pbnRlcjIpIHtcbiAgICAgIHZhciB4MSA9IE1hdGguYWJzKHBvaW50ZXIuc3RhcnRYIC0gcG9pbnRlcjIuc3RhcnRYKTtcbiAgICAgIHZhciB5MSA9IE1hdGguYWJzKHBvaW50ZXIuc3RhcnRZIC0gcG9pbnRlcjIuc3RhcnRZKTtcbiAgICAgIHZhciB4MiA9IE1hdGguYWJzKHBvaW50ZXIuZW5kWCAtIHBvaW50ZXIyLmVuZFgpO1xuICAgICAgdmFyIHkyID0gTWF0aC5hYnMocG9pbnRlci5lbmRZIC0gcG9pbnRlcjIuZW5kWSk7XG4gICAgICB2YXIgejEgPSBNYXRoLnNxcnQoeDEgKiB4MSArIHkxICogeTEpO1xuICAgICAgdmFyIHoyID0gTWF0aC5zcXJ0KHgyICogeDIgKyB5MiAqIHkyKTtcbiAgICAgIHZhciByYXRpbyA9ICh6MiAtIHoxKSAvIHoxO1xuICAgICAgaWYgKE1hdGguYWJzKHJhdGlvKSA+IE1hdGguYWJzKG1heFJhdGlvKSkge1xuICAgICAgICBtYXhSYXRpbyA9IHJhdGlvO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIG1heFJhdGlvO1xufVxuXG4vKipcbiAqIEdldCBhIHBvaW50ZXIgZnJvbSBhbiBldmVudCBvYmplY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSBUaGUgdGFyZ2V0IGV2ZW50IG9iamVjdC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gZW5kT25seSAtIEluZGljYXRlcyBpZiBvbmx5IHJldHVybnMgdGhlIGVuZCBwb2ludCBjb29yZGluYXRlIG9yIG5vdC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSByZXN1bHQgcG9pbnRlciBjb250YWlucyBzdGFydCBhbmQvb3IgZW5kIHBvaW50IGNvb3JkaW5hdGVzLlxuICovXG5mdW5jdGlvbiBnZXRQb2ludGVyKF9yZWYyLCBlbmRPbmx5KSB7XG4gIHZhciBwYWdlWCA9IF9yZWYyLnBhZ2VYLFxuICAgIHBhZ2VZID0gX3JlZjIucGFnZVk7XG4gIHZhciBlbmQgPSB7XG4gICAgZW5kWDogcGFnZVgsXG4gICAgZW5kWTogcGFnZVlcbiAgfTtcbiAgcmV0dXJuIGVuZE9ubHkgPyBlbmQgOiBfb2JqZWN0U3ByZWFkMih7XG4gICAgc3RhcnRYOiBwYWdlWCxcbiAgICBzdGFydFk6IHBhZ2VZXG4gIH0sIGVuZCk7XG59XG5cbi8qKlxuICogR2V0IHRoZSBjZW50ZXIgcG9pbnQgY29vcmRpbmF0ZSBvZiBhIGdyb3VwIG9mIHBvaW50ZXJzLlxuICogQHBhcmFtIHtPYmplY3R9IHBvaW50ZXJzIC0gVGhlIHRhcmdldCBwb2ludGVycy5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBjZW50ZXIgcG9pbnQgY29vcmRpbmF0ZS5cbiAqL1xuZnVuY3Rpb24gZ2V0UG9pbnRlcnNDZW50ZXIocG9pbnRlcnMpIHtcbiAgdmFyIHBhZ2VYID0gMDtcbiAgdmFyIHBhZ2VZID0gMDtcbiAgdmFyIGNvdW50ID0gMDtcbiAgZm9yRWFjaChwb2ludGVycywgZnVuY3Rpb24gKF9yZWYzKSB7XG4gICAgdmFyIHN0YXJ0WCA9IF9yZWYzLnN0YXJ0WCxcbiAgICAgIHN0YXJ0WSA9IF9yZWYzLnN0YXJ0WTtcbiAgICBwYWdlWCArPSBzdGFydFg7XG4gICAgcGFnZVkgKz0gc3RhcnRZO1xuICAgIGNvdW50ICs9IDE7XG4gIH0pO1xuICBwYWdlWCAvPSBjb3VudDtcbiAgcGFnZVkgLz0gY291bnQ7XG4gIHJldHVybiB7XG4gICAgcGFnZVg6IHBhZ2VYLFxuICAgIHBhZ2VZOiBwYWdlWVxuICB9O1xufVxuXG4vKipcbiAqIEdldCB0aGUgbWF4IHNpemVzIGluIGEgcmVjdGFuZ2xlIHVuZGVyIHRoZSBnaXZlbiBhc3BlY3QgcmF0aW8uXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YSAtIFRoZSBvcmlnaW5hbCBzaXplcy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbdHlwZT0nY29udGFpbiddIC0gVGhlIGFkanVzdCB0eXBlLlxuICogQHJldHVybnMge09iamVjdH0gVGhlIHJlc3VsdCBzaXplcy5cbiAqL1xuZnVuY3Rpb24gZ2V0QWRqdXN0ZWRTaXplcyhfcmVmNCkge1xuICB2YXIgYXNwZWN0UmF0aW8gPSBfcmVmNC5hc3BlY3RSYXRpbyxcbiAgICBoZWlnaHQgPSBfcmVmNC5oZWlnaHQsXG4gICAgd2lkdGggPSBfcmVmNC53aWR0aDtcbiAgdmFyIHR5cGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6ICdjb250YWluJztcbiAgdmFyIGlzVmFsaWRXaWR0aCA9IGlzUG9zaXRpdmVOdW1iZXIod2lkdGgpO1xuICB2YXIgaXNWYWxpZEhlaWdodCA9IGlzUG9zaXRpdmVOdW1iZXIoaGVpZ2h0KTtcbiAgaWYgKGlzVmFsaWRXaWR0aCAmJiBpc1ZhbGlkSGVpZ2h0KSB7XG4gICAgdmFyIGFkanVzdGVkV2lkdGggPSBoZWlnaHQgKiBhc3BlY3RSYXRpbztcbiAgICBpZiAodHlwZSA9PT0gJ2NvbnRhaW4nICYmIGFkanVzdGVkV2lkdGggPiB3aWR0aCB8fCB0eXBlID09PSAnY292ZXInICYmIGFkanVzdGVkV2lkdGggPCB3aWR0aCkge1xuICAgICAgaGVpZ2h0ID0gd2lkdGggLyBhc3BlY3RSYXRpbztcbiAgICB9IGVsc2Uge1xuICAgICAgd2lkdGggPSBoZWlnaHQgKiBhc3BlY3RSYXRpbztcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNWYWxpZFdpZHRoKSB7XG4gICAgaGVpZ2h0ID0gd2lkdGggLyBhc3BlY3RSYXRpbztcbiAgfSBlbHNlIGlmIChpc1ZhbGlkSGVpZ2h0KSB7XG4gICAgd2lkdGggPSBoZWlnaHQgKiBhc3BlY3RSYXRpbztcbiAgfVxuICByZXR1cm4ge1xuICAgIHdpZHRoOiB3aWR0aCxcbiAgICBoZWlnaHQ6IGhlaWdodFxuICB9O1xufVxuXG4vKipcbiAqIEdldCB0aGUgbmV3IHNpemVzIG9mIGEgcmVjdGFuZ2xlIGFmdGVyIHJvdGF0ZWQuXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YSAtIFRoZSBvcmlnaW5hbCBzaXplcy5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSByZXN1bHQgc2l6ZXMuXG4gKi9cbmZ1bmN0aW9uIGdldFJvdGF0ZWRTaXplcyhfcmVmNSkge1xuICB2YXIgd2lkdGggPSBfcmVmNS53aWR0aCxcbiAgICBoZWlnaHQgPSBfcmVmNS5oZWlnaHQsXG4gICAgZGVncmVlID0gX3JlZjUuZGVncmVlO1xuICBkZWdyZWUgPSBNYXRoLmFicyhkZWdyZWUpICUgMTgwO1xuICBpZiAoZGVncmVlID09PSA5MCkge1xuICAgIHJldHVybiB7XG4gICAgICB3aWR0aDogaGVpZ2h0LFxuICAgICAgaGVpZ2h0OiB3aWR0aFxuICAgIH07XG4gIH1cbiAgdmFyIGFyYyA9IGRlZ3JlZSAlIDkwICogTWF0aC5QSSAvIDE4MDtcbiAgdmFyIHNpbkFyYyA9IE1hdGguc2luKGFyYyk7XG4gIHZhciBjb3NBcmMgPSBNYXRoLmNvcyhhcmMpO1xuICB2YXIgbmV3V2lkdGggPSB3aWR0aCAqIGNvc0FyYyArIGhlaWdodCAqIHNpbkFyYztcbiAgdmFyIG5ld0hlaWdodCA9IHdpZHRoICogc2luQXJjICsgaGVpZ2h0ICogY29zQXJjO1xuICByZXR1cm4gZGVncmVlID4gOTAgPyB7XG4gICAgd2lkdGg6IG5ld0hlaWdodCxcbiAgICBoZWlnaHQ6IG5ld1dpZHRoXG4gIH0gOiB7XG4gICAgd2lkdGg6IG5ld1dpZHRoLFxuICAgIGhlaWdodDogbmV3SGVpZ2h0XG4gIH07XG59XG5cbi8qKlxuICogR2V0IGEgY2FudmFzIHdoaWNoIGRyZXcgdGhlIGdpdmVuIGltYWdlLlxuICogQHBhcmFtIHtIVE1MSW1hZ2VFbGVtZW50fSBpbWFnZSAtIFRoZSBpbWFnZSBmb3IgZHJhd2luZy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBpbWFnZURhdGEgLSBUaGUgaW1hZ2UgZGF0YS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjYW52YXNEYXRhIC0gVGhlIGNhbnZhcyBkYXRhLlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBUaGUgb3B0aW9ucy5cbiAqIEByZXR1cm5zIHtIVE1MQ2FudmFzRWxlbWVudH0gVGhlIHJlc3VsdCBjYW52YXMuXG4gKi9cbmZ1bmN0aW9uIGdldFNvdXJjZUNhbnZhcyhpbWFnZSwgX3JlZjYsIF9yZWY3LCBfcmVmOCkge1xuICB2YXIgaW1hZ2VBc3BlY3RSYXRpbyA9IF9yZWY2LmFzcGVjdFJhdGlvLFxuICAgIGltYWdlTmF0dXJhbFdpZHRoID0gX3JlZjYubmF0dXJhbFdpZHRoLFxuICAgIGltYWdlTmF0dXJhbEhlaWdodCA9IF9yZWY2Lm5hdHVyYWxIZWlnaHQsXG4gICAgX3JlZjYkcm90YXRlID0gX3JlZjYucm90YXRlLFxuICAgIHJvdGF0ZSA9IF9yZWY2JHJvdGF0ZSA9PT0gdm9pZCAwID8gMCA6IF9yZWY2JHJvdGF0ZSxcbiAgICBfcmVmNiRzY2FsZVggPSBfcmVmNi5zY2FsZVgsXG4gICAgc2NhbGVYID0gX3JlZjYkc2NhbGVYID09PSB2b2lkIDAgPyAxIDogX3JlZjYkc2NhbGVYLFxuICAgIF9yZWY2JHNjYWxlWSA9IF9yZWY2LnNjYWxlWSxcbiAgICBzY2FsZVkgPSBfcmVmNiRzY2FsZVkgPT09IHZvaWQgMCA/IDEgOiBfcmVmNiRzY2FsZVk7XG4gIHZhciBhc3BlY3RSYXRpbyA9IF9yZWY3LmFzcGVjdFJhdGlvLFxuICAgIG5hdHVyYWxXaWR0aCA9IF9yZWY3Lm5hdHVyYWxXaWR0aCxcbiAgICBuYXR1cmFsSGVpZ2h0ID0gX3JlZjcubmF0dXJhbEhlaWdodDtcbiAgdmFyIF9yZWY4JGZpbGxDb2xvciA9IF9yZWY4LmZpbGxDb2xvcixcbiAgICBmaWxsQ29sb3IgPSBfcmVmOCRmaWxsQ29sb3IgPT09IHZvaWQgMCA/ICd0cmFuc3BhcmVudCcgOiBfcmVmOCRmaWxsQ29sb3IsXG4gICAgX3JlZjgkaW1hZ2VTbW9vdGhpbmdFID0gX3JlZjguaW1hZ2VTbW9vdGhpbmdFbmFibGVkLFxuICAgIGltYWdlU21vb3RoaW5nRW5hYmxlZCA9IF9yZWY4JGltYWdlU21vb3RoaW5nRSA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9yZWY4JGltYWdlU21vb3RoaW5nRSxcbiAgICBfcmVmOCRpbWFnZVNtb290aGluZ1EgPSBfcmVmOC5pbWFnZVNtb290aGluZ1F1YWxpdHksXG4gICAgaW1hZ2VTbW9vdGhpbmdRdWFsaXR5ID0gX3JlZjgkaW1hZ2VTbW9vdGhpbmdRID09PSB2b2lkIDAgPyAnbG93JyA6IF9yZWY4JGltYWdlU21vb3RoaW5nUSxcbiAgICBfcmVmOCRtYXhXaWR0aCA9IF9yZWY4Lm1heFdpZHRoLFxuICAgIG1heFdpZHRoID0gX3JlZjgkbWF4V2lkdGggPT09IHZvaWQgMCA/IEluZmluaXR5IDogX3JlZjgkbWF4V2lkdGgsXG4gICAgX3JlZjgkbWF4SGVpZ2h0ID0gX3JlZjgubWF4SGVpZ2h0LFxuICAgIG1heEhlaWdodCA9IF9yZWY4JG1heEhlaWdodCA9PT0gdm9pZCAwID8gSW5maW5pdHkgOiBfcmVmOCRtYXhIZWlnaHQsXG4gICAgX3JlZjgkbWluV2lkdGggPSBfcmVmOC5taW5XaWR0aCxcbiAgICBtaW5XaWR0aCA9IF9yZWY4JG1pbldpZHRoID09PSB2b2lkIDAgPyAwIDogX3JlZjgkbWluV2lkdGgsXG4gICAgX3JlZjgkbWluSGVpZ2h0ID0gX3JlZjgubWluSGVpZ2h0LFxuICAgIG1pbkhlaWdodCA9IF9yZWY4JG1pbkhlaWdodCA9PT0gdm9pZCAwID8gMCA6IF9yZWY4JG1pbkhlaWdodDtcbiAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICB2YXIgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICB2YXIgbWF4U2l6ZXMgPSBnZXRBZGp1c3RlZFNpemVzKHtcbiAgICBhc3BlY3RSYXRpbzogYXNwZWN0UmF0aW8sXG4gICAgd2lkdGg6IG1heFdpZHRoLFxuICAgIGhlaWdodDogbWF4SGVpZ2h0XG4gIH0pO1xuICB2YXIgbWluU2l6ZXMgPSBnZXRBZGp1c3RlZFNpemVzKHtcbiAgICBhc3BlY3RSYXRpbzogYXNwZWN0UmF0aW8sXG4gICAgd2lkdGg6IG1pbldpZHRoLFxuICAgIGhlaWdodDogbWluSGVpZ2h0XG4gIH0sICdjb3ZlcicpO1xuICB2YXIgd2lkdGggPSBNYXRoLm1pbihtYXhTaXplcy53aWR0aCwgTWF0aC5tYXgobWluU2l6ZXMud2lkdGgsIG5hdHVyYWxXaWR0aCkpO1xuICB2YXIgaGVpZ2h0ID0gTWF0aC5taW4obWF4U2l6ZXMuaGVpZ2h0LCBNYXRoLm1heChtaW5TaXplcy5oZWlnaHQsIG5hdHVyYWxIZWlnaHQpKTtcblxuICAvLyBOb3RlOiBzaG91bGQgYWx3YXlzIHVzZSBpbWFnZSdzIG5hdHVyYWwgc2l6ZXMgZm9yIGRyYXdpbmcgYXNcbiAgLy8gaW1hZ2VEYXRhLm5hdHVyYWxXaWR0aCA9PT0gY2FudmFzRGF0YS5uYXR1cmFsSGVpZ2h0IHdoZW4gcm90YXRlICUgMTgwID09PSA5MFxuICB2YXIgZGVzdE1heFNpemVzID0gZ2V0QWRqdXN0ZWRTaXplcyh7XG4gICAgYXNwZWN0UmF0aW86IGltYWdlQXNwZWN0UmF0aW8sXG4gICAgd2lkdGg6IG1heFdpZHRoLFxuICAgIGhlaWdodDogbWF4SGVpZ2h0XG4gIH0pO1xuICB2YXIgZGVzdE1pblNpemVzID0gZ2V0QWRqdXN0ZWRTaXplcyh7XG4gICAgYXNwZWN0UmF0aW86IGltYWdlQXNwZWN0UmF0aW8sXG4gICAgd2lkdGg6IG1pbldpZHRoLFxuICAgIGhlaWdodDogbWluSGVpZ2h0XG4gIH0sICdjb3ZlcicpO1xuICB2YXIgZGVzdFdpZHRoID0gTWF0aC5taW4oZGVzdE1heFNpemVzLndpZHRoLCBNYXRoLm1heChkZXN0TWluU2l6ZXMud2lkdGgsIGltYWdlTmF0dXJhbFdpZHRoKSk7XG4gIHZhciBkZXN0SGVpZ2h0ID0gTWF0aC5taW4oZGVzdE1heFNpemVzLmhlaWdodCwgTWF0aC5tYXgoZGVzdE1pblNpemVzLmhlaWdodCwgaW1hZ2VOYXR1cmFsSGVpZ2h0KSk7XG4gIHZhciBwYXJhbXMgPSBbLWRlc3RXaWR0aCAvIDIsIC1kZXN0SGVpZ2h0IC8gMiwgZGVzdFdpZHRoLCBkZXN0SGVpZ2h0XTtcbiAgY2FudmFzLndpZHRoID0gbm9ybWFsaXplRGVjaW1hbE51bWJlcih3aWR0aCk7XG4gIGNhbnZhcy5oZWlnaHQgPSBub3JtYWxpemVEZWNpbWFsTnVtYmVyKGhlaWdodCk7XG4gIGNvbnRleHQuZmlsbFN0eWxlID0gZmlsbENvbG9yO1xuICBjb250ZXh0LmZpbGxSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICBjb250ZXh0LnNhdmUoKTtcbiAgY29udGV4dC50cmFuc2xhdGUod2lkdGggLyAyLCBoZWlnaHQgLyAyKTtcbiAgY29udGV4dC5yb3RhdGUocm90YXRlICogTWF0aC5QSSAvIDE4MCk7XG4gIGNvbnRleHQuc2NhbGUoc2NhbGVYLCBzY2FsZVkpO1xuICBjb250ZXh0LmltYWdlU21vb3RoaW5nRW5hYmxlZCA9IGltYWdlU21vb3RoaW5nRW5hYmxlZDtcbiAgY29udGV4dC5pbWFnZVNtb290aGluZ1F1YWxpdHkgPSBpbWFnZVNtb290aGluZ1F1YWxpdHk7XG4gIGNvbnRleHQuZHJhd0ltYWdlLmFwcGx5KGNvbnRleHQsIFtpbWFnZV0uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShwYXJhbXMubWFwKGZ1bmN0aW9uIChwYXJhbSkge1xuICAgIHJldHVybiBNYXRoLmZsb29yKG5vcm1hbGl6ZURlY2ltYWxOdW1iZXIocGFyYW0pKTtcbiAgfSkpKSk7XG4gIGNvbnRleHQucmVzdG9yZSgpO1xuICByZXR1cm4gY2FudmFzO1xufVxudmFyIGZyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGU7XG5cbi8qKlxuICogR2V0IHN0cmluZyBmcm9tIGNoYXIgY29kZSBpbiBkYXRhIHZpZXcuXG4gKiBAcGFyYW0ge0RhdGFWaWV3fSBkYXRhVmlldyAtIFRoZSBkYXRhIHZpZXcgZm9yIHJlYWQuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgLSBUaGUgc3RhcnQgaW5kZXguXG4gKiBAcGFyYW0ge251bWJlcn0gbGVuZ3RoIC0gVGhlIHJlYWQgbGVuZ3RoLlxuICogQHJldHVybnMge3N0cmluZ30gVGhlIHJlYWQgcmVzdWx0LlxuICovXG5mdW5jdGlvbiBnZXRTdHJpbmdGcm9tQ2hhckNvZGUoZGF0YVZpZXcsIHN0YXJ0LCBsZW5ndGgpIHtcbiAgdmFyIHN0ciA9ICcnO1xuICBsZW5ndGggKz0gc3RhcnQ7XG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgc3RyICs9IGZyb21DaGFyQ29kZShkYXRhVmlldy5nZXRVaW50OChpKSk7XG4gIH1cbiAgcmV0dXJuIHN0cjtcbn1cbnZhciBSRUdFWFBfREFUQV9VUkxfSEVBRCA9IC9eZGF0YTouKiwvO1xuXG4vKipcbiAqIFRyYW5zZm9ybSBEYXRhIFVSTCB0byBhcnJheSBidWZmZXIuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGF0YVVSTCAtIFRoZSBEYXRhIFVSTCB0byB0cmFuc2Zvcm0uXG4gKiBAcmV0dXJucyB7QXJyYXlCdWZmZXJ9IFRoZSByZXN1bHQgYXJyYXkgYnVmZmVyLlxuICovXG5mdW5jdGlvbiBkYXRhVVJMVG9BcnJheUJ1ZmZlcihkYXRhVVJMKSB7XG4gIHZhciBiYXNlNjQgPSBkYXRhVVJMLnJlcGxhY2UoUkVHRVhQX0RBVEFfVVJMX0hFQUQsICcnKTtcbiAgdmFyIGJpbmFyeSA9IGF0b2IoYmFzZTY0KTtcbiAgdmFyIGFycmF5QnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKGJpbmFyeS5sZW5ndGgpO1xuICB2YXIgdWludDggPSBuZXcgVWludDhBcnJheShhcnJheUJ1ZmZlcik7XG4gIGZvckVhY2godWludDgsIGZ1bmN0aW9uICh2YWx1ZSwgaSkge1xuICAgIHVpbnQ4W2ldID0gYmluYXJ5LmNoYXJDb2RlQXQoaSk7XG4gIH0pO1xuICByZXR1cm4gYXJyYXlCdWZmZXI7XG59XG5cbi8qKlxuICogVHJhbnNmb3JtIGFycmF5IGJ1ZmZlciB0byBEYXRhIFVSTC5cbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGFycmF5QnVmZmVyIC0gVGhlIGFycmF5IGJ1ZmZlciB0byB0cmFuc2Zvcm0uXG4gKiBAcGFyYW0ge3N0cmluZ30gbWltZVR5cGUgLSBUaGUgbWltZSB0eXBlIG9mIHRoZSBEYXRhIFVSTC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSByZXN1bHQgRGF0YSBVUkwuXG4gKi9cbmZ1bmN0aW9uIGFycmF5QnVmZmVyVG9EYXRhVVJMKGFycmF5QnVmZmVyLCBtaW1lVHlwZSkge1xuICB2YXIgY2h1bmtzID0gW107XG5cbiAgLy8gQ2h1bmsgVHlwZWQgQXJyYXkgZm9yIGJldHRlciBwZXJmb3JtYW5jZSAoIzQzNSlcbiAgdmFyIGNodW5rU2l6ZSA9IDgxOTI7XG4gIHZhciB1aW50OCA9IG5ldyBVaW50OEFycmF5KGFycmF5QnVmZmVyKTtcbiAgd2hpbGUgKHVpbnQ4Lmxlbmd0aCA+IDApIHtcbiAgICAvLyBYWFg6IEJhYmVsJ3MgYHRvQ29uc3VtYWJsZUFycmF5YCBoZWxwZXIgd2lsbCB0aHJvdyBlcnJvciBpbiBJRSBvciBTYWZhcmkgOVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItc3ByZWFkXG4gICAgY2h1bmtzLnB1c2goZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIHRvQXJyYXkodWludDguc3ViYXJyYXkoMCwgY2h1bmtTaXplKSkpKTtcbiAgICB1aW50OCA9IHVpbnQ4LnN1YmFycmF5KGNodW5rU2l6ZSk7XG4gIH1cbiAgcmV0dXJuIFwiZGF0YTpcIi5jb25jYXQobWltZVR5cGUsIFwiO2Jhc2U2NCxcIikuY29uY2F0KGJ0b2EoY2h1bmtzLmpvaW4oJycpKSk7XG59XG5cbi8qKlxuICogR2V0IG9yaWVudGF0aW9uIHZhbHVlIGZyb20gZ2l2ZW4gYXJyYXkgYnVmZmVyLlxuICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gYXJyYXlCdWZmZXIgLSBUaGUgYXJyYXkgYnVmZmVyIHRvIHJlYWQuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgcmVhZCBvcmllbnRhdGlvbiB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gcmVzZXRBbmRHZXRPcmllbnRhdGlvbihhcnJheUJ1ZmZlcikge1xuICB2YXIgZGF0YVZpZXcgPSBuZXcgRGF0YVZpZXcoYXJyYXlCdWZmZXIpO1xuICB2YXIgb3JpZW50YXRpb247XG5cbiAgLy8gSWdub3JlcyByYW5nZSBlcnJvciB3aGVuIHRoZSBpbWFnZSBkb2VzIG5vdCBoYXZlIGNvcnJlY3QgRXhpZiBpbmZvcm1hdGlvblxuICB0cnkge1xuICAgIHZhciBsaXR0bGVFbmRpYW47XG4gICAgdmFyIGFwcDFTdGFydDtcbiAgICB2YXIgaWZkU3RhcnQ7XG5cbiAgICAvLyBPbmx5IGhhbmRsZSBKUEVHIGltYWdlIChzdGFydCBieSAweEZGRDgpXG4gICAgaWYgKGRhdGFWaWV3LmdldFVpbnQ4KDApID09PSAweEZGICYmIGRhdGFWaWV3LmdldFVpbnQ4KDEpID09PSAweEQ4KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gZGF0YVZpZXcuYnl0ZUxlbmd0aDtcbiAgICAgIHZhciBvZmZzZXQgPSAyO1xuICAgICAgd2hpbGUgKG9mZnNldCArIDEgPCBsZW5ndGgpIHtcbiAgICAgICAgaWYgKGRhdGFWaWV3LmdldFVpbnQ4KG9mZnNldCkgPT09IDB4RkYgJiYgZGF0YVZpZXcuZ2V0VWludDgob2Zmc2V0ICsgMSkgPT09IDB4RTEpIHtcbiAgICAgICAgICBhcHAxU3RhcnQgPSBvZmZzZXQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgb2Zmc2V0ICs9IDE7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChhcHAxU3RhcnQpIHtcbiAgICAgIHZhciBleGlmSURDb2RlID0gYXBwMVN0YXJ0ICsgNDtcbiAgICAgIHZhciB0aWZmT2Zmc2V0ID0gYXBwMVN0YXJ0ICsgMTA7XG4gICAgICBpZiAoZ2V0U3RyaW5nRnJvbUNoYXJDb2RlKGRhdGFWaWV3LCBleGlmSURDb2RlLCA0KSA9PT0gJ0V4aWYnKSB7XG4gICAgICAgIHZhciBlbmRpYW5uZXNzID0gZGF0YVZpZXcuZ2V0VWludDE2KHRpZmZPZmZzZXQpO1xuICAgICAgICBsaXR0bGVFbmRpYW4gPSBlbmRpYW5uZXNzID09PSAweDQ5NDk7XG4gICAgICAgIGlmIChsaXR0bGVFbmRpYW4gfHwgZW5kaWFubmVzcyA9PT0gMHg0RDREIC8qIGJpZ0VuZGlhbiAqLykge1xuICAgICAgICAgIGlmIChkYXRhVmlldy5nZXRVaW50MTYodGlmZk9mZnNldCArIDIsIGxpdHRsZUVuZGlhbikgPT09IDB4MDAyQSkge1xuICAgICAgICAgICAgdmFyIGZpcnN0SUZET2Zmc2V0ID0gZGF0YVZpZXcuZ2V0VWludDMyKHRpZmZPZmZzZXQgKyA0LCBsaXR0bGVFbmRpYW4pO1xuICAgICAgICAgICAgaWYgKGZpcnN0SUZET2Zmc2V0ID49IDB4MDAwMDAwMDgpIHtcbiAgICAgICAgICAgICAgaWZkU3RhcnQgPSB0aWZmT2Zmc2V0ICsgZmlyc3RJRkRPZmZzZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpZmRTdGFydCkge1xuICAgICAgdmFyIF9sZW5ndGggPSBkYXRhVmlldy5nZXRVaW50MTYoaWZkU3RhcnQsIGxpdHRsZUVuZGlhbik7XG4gICAgICB2YXIgX29mZnNldDtcbiAgICAgIHZhciBpO1xuICAgICAgZm9yIChpID0gMDsgaSA8IF9sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBfb2Zmc2V0ID0gaWZkU3RhcnQgKyBpICogMTIgKyAyO1xuICAgICAgICBpZiAoZGF0YVZpZXcuZ2V0VWludDE2KF9vZmZzZXQsIGxpdHRsZUVuZGlhbikgPT09IDB4MDExMiAvKiBPcmllbnRhdGlvbiAqLykge1xuICAgICAgICAgIC8vIDggaXMgdGhlIG9mZnNldCBvZiB0aGUgY3VycmVudCB0YWcncyB2YWx1ZVxuICAgICAgICAgIF9vZmZzZXQgKz0gODtcblxuICAgICAgICAgIC8vIEdldCB0aGUgb3JpZ2luYWwgb3JpZW50YXRpb24gdmFsdWVcbiAgICAgICAgICBvcmllbnRhdGlvbiA9IGRhdGFWaWV3LmdldFVpbnQxNihfb2Zmc2V0LCBsaXR0bGVFbmRpYW4pO1xuXG4gICAgICAgICAgLy8gT3ZlcnJpZGUgdGhlIG9yaWVudGF0aW9uIHdpdGggaXRzIGRlZmF1bHQgdmFsdWVcbiAgICAgICAgICBkYXRhVmlldy5zZXRVaW50MTYoX29mZnNldCwgMSwgbGl0dGxlRW5kaWFuKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBvcmllbnRhdGlvbiA9IDE7XG4gIH1cbiAgcmV0dXJuIG9yaWVudGF0aW9uO1xufVxuXG4vKipcbiAqIFBhcnNlIEV4aWYgT3JpZW50YXRpb24gdmFsdWUuXG4gKiBAcGFyYW0ge251bWJlcn0gb3JpZW50YXRpb24gLSBUaGUgb3JpZW50YXRpb24gdG8gcGFyc2UuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgcGFyc2VkIHJlc3VsdC5cbiAqL1xuZnVuY3Rpb24gcGFyc2VPcmllbnRhdGlvbihvcmllbnRhdGlvbikge1xuICB2YXIgcm90YXRlID0gMDtcbiAgdmFyIHNjYWxlWCA9IDE7XG4gIHZhciBzY2FsZVkgPSAxO1xuICBzd2l0Y2ggKG9yaWVudGF0aW9uKSB7XG4gICAgLy8gRmxpcCBob3Jpem9udGFsXG4gICAgY2FzZSAyOlxuICAgICAgc2NhbGVYID0gLTE7XG4gICAgICBicmVhaztcblxuICAgIC8vIFJvdGF0ZSBsZWZ0IDE4MMKwXG4gICAgY2FzZSAzOlxuICAgICAgcm90YXRlID0gLTE4MDtcbiAgICAgIGJyZWFrO1xuXG4gICAgLy8gRmxpcCB2ZXJ0aWNhbFxuICAgIGNhc2UgNDpcbiAgICAgIHNjYWxlWSA9IC0xO1xuICAgICAgYnJlYWs7XG5cbiAgICAvLyBGbGlwIHZlcnRpY2FsIGFuZCByb3RhdGUgcmlnaHQgOTDCsFxuICAgIGNhc2UgNTpcbiAgICAgIHJvdGF0ZSA9IDkwO1xuICAgICAgc2NhbGVZID0gLTE7XG4gICAgICBicmVhaztcblxuICAgIC8vIFJvdGF0ZSByaWdodCA5MMKwXG4gICAgY2FzZSA2OlxuICAgICAgcm90YXRlID0gOTA7XG4gICAgICBicmVhaztcblxuICAgIC8vIEZsaXAgaG9yaXpvbnRhbCBhbmQgcm90YXRlIHJpZ2h0IDkwwrBcbiAgICBjYXNlIDc6XG4gICAgICByb3RhdGUgPSA5MDtcbiAgICAgIHNjYWxlWCA9IC0xO1xuICAgICAgYnJlYWs7XG5cbiAgICAvLyBSb3RhdGUgbGVmdCA5MMKwXG4gICAgY2FzZSA4OlxuICAgICAgcm90YXRlID0gLTkwO1xuICAgICAgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICByb3RhdGU6IHJvdGF0ZSxcbiAgICBzY2FsZVg6IHNjYWxlWCxcbiAgICBzY2FsZVk6IHNjYWxlWVxuICB9O1xufVxuXG52YXIgcmVuZGVyID0ge1xuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB0aGlzLmluaXRDb250YWluZXIoKTtcbiAgICB0aGlzLmluaXRDYW52YXMoKTtcbiAgICB0aGlzLmluaXRDcm9wQm94KCk7XG4gICAgdGhpcy5yZW5kZXJDYW52YXMoKTtcbiAgICBpZiAodGhpcy5jcm9wcGVkKSB7XG4gICAgICB0aGlzLnJlbmRlckNyb3BCb3goKTtcbiAgICB9XG4gIH0sXG4gIGluaXRDb250YWluZXI6IGZ1bmN0aW9uIGluaXRDb250YWluZXIoKSB7XG4gICAgdmFyIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQsXG4gICAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuICAgICAgY29udGFpbmVyID0gdGhpcy5jb250YWluZXIsXG4gICAgICBjcm9wcGVyID0gdGhpcy5jcm9wcGVyO1xuICAgIHZhciBtaW5XaWR0aCA9IE51bWJlcihvcHRpb25zLm1pbkNvbnRhaW5lcldpZHRoKTtcbiAgICB2YXIgbWluSGVpZ2h0ID0gTnVtYmVyKG9wdGlvbnMubWluQ29udGFpbmVySGVpZ2h0KTtcbiAgICBhZGRDbGFzcyhjcm9wcGVyLCBDTEFTU19ISURERU4pO1xuICAgIHJlbW92ZUNsYXNzKGVsZW1lbnQsIENMQVNTX0hJRERFTik7XG4gICAgdmFyIGNvbnRhaW5lckRhdGEgPSB7XG4gICAgICB3aWR0aDogTWF0aC5tYXgoY29udGFpbmVyLm9mZnNldFdpZHRoLCBtaW5XaWR0aCA+PSAwID8gbWluV2lkdGggOiBNSU5fQ09OVEFJTkVSX1dJRFRIKSxcbiAgICAgIGhlaWdodDogTWF0aC5tYXgoY29udGFpbmVyLm9mZnNldEhlaWdodCwgbWluSGVpZ2h0ID49IDAgPyBtaW5IZWlnaHQgOiBNSU5fQ09OVEFJTkVSX0hFSUdIVClcbiAgICB9O1xuICAgIHRoaXMuY29udGFpbmVyRGF0YSA9IGNvbnRhaW5lckRhdGE7XG4gICAgc2V0U3R5bGUoY3JvcHBlciwge1xuICAgICAgd2lkdGg6IGNvbnRhaW5lckRhdGEud2lkdGgsXG4gICAgICBoZWlnaHQ6IGNvbnRhaW5lckRhdGEuaGVpZ2h0XG4gICAgfSk7XG4gICAgYWRkQ2xhc3MoZWxlbWVudCwgQ0xBU1NfSElEREVOKTtcbiAgICByZW1vdmVDbGFzcyhjcm9wcGVyLCBDTEFTU19ISURERU4pO1xuICB9LFxuICAvLyBDYW52YXMgKGltYWdlIHdyYXBwZXIpXG4gIGluaXRDYW52YXM6IGZ1bmN0aW9uIGluaXRDYW52YXMoKSB7XG4gICAgdmFyIGNvbnRhaW5lckRhdGEgPSB0aGlzLmNvbnRhaW5lckRhdGEsXG4gICAgICBpbWFnZURhdGEgPSB0aGlzLmltYWdlRGF0YTtcbiAgICB2YXIgdmlld01vZGUgPSB0aGlzLm9wdGlvbnMudmlld01vZGU7XG4gICAgdmFyIHJvdGF0ZWQgPSBNYXRoLmFicyhpbWFnZURhdGEucm90YXRlKSAlIDE4MCA9PT0gOTA7XG4gICAgdmFyIG5hdHVyYWxXaWR0aCA9IHJvdGF0ZWQgPyBpbWFnZURhdGEubmF0dXJhbEhlaWdodCA6IGltYWdlRGF0YS5uYXR1cmFsV2lkdGg7XG4gICAgdmFyIG5hdHVyYWxIZWlnaHQgPSByb3RhdGVkID8gaW1hZ2VEYXRhLm5hdHVyYWxXaWR0aCA6IGltYWdlRGF0YS5uYXR1cmFsSGVpZ2h0O1xuICAgIHZhciBhc3BlY3RSYXRpbyA9IG5hdHVyYWxXaWR0aCAvIG5hdHVyYWxIZWlnaHQ7XG4gICAgdmFyIGNhbnZhc1dpZHRoID0gY29udGFpbmVyRGF0YS53aWR0aDtcbiAgICB2YXIgY2FudmFzSGVpZ2h0ID0gY29udGFpbmVyRGF0YS5oZWlnaHQ7XG4gICAgaWYgKGNvbnRhaW5lckRhdGEuaGVpZ2h0ICogYXNwZWN0UmF0aW8gPiBjb250YWluZXJEYXRhLndpZHRoKSB7XG4gICAgICBpZiAodmlld01vZGUgPT09IDMpIHtcbiAgICAgICAgY2FudmFzV2lkdGggPSBjb250YWluZXJEYXRhLmhlaWdodCAqIGFzcGVjdFJhdGlvO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FudmFzSGVpZ2h0ID0gY29udGFpbmVyRGF0YS53aWR0aCAvIGFzcGVjdFJhdGlvO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodmlld01vZGUgPT09IDMpIHtcbiAgICAgIGNhbnZhc0hlaWdodCA9IGNvbnRhaW5lckRhdGEud2lkdGggLyBhc3BlY3RSYXRpbztcbiAgICB9IGVsc2Uge1xuICAgICAgY2FudmFzV2lkdGggPSBjb250YWluZXJEYXRhLmhlaWdodCAqIGFzcGVjdFJhdGlvO1xuICAgIH1cbiAgICB2YXIgY2FudmFzRGF0YSA9IHtcbiAgICAgIGFzcGVjdFJhdGlvOiBhc3BlY3RSYXRpbyxcbiAgICAgIG5hdHVyYWxXaWR0aDogbmF0dXJhbFdpZHRoLFxuICAgICAgbmF0dXJhbEhlaWdodDogbmF0dXJhbEhlaWdodCxcbiAgICAgIHdpZHRoOiBjYW52YXNXaWR0aCxcbiAgICAgIGhlaWdodDogY2FudmFzSGVpZ2h0XG4gICAgfTtcbiAgICB0aGlzLmNhbnZhc0RhdGEgPSBjYW52YXNEYXRhO1xuICAgIHRoaXMubGltaXRlZCA9IHZpZXdNb2RlID09PSAxIHx8IHZpZXdNb2RlID09PSAyO1xuICAgIHRoaXMubGltaXRDYW52YXModHJ1ZSwgdHJ1ZSk7XG4gICAgY2FudmFzRGF0YS53aWR0aCA9IE1hdGgubWluKE1hdGgubWF4KGNhbnZhc0RhdGEud2lkdGgsIGNhbnZhc0RhdGEubWluV2lkdGgpLCBjYW52YXNEYXRhLm1heFdpZHRoKTtcbiAgICBjYW52YXNEYXRhLmhlaWdodCA9IE1hdGgubWluKE1hdGgubWF4KGNhbnZhc0RhdGEuaGVpZ2h0LCBjYW52YXNEYXRhLm1pbkhlaWdodCksIGNhbnZhc0RhdGEubWF4SGVpZ2h0KTtcbiAgICBjYW52YXNEYXRhLmxlZnQgPSAoY29udGFpbmVyRGF0YS53aWR0aCAtIGNhbnZhc0RhdGEud2lkdGgpIC8gMjtcbiAgICBjYW52YXNEYXRhLnRvcCA9IChjb250YWluZXJEYXRhLmhlaWdodCAtIGNhbnZhc0RhdGEuaGVpZ2h0KSAvIDI7XG4gICAgY2FudmFzRGF0YS5vbGRMZWZ0ID0gY2FudmFzRGF0YS5sZWZ0O1xuICAgIGNhbnZhc0RhdGEub2xkVG9wID0gY2FudmFzRGF0YS50b3A7XG4gICAgdGhpcy5pbml0aWFsQ2FudmFzRGF0YSA9IGFzc2lnbih7fSwgY2FudmFzRGF0YSk7XG4gIH0sXG4gIGxpbWl0Q2FudmFzOiBmdW5jdGlvbiBsaW1pdENhbnZhcyhzaXplTGltaXRlZCwgcG9zaXRpb25MaW1pdGVkKSB7XG4gICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG4gICAgICBjb250YWluZXJEYXRhID0gdGhpcy5jb250YWluZXJEYXRhLFxuICAgICAgY2FudmFzRGF0YSA9IHRoaXMuY2FudmFzRGF0YSxcbiAgICAgIGNyb3BCb3hEYXRhID0gdGhpcy5jcm9wQm94RGF0YTtcbiAgICB2YXIgdmlld01vZGUgPSBvcHRpb25zLnZpZXdNb2RlO1xuICAgIHZhciBhc3BlY3RSYXRpbyA9IGNhbnZhc0RhdGEuYXNwZWN0UmF0aW87XG4gICAgdmFyIGNyb3BwZWQgPSB0aGlzLmNyb3BwZWQgJiYgY3JvcEJveERhdGE7XG4gICAgaWYgKHNpemVMaW1pdGVkKSB7XG4gICAgICB2YXIgbWluQ2FudmFzV2lkdGggPSBOdW1iZXIob3B0aW9ucy5taW5DYW52YXNXaWR0aCkgfHwgMDtcbiAgICAgIHZhciBtaW5DYW52YXNIZWlnaHQgPSBOdW1iZXIob3B0aW9ucy5taW5DYW52YXNIZWlnaHQpIHx8IDA7XG4gICAgICBpZiAodmlld01vZGUgPiAxKSB7XG4gICAgICAgIG1pbkNhbnZhc1dpZHRoID0gTWF0aC5tYXgobWluQ2FudmFzV2lkdGgsIGNvbnRhaW5lckRhdGEud2lkdGgpO1xuICAgICAgICBtaW5DYW52YXNIZWlnaHQgPSBNYXRoLm1heChtaW5DYW52YXNIZWlnaHQsIGNvbnRhaW5lckRhdGEuaGVpZ2h0KTtcbiAgICAgICAgaWYgKHZpZXdNb2RlID09PSAzKSB7XG4gICAgICAgICAgaWYgKG1pbkNhbnZhc0hlaWdodCAqIGFzcGVjdFJhdGlvID4gbWluQ2FudmFzV2lkdGgpIHtcbiAgICAgICAgICAgIG1pbkNhbnZhc1dpZHRoID0gbWluQ2FudmFzSGVpZ2h0ICogYXNwZWN0UmF0aW87XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1pbkNhbnZhc0hlaWdodCA9IG1pbkNhbnZhc1dpZHRoIC8gYXNwZWN0UmF0aW87XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHZpZXdNb2RlID4gMCkge1xuICAgICAgICBpZiAobWluQ2FudmFzV2lkdGgpIHtcbiAgICAgICAgICBtaW5DYW52YXNXaWR0aCA9IE1hdGgubWF4KG1pbkNhbnZhc1dpZHRoLCBjcm9wcGVkID8gY3JvcEJveERhdGEud2lkdGggOiAwKTtcbiAgICAgICAgfSBlbHNlIGlmIChtaW5DYW52YXNIZWlnaHQpIHtcbiAgICAgICAgICBtaW5DYW52YXNIZWlnaHQgPSBNYXRoLm1heChtaW5DYW52YXNIZWlnaHQsIGNyb3BwZWQgPyBjcm9wQm94RGF0YS5oZWlnaHQgOiAwKTtcbiAgICAgICAgfSBlbHNlIGlmIChjcm9wcGVkKSB7XG4gICAgICAgICAgbWluQ2FudmFzV2lkdGggPSBjcm9wQm94RGF0YS53aWR0aDtcbiAgICAgICAgICBtaW5DYW52YXNIZWlnaHQgPSBjcm9wQm94RGF0YS5oZWlnaHQ7XG4gICAgICAgICAgaWYgKG1pbkNhbnZhc0hlaWdodCAqIGFzcGVjdFJhdGlvID4gbWluQ2FudmFzV2lkdGgpIHtcbiAgICAgICAgICAgIG1pbkNhbnZhc1dpZHRoID0gbWluQ2FudmFzSGVpZ2h0ICogYXNwZWN0UmF0aW87XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1pbkNhbnZhc0hlaWdodCA9IG1pbkNhbnZhc1dpZHRoIC8gYXNwZWN0UmF0aW87XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgX2dldEFkanVzdGVkU2l6ZXMgPSBnZXRBZGp1c3RlZFNpemVzKHtcbiAgICAgICAgYXNwZWN0UmF0aW86IGFzcGVjdFJhdGlvLFxuICAgICAgICB3aWR0aDogbWluQ2FudmFzV2lkdGgsXG4gICAgICAgIGhlaWdodDogbWluQ2FudmFzSGVpZ2h0XG4gICAgICB9KTtcbiAgICAgIG1pbkNhbnZhc1dpZHRoID0gX2dldEFkanVzdGVkU2l6ZXMud2lkdGg7XG4gICAgICBtaW5DYW52YXNIZWlnaHQgPSBfZ2V0QWRqdXN0ZWRTaXplcy5oZWlnaHQ7XG4gICAgICBjYW52YXNEYXRhLm1pbldpZHRoID0gbWluQ2FudmFzV2lkdGg7XG4gICAgICBjYW52YXNEYXRhLm1pbkhlaWdodCA9IG1pbkNhbnZhc0hlaWdodDtcbiAgICAgIGNhbnZhc0RhdGEubWF4V2lkdGggPSBJbmZpbml0eTtcbiAgICAgIGNhbnZhc0RhdGEubWF4SGVpZ2h0ID0gSW5maW5pdHk7XG4gICAgfVxuICAgIGlmIChwb3NpdGlvbkxpbWl0ZWQpIHtcbiAgICAgIGlmICh2aWV3TW9kZSA+IChjcm9wcGVkID8gMCA6IDEpKSB7XG4gICAgICAgIHZhciBuZXdDYW52YXNMZWZ0ID0gY29udGFpbmVyRGF0YS53aWR0aCAtIGNhbnZhc0RhdGEud2lkdGg7XG4gICAgICAgIHZhciBuZXdDYW52YXNUb3AgPSBjb250YWluZXJEYXRhLmhlaWdodCAtIGNhbnZhc0RhdGEuaGVpZ2h0O1xuICAgICAgICBjYW52YXNEYXRhLm1pbkxlZnQgPSBNYXRoLm1pbigwLCBuZXdDYW52YXNMZWZ0KTtcbiAgICAgICAgY2FudmFzRGF0YS5taW5Ub3AgPSBNYXRoLm1pbigwLCBuZXdDYW52YXNUb3ApO1xuICAgICAgICBjYW52YXNEYXRhLm1heExlZnQgPSBNYXRoLm1heCgwLCBuZXdDYW52YXNMZWZ0KTtcbiAgICAgICAgY2FudmFzRGF0YS5tYXhUb3AgPSBNYXRoLm1heCgwLCBuZXdDYW52YXNUb3ApO1xuICAgICAgICBpZiAoY3JvcHBlZCAmJiB0aGlzLmxpbWl0ZWQpIHtcbiAgICAgICAgICBjYW52YXNEYXRhLm1pbkxlZnQgPSBNYXRoLm1pbihjcm9wQm94RGF0YS5sZWZ0LCBjcm9wQm94RGF0YS5sZWZ0ICsgKGNyb3BCb3hEYXRhLndpZHRoIC0gY2FudmFzRGF0YS53aWR0aCkpO1xuICAgICAgICAgIGNhbnZhc0RhdGEubWluVG9wID0gTWF0aC5taW4oY3JvcEJveERhdGEudG9wLCBjcm9wQm94RGF0YS50b3AgKyAoY3JvcEJveERhdGEuaGVpZ2h0IC0gY2FudmFzRGF0YS5oZWlnaHQpKTtcbiAgICAgICAgICBjYW52YXNEYXRhLm1heExlZnQgPSBjcm9wQm94RGF0YS5sZWZ0O1xuICAgICAgICAgIGNhbnZhc0RhdGEubWF4VG9wID0gY3JvcEJveERhdGEudG9wO1xuICAgICAgICAgIGlmICh2aWV3TW9kZSA9PT0gMikge1xuICAgICAgICAgICAgaWYgKGNhbnZhc0RhdGEud2lkdGggPj0gY29udGFpbmVyRGF0YS53aWR0aCkge1xuICAgICAgICAgICAgICBjYW52YXNEYXRhLm1pbkxlZnQgPSBNYXRoLm1pbigwLCBuZXdDYW52YXNMZWZ0KTtcbiAgICAgICAgICAgICAgY2FudmFzRGF0YS5tYXhMZWZ0ID0gTWF0aC5tYXgoMCwgbmV3Q2FudmFzTGVmdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2FudmFzRGF0YS5oZWlnaHQgPj0gY29udGFpbmVyRGF0YS5oZWlnaHQpIHtcbiAgICAgICAgICAgICAgY2FudmFzRGF0YS5taW5Ub3AgPSBNYXRoLm1pbigwLCBuZXdDYW52YXNUb3ApO1xuICAgICAgICAgICAgICBjYW52YXNEYXRhLm1heFRvcCA9IE1hdGgubWF4KDAsIG5ld0NhbnZhc1RvcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYW52YXNEYXRhLm1pbkxlZnQgPSAtY2FudmFzRGF0YS53aWR0aDtcbiAgICAgICAgY2FudmFzRGF0YS5taW5Ub3AgPSAtY2FudmFzRGF0YS5oZWlnaHQ7XG4gICAgICAgIGNhbnZhc0RhdGEubWF4TGVmdCA9IGNvbnRhaW5lckRhdGEud2lkdGg7XG4gICAgICAgIGNhbnZhc0RhdGEubWF4VG9wID0gY29udGFpbmVyRGF0YS5oZWlnaHQ7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICByZW5kZXJDYW52YXM6IGZ1bmN0aW9uIHJlbmRlckNhbnZhcyhjaGFuZ2VkLCB0cmFuc2Zvcm1lZCkge1xuICAgIHZhciBjYW52YXNEYXRhID0gdGhpcy5jYW52YXNEYXRhLFxuICAgICAgaW1hZ2VEYXRhID0gdGhpcy5pbWFnZURhdGE7XG4gICAgaWYgKHRyYW5zZm9ybWVkKSB7XG4gICAgICB2YXIgX2dldFJvdGF0ZWRTaXplcyA9IGdldFJvdGF0ZWRTaXplcyh7XG4gICAgICAgICAgd2lkdGg6IGltYWdlRGF0YS5uYXR1cmFsV2lkdGggKiBNYXRoLmFicyhpbWFnZURhdGEuc2NhbGVYIHx8IDEpLFxuICAgICAgICAgIGhlaWdodDogaW1hZ2VEYXRhLm5hdHVyYWxIZWlnaHQgKiBNYXRoLmFicyhpbWFnZURhdGEuc2NhbGVZIHx8IDEpLFxuICAgICAgICAgIGRlZ3JlZTogaW1hZ2VEYXRhLnJvdGF0ZSB8fCAwXG4gICAgICAgIH0pLFxuICAgICAgICBuYXR1cmFsV2lkdGggPSBfZ2V0Um90YXRlZFNpemVzLndpZHRoLFxuICAgICAgICBuYXR1cmFsSGVpZ2h0ID0gX2dldFJvdGF0ZWRTaXplcy5oZWlnaHQ7XG4gICAgICB2YXIgd2lkdGggPSBjYW52YXNEYXRhLndpZHRoICogKG5hdHVyYWxXaWR0aCAvIGNhbnZhc0RhdGEubmF0dXJhbFdpZHRoKTtcbiAgICAgIHZhciBoZWlnaHQgPSBjYW52YXNEYXRhLmhlaWdodCAqIChuYXR1cmFsSGVpZ2h0IC8gY2FudmFzRGF0YS5uYXR1cmFsSGVpZ2h0KTtcbiAgICAgIGNhbnZhc0RhdGEubGVmdCAtPSAod2lkdGggLSBjYW52YXNEYXRhLndpZHRoKSAvIDI7XG4gICAgICBjYW52YXNEYXRhLnRvcCAtPSAoaGVpZ2h0IC0gY2FudmFzRGF0YS5oZWlnaHQpIC8gMjtcbiAgICAgIGNhbnZhc0RhdGEud2lkdGggPSB3aWR0aDtcbiAgICAgIGNhbnZhc0RhdGEuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgY2FudmFzRGF0YS5hc3BlY3RSYXRpbyA9IG5hdHVyYWxXaWR0aCAvIG5hdHVyYWxIZWlnaHQ7XG4gICAgICBjYW52YXNEYXRhLm5hdHVyYWxXaWR0aCA9IG5hdHVyYWxXaWR0aDtcbiAgICAgIGNhbnZhc0RhdGEubmF0dXJhbEhlaWdodCA9IG5hdHVyYWxIZWlnaHQ7XG4gICAgICB0aGlzLmxpbWl0Q2FudmFzKHRydWUsIGZhbHNlKTtcbiAgICB9XG4gICAgaWYgKGNhbnZhc0RhdGEud2lkdGggPiBjYW52YXNEYXRhLm1heFdpZHRoIHx8IGNhbnZhc0RhdGEud2lkdGggPCBjYW52YXNEYXRhLm1pbldpZHRoKSB7XG4gICAgICBjYW52YXNEYXRhLmxlZnQgPSBjYW52YXNEYXRhLm9sZExlZnQ7XG4gICAgfVxuICAgIGlmIChjYW52YXNEYXRhLmhlaWdodCA+IGNhbnZhc0RhdGEubWF4SGVpZ2h0IHx8IGNhbnZhc0RhdGEuaGVpZ2h0IDwgY2FudmFzRGF0YS5taW5IZWlnaHQpIHtcbiAgICAgIGNhbnZhc0RhdGEudG9wID0gY2FudmFzRGF0YS5vbGRUb3A7XG4gICAgfVxuICAgIGNhbnZhc0RhdGEud2lkdGggPSBNYXRoLm1pbihNYXRoLm1heChjYW52YXNEYXRhLndpZHRoLCBjYW52YXNEYXRhLm1pbldpZHRoKSwgY2FudmFzRGF0YS5tYXhXaWR0aCk7XG4gICAgY2FudmFzRGF0YS5oZWlnaHQgPSBNYXRoLm1pbihNYXRoLm1heChjYW52YXNEYXRhLmhlaWdodCwgY2FudmFzRGF0YS5taW5IZWlnaHQpLCBjYW52YXNEYXRhLm1heEhlaWdodCk7XG4gICAgdGhpcy5saW1pdENhbnZhcyhmYWxzZSwgdHJ1ZSk7XG4gICAgY2FudmFzRGF0YS5sZWZ0ID0gTWF0aC5taW4oTWF0aC5tYXgoY2FudmFzRGF0YS5sZWZ0LCBjYW52YXNEYXRhLm1pbkxlZnQpLCBjYW52YXNEYXRhLm1heExlZnQpO1xuICAgIGNhbnZhc0RhdGEudG9wID0gTWF0aC5taW4oTWF0aC5tYXgoY2FudmFzRGF0YS50b3AsIGNhbnZhc0RhdGEubWluVG9wKSwgY2FudmFzRGF0YS5tYXhUb3ApO1xuICAgIGNhbnZhc0RhdGEub2xkTGVmdCA9IGNhbnZhc0RhdGEubGVmdDtcbiAgICBjYW52YXNEYXRhLm9sZFRvcCA9IGNhbnZhc0RhdGEudG9wO1xuICAgIHNldFN0eWxlKHRoaXMuY2FudmFzLCBhc3NpZ24oe1xuICAgICAgd2lkdGg6IGNhbnZhc0RhdGEud2lkdGgsXG4gICAgICBoZWlnaHQ6IGNhbnZhc0RhdGEuaGVpZ2h0XG4gICAgfSwgZ2V0VHJhbnNmb3Jtcyh7XG4gICAgICB0cmFuc2xhdGVYOiBjYW52YXNEYXRhLmxlZnQsXG4gICAgICB0cmFuc2xhdGVZOiBjYW52YXNEYXRhLnRvcFxuICAgIH0pKSk7XG4gICAgdGhpcy5yZW5kZXJJbWFnZShjaGFuZ2VkKTtcbiAgICBpZiAodGhpcy5jcm9wcGVkICYmIHRoaXMubGltaXRlZCkge1xuICAgICAgdGhpcy5saW1pdENyb3BCb3godHJ1ZSwgdHJ1ZSk7XG4gICAgfVxuICB9LFxuICByZW5kZXJJbWFnZTogZnVuY3Rpb24gcmVuZGVySW1hZ2UoY2hhbmdlZCkge1xuICAgIHZhciBjYW52YXNEYXRhID0gdGhpcy5jYW52YXNEYXRhLFxuICAgICAgaW1hZ2VEYXRhID0gdGhpcy5pbWFnZURhdGE7XG4gICAgdmFyIHdpZHRoID0gaW1hZ2VEYXRhLm5hdHVyYWxXaWR0aCAqIChjYW52YXNEYXRhLndpZHRoIC8gY2FudmFzRGF0YS5uYXR1cmFsV2lkdGgpO1xuICAgIHZhciBoZWlnaHQgPSBpbWFnZURhdGEubmF0dXJhbEhlaWdodCAqIChjYW52YXNEYXRhLmhlaWdodCAvIGNhbnZhc0RhdGEubmF0dXJhbEhlaWdodCk7XG4gICAgYXNzaWduKGltYWdlRGF0YSwge1xuICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgICBsZWZ0OiAoY2FudmFzRGF0YS53aWR0aCAtIHdpZHRoKSAvIDIsXG4gICAgICB0b3A6IChjYW52YXNEYXRhLmhlaWdodCAtIGhlaWdodCkgLyAyXG4gICAgfSk7XG4gICAgc2V0U3R5bGUodGhpcy5pbWFnZSwgYXNzaWduKHtcbiAgICAgIHdpZHRoOiBpbWFnZURhdGEud2lkdGgsXG4gICAgICBoZWlnaHQ6IGltYWdlRGF0YS5oZWlnaHRcbiAgICB9LCBnZXRUcmFuc2Zvcm1zKGFzc2lnbih7XG4gICAgICB0cmFuc2xhdGVYOiBpbWFnZURhdGEubGVmdCxcbiAgICAgIHRyYW5zbGF0ZVk6IGltYWdlRGF0YS50b3BcbiAgICB9LCBpbWFnZURhdGEpKSkpO1xuICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICB0aGlzLm91dHB1dCgpO1xuICAgIH1cbiAgfSxcbiAgaW5pdENyb3BCb3g6IGZ1bmN0aW9uIGluaXRDcm9wQm94KCkge1xuICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuICAgICAgY2FudmFzRGF0YSA9IHRoaXMuY2FudmFzRGF0YTtcbiAgICB2YXIgYXNwZWN0UmF0aW8gPSBvcHRpb25zLmFzcGVjdFJhdGlvIHx8IG9wdGlvbnMuaW5pdGlhbEFzcGVjdFJhdGlvO1xuICAgIHZhciBhdXRvQ3JvcEFyZWEgPSBOdW1iZXIob3B0aW9ucy5hdXRvQ3JvcEFyZWEpIHx8IDAuODtcbiAgICB2YXIgY3JvcEJveERhdGEgPSB7XG4gICAgICB3aWR0aDogY2FudmFzRGF0YS53aWR0aCxcbiAgICAgIGhlaWdodDogY2FudmFzRGF0YS5oZWlnaHRcbiAgICB9O1xuICAgIGlmIChhc3BlY3RSYXRpbykge1xuICAgICAgaWYgKGNhbnZhc0RhdGEuaGVpZ2h0ICogYXNwZWN0UmF0aW8gPiBjYW52YXNEYXRhLndpZHRoKSB7XG4gICAgICAgIGNyb3BCb3hEYXRhLmhlaWdodCA9IGNyb3BCb3hEYXRhLndpZHRoIC8gYXNwZWN0UmF0aW87XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjcm9wQm94RGF0YS53aWR0aCA9IGNyb3BCb3hEYXRhLmhlaWdodCAqIGFzcGVjdFJhdGlvO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmNyb3BCb3hEYXRhID0gY3JvcEJveERhdGE7XG4gICAgdGhpcy5saW1pdENyb3BCb3godHJ1ZSwgdHJ1ZSk7XG5cbiAgICAvLyBJbml0aWFsaXplIGF1dG8gY3JvcCBhcmVhXG4gICAgY3JvcEJveERhdGEud2lkdGggPSBNYXRoLm1pbihNYXRoLm1heChjcm9wQm94RGF0YS53aWR0aCwgY3JvcEJveERhdGEubWluV2lkdGgpLCBjcm9wQm94RGF0YS5tYXhXaWR0aCk7XG4gICAgY3JvcEJveERhdGEuaGVpZ2h0ID0gTWF0aC5taW4oTWF0aC5tYXgoY3JvcEJveERhdGEuaGVpZ2h0LCBjcm9wQm94RGF0YS5taW5IZWlnaHQpLCBjcm9wQm94RGF0YS5tYXhIZWlnaHQpO1xuXG4gICAgLy8gVGhlIHdpZHRoL2hlaWdodCBvZiBhdXRvIGNyb3AgYXJlYSBtdXN0IGxhcmdlIHRoYW4gXCJtaW5XaWR0aC9IZWlnaHRcIlxuICAgIGNyb3BCb3hEYXRhLndpZHRoID0gTWF0aC5tYXgoY3JvcEJveERhdGEubWluV2lkdGgsIGNyb3BCb3hEYXRhLndpZHRoICogYXV0b0Nyb3BBcmVhKTtcbiAgICBjcm9wQm94RGF0YS5oZWlnaHQgPSBNYXRoLm1heChjcm9wQm94RGF0YS5taW5IZWlnaHQsIGNyb3BCb3hEYXRhLmhlaWdodCAqIGF1dG9Dcm9wQXJlYSk7XG4gICAgY3JvcEJveERhdGEubGVmdCA9IGNhbnZhc0RhdGEubGVmdCArIChjYW52YXNEYXRhLndpZHRoIC0gY3JvcEJveERhdGEud2lkdGgpIC8gMjtcbiAgICBjcm9wQm94RGF0YS50b3AgPSBjYW52YXNEYXRhLnRvcCArIChjYW52YXNEYXRhLmhlaWdodCAtIGNyb3BCb3hEYXRhLmhlaWdodCkgLyAyO1xuICAgIGNyb3BCb3hEYXRhLm9sZExlZnQgPSBjcm9wQm94RGF0YS5sZWZ0O1xuICAgIGNyb3BCb3hEYXRhLm9sZFRvcCA9IGNyb3BCb3hEYXRhLnRvcDtcbiAgICB0aGlzLmluaXRpYWxDcm9wQm94RGF0YSA9IGFzc2lnbih7fSwgY3JvcEJveERhdGEpO1xuICB9LFxuICBsaW1pdENyb3BCb3g6IGZ1bmN0aW9uIGxpbWl0Q3JvcEJveChzaXplTGltaXRlZCwgcG9zaXRpb25MaW1pdGVkKSB7XG4gICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG4gICAgICBjb250YWluZXJEYXRhID0gdGhpcy5jb250YWluZXJEYXRhLFxuICAgICAgY2FudmFzRGF0YSA9IHRoaXMuY2FudmFzRGF0YSxcbiAgICAgIGNyb3BCb3hEYXRhID0gdGhpcy5jcm9wQm94RGF0YSxcbiAgICAgIGxpbWl0ZWQgPSB0aGlzLmxpbWl0ZWQ7XG4gICAgdmFyIGFzcGVjdFJhdGlvID0gb3B0aW9ucy5hc3BlY3RSYXRpbztcbiAgICBpZiAoc2l6ZUxpbWl0ZWQpIHtcbiAgICAgIHZhciBtaW5Dcm9wQm94V2lkdGggPSBOdW1iZXIob3B0aW9ucy5taW5Dcm9wQm94V2lkdGgpIHx8IDA7XG4gICAgICB2YXIgbWluQ3JvcEJveEhlaWdodCA9IE51bWJlcihvcHRpb25zLm1pbkNyb3BCb3hIZWlnaHQpIHx8IDA7XG4gICAgICB2YXIgbWF4Q3JvcEJveFdpZHRoID0gbGltaXRlZCA/IE1hdGgubWluKGNvbnRhaW5lckRhdGEud2lkdGgsIGNhbnZhc0RhdGEud2lkdGgsIGNhbnZhc0RhdGEud2lkdGggKyBjYW52YXNEYXRhLmxlZnQsIGNvbnRhaW5lckRhdGEud2lkdGggLSBjYW52YXNEYXRhLmxlZnQpIDogY29udGFpbmVyRGF0YS53aWR0aDtcbiAgICAgIHZhciBtYXhDcm9wQm94SGVpZ2h0ID0gbGltaXRlZCA/IE1hdGgubWluKGNvbnRhaW5lckRhdGEuaGVpZ2h0LCBjYW52YXNEYXRhLmhlaWdodCwgY2FudmFzRGF0YS5oZWlnaHQgKyBjYW52YXNEYXRhLnRvcCwgY29udGFpbmVyRGF0YS5oZWlnaHQgLSBjYW52YXNEYXRhLnRvcCkgOiBjb250YWluZXJEYXRhLmhlaWdodDtcblxuICAgICAgLy8gVGhlIG1pbi9tYXhDcm9wQm94V2lkdGgvSGVpZ2h0IG11c3QgYmUgbGVzcyB0aGFuIGNvbnRhaW5lcidzIHdpZHRoL2hlaWdodFxuICAgICAgbWluQ3JvcEJveFdpZHRoID0gTWF0aC5taW4obWluQ3JvcEJveFdpZHRoLCBjb250YWluZXJEYXRhLndpZHRoKTtcbiAgICAgIG1pbkNyb3BCb3hIZWlnaHQgPSBNYXRoLm1pbihtaW5Dcm9wQm94SGVpZ2h0LCBjb250YWluZXJEYXRhLmhlaWdodCk7XG4gICAgICBpZiAoYXNwZWN0UmF0aW8pIHtcbiAgICAgICAgaWYgKG1pbkNyb3BCb3hXaWR0aCAmJiBtaW5Dcm9wQm94SGVpZ2h0KSB7XG4gICAgICAgICAgaWYgKG1pbkNyb3BCb3hIZWlnaHQgKiBhc3BlY3RSYXRpbyA+IG1pbkNyb3BCb3hXaWR0aCkge1xuICAgICAgICAgICAgbWluQ3JvcEJveEhlaWdodCA9IG1pbkNyb3BCb3hXaWR0aCAvIGFzcGVjdFJhdGlvO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtaW5Dcm9wQm94V2lkdGggPSBtaW5Dcm9wQm94SGVpZ2h0ICogYXNwZWN0UmF0aW87XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG1pbkNyb3BCb3hXaWR0aCkge1xuICAgICAgICAgIG1pbkNyb3BCb3hIZWlnaHQgPSBtaW5Dcm9wQm94V2lkdGggLyBhc3BlY3RSYXRpbztcbiAgICAgICAgfSBlbHNlIGlmIChtaW5Dcm9wQm94SGVpZ2h0KSB7XG4gICAgICAgICAgbWluQ3JvcEJveFdpZHRoID0gbWluQ3JvcEJveEhlaWdodCAqIGFzcGVjdFJhdGlvO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXhDcm9wQm94SGVpZ2h0ICogYXNwZWN0UmF0aW8gPiBtYXhDcm9wQm94V2lkdGgpIHtcbiAgICAgICAgICBtYXhDcm9wQm94SGVpZ2h0ID0gbWF4Q3JvcEJveFdpZHRoIC8gYXNwZWN0UmF0aW87XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWF4Q3JvcEJveFdpZHRoID0gbWF4Q3JvcEJveEhlaWdodCAqIGFzcGVjdFJhdGlvO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSBtaW5XaWR0aC9IZWlnaHQgbXVzdCBiZSBsZXNzIHRoYW4gbWF4V2lkdGgvSGVpZ2h0XG4gICAgICBjcm9wQm94RGF0YS5taW5XaWR0aCA9IE1hdGgubWluKG1pbkNyb3BCb3hXaWR0aCwgbWF4Q3JvcEJveFdpZHRoKTtcbiAgICAgIGNyb3BCb3hEYXRhLm1pbkhlaWdodCA9IE1hdGgubWluKG1pbkNyb3BCb3hIZWlnaHQsIG1heENyb3BCb3hIZWlnaHQpO1xuICAgICAgY3JvcEJveERhdGEubWF4V2lkdGggPSBtYXhDcm9wQm94V2lkdGg7XG4gICAgICBjcm9wQm94RGF0YS5tYXhIZWlnaHQgPSBtYXhDcm9wQm94SGVpZ2h0O1xuICAgIH1cbiAgICBpZiAocG9zaXRpb25MaW1pdGVkKSB7XG4gICAgICBpZiAobGltaXRlZCkge1xuICAgICAgICBjcm9wQm94RGF0YS5taW5MZWZ0ID0gTWF0aC5tYXgoMCwgY2FudmFzRGF0YS5sZWZ0KTtcbiAgICAgICAgY3JvcEJveERhdGEubWluVG9wID0gTWF0aC5tYXgoMCwgY2FudmFzRGF0YS50b3ApO1xuICAgICAgICBjcm9wQm94RGF0YS5tYXhMZWZ0ID0gTWF0aC5taW4oY29udGFpbmVyRGF0YS53aWR0aCwgY2FudmFzRGF0YS5sZWZ0ICsgY2FudmFzRGF0YS53aWR0aCkgLSBjcm9wQm94RGF0YS53aWR0aDtcbiAgICAgICAgY3JvcEJveERhdGEubWF4VG9wID0gTWF0aC5taW4oY29udGFpbmVyRGF0YS5oZWlnaHQsIGNhbnZhc0RhdGEudG9wICsgY2FudmFzRGF0YS5oZWlnaHQpIC0gY3JvcEJveERhdGEuaGVpZ2h0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3JvcEJveERhdGEubWluTGVmdCA9IDA7XG4gICAgICAgIGNyb3BCb3hEYXRhLm1pblRvcCA9IDA7XG4gICAgICAgIGNyb3BCb3hEYXRhLm1heExlZnQgPSBjb250YWluZXJEYXRhLndpZHRoIC0gY3JvcEJveERhdGEud2lkdGg7XG4gICAgICAgIGNyb3BCb3hEYXRhLm1heFRvcCA9IGNvbnRhaW5lckRhdGEuaGVpZ2h0IC0gY3JvcEJveERhdGEuaGVpZ2h0O1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgcmVuZGVyQ3JvcEJveDogZnVuY3Rpb24gcmVuZGVyQ3JvcEJveCgpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcbiAgICAgIGNvbnRhaW5lckRhdGEgPSB0aGlzLmNvbnRhaW5lckRhdGEsXG4gICAgICBjcm9wQm94RGF0YSA9IHRoaXMuY3JvcEJveERhdGE7XG4gICAgaWYgKGNyb3BCb3hEYXRhLndpZHRoID4gY3JvcEJveERhdGEubWF4V2lkdGggfHwgY3JvcEJveERhdGEud2lkdGggPCBjcm9wQm94RGF0YS5taW5XaWR0aCkge1xuICAgICAgY3JvcEJveERhdGEubGVmdCA9IGNyb3BCb3hEYXRhLm9sZExlZnQ7XG4gICAgfVxuICAgIGlmIChjcm9wQm94RGF0YS5oZWlnaHQgPiBjcm9wQm94RGF0YS5tYXhIZWlnaHQgfHwgY3JvcEJveERhdGEuaGVpZ2h0IDwgY3JvcEJveERhdGEubWluSGVpZ2h0KSB7XG4gICAgICBjcm9wQm94RGF0YS50b3AgPSBjcm9wQm94RGF0YS5vbGRUb3A7XG4gICAgfVxuICAgIGNyb3BCb3hEYXRhLndpZHRoID0gTWF0aC5taW4oTWF0aC5tYXgoY3JvcEJveERhdGEud2lkdGgsIGNyb3BCb3hEYXRhLm1pbldpZHRoKSwgY3JvcEJveERhdGEubWF4V2lkdGgpO1xuICAgIGNyb3BCb3hEYXRhLmhlaWdodCA9IE1hdGgubWluKE1hdGgubWF4KGNyb3BCb3hEYXRhLmhlaWdodCwgY3JvcEJveERhdGEubWluSGVpZ2h0KSwgY3JvcEJveERhdGEubWF4SGVpZ2h0KTtcbiAgICB0aGlzLmxpbWl0Q3JvcEJveChmYWxzZSwgdHJ1ZSk7XG4gICAgY3JvcEJveERhdGEubGVmdCA9IE1hdGgubWluKE1hdGgubWF4KGNyb3BCb3hEYXRhLmxlZnQsIGNyb3BCb3hEYXRhLm1pbkxlZnQpLCBjcm9wQm94RGF0YS5tYXhMZWZ0KTtcbiAgICBjcm9wQm94RGF0YS50b3AgPSBNYXRoLm1pbihNYXRoLm1heChjcm9wQm94RGF0YS50b3AsIGNyb3BCb3hEYXRhLm1pblRvcCksIGNyb3BCb3hEYXRhLm1heFRvcCk7XG4gICAgY3JvcEJveERhdGEub2xkTGVmdCA9IGNyb3BCb3hEYXRhLmxlZnQ7XG4gICAgY3JvcEJveERhdGEub2xkVG9wID0gY3JvcEJveERhdGEudG9wO1xuICAgIGlmIChvcHRpb25zLm1vdmFibGUgJiYgb3B0aW9ucy5jcm9wQm94TW92YWJsZSkge1xuICAgICAgLy8gVHVybiB0byBtb3ZlIHRoZSBjYW52YXMgd2hlbiB0aGUgY3JvcCBib3ggaXMgZXF1YWwgdG8gdGhlIGNvbnRhaW5lclxuICAgICAgc2V0RGF0YSh0aGlzLmZhY2UsIERBVEFfQUNUSU9OLCBjcm9wQm94RGF0YS53aWR0aCA+PSBjb250YWluZXJEYXRhLndpZHRoICYmIGNyb3BCb3hEYXRhLmhlaWdodCA+PSBjb250YWluZXJEYXRhLmhlaWdodCA/IEFDVElPTl9NT1ZFIDogQUNUSU9OX0FMTCk7XG4gICAgfVxuICAgIHNldFN0eWxlKHRoaXMuY3JvcEJveCwgYXNzaWduKHtcbiAgICAgIHdpZHRoOiBjcm9wQm94RGF0YS53aWR0aCxcbiAgICAgIGhlaWdodDogY3JvcEJveERhdGEuaGVpZ2h0XG4gICAgfSwgZ2V0VHJhbnNmb3Jtcyh7XG4gICAgICB0cmFuc2xhdGVYOiBjcm9wQm94RGF0YS5sZWZ0LFxuICAgICAgdHJhbnNsYXRlWTogY3JvcEJveERhdGEudG9wXG4gICAgfSkpKTtcbiAgICBpZiAodGhpcy5jcm9wcGVkICYmIHRoaXMubGltaXRlZCkge1xuICAgICAgdGhpcy5saW1pdENhbnZhcyh0cnVlLCB0cnVlKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmRpc2FibGVkKSB7XG4gICAgICB0aGlzLm91dHB1dCgpO1xuICAgIH1cbiAgfSxcbiAgb3V0cHV0OiBmdW5jdGlvbiBvdXRwdXQoKSB7XG4gICAgdGhpcy5wcmV2aWV3KCk7XG4gICAgZGlzcGF0Y2hFdmVudCh0aGlzLmVsZW1lbnQsIEVWRU5UX0NST1AsIHRoaXMuZ2V0RGF0YSgpKTtcbiAgfVxufTtcblxudmFyIHByZXZpZXcgPSB7XG4gIGluaXRQcmV2aWV3OiBmdW5jdGlvbiBpbml0UHJldmlldygpIHtcbiAgICB2YXIgZWxlbWVudCA9IHRoaXMuZWxlbWVudCxcbiAgICAgIGNyb3NzT3JpZ2luID0gdGhpcy5jcm9zc09yaWdpbjtcbiAgICB2YXIgcHJldmlldyA9IHRoaXMub3B0aW9ucy5wcmV2aWV3O1xuICAgIHZhciB1cmwgPSBjcm9zc09yaWdpbiA/IHRoaXMuY3Jvc3NPcmlnaW5VcmwgOiB0aGlzLnVybDtcbiAgICB2YXIgYWx0ID0gZWxlbWVudC5hbHQgfHwgJ1RoZSBpbWFnZSB0byBwcmV2aWV3JztcbiAgICB2YXIgaW1hZ2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKTtcbiAgICBpZiAoY3Jvc3NPcmlnaW4pIHtcbiAgICAgIGltYWdlLmNyb3NzT3JpZ2luID0gY3Jvc3NPcmlnaW47XG4gICAgfVxuICAgIGltYWdlLnNyYyA9IHVybDtcbiAgICBpbWFnZS5hbHQgPSBhbHQ7XG4gICAgdGhpcy52aWV3Qm94LmFwcGVuZENoaWxkKGltYWdlKTtcbiAgICB0aGlzLnZpZXdCb3hJbWFnZSA9IGltYWdlO1xuICAgIGlmICghcHJldmlldykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgcHJldmlld3MgPSBwcmV2aWV3O1xuICAgIGlmICh0eXBlb2YgcHJldmlldyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHByZXZpZXdzID0gZWxlbWVudC5vd25lckRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwocHJldmlldyk7XG4gICAgfSBlbHNlIGlmIChwcmV2aWV3LnF1ZXJ5U2VsZWN0b3IpIHtcbiAgICAgIHByZXZpZXdzID0gW3ByZXZpZXddO1xuICAgIH1cbiAgICB0aGlzLnByZXZpZXdzID0gcHJldmlld3M7XG4gICAgZm9yRWFjaChwcmV2aWV3cywgZnVuY3Rpb24gKGVsKSB7XG4gICAgICB2YXIgaW1nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJyk7XG5cbiAgICAgIC8vIFNhdmUgdGhlIG9yaWdpbmFsIHNpemUgZm9yIHJlY292ZXJcbiAgICAgIHNldERhdGEoZWwsIERBVEFfUFJFVklFVywge1xuICAgICAgICB3aWR0aDogZWwub2Zmc2V0V2lkdGgsXG4gICAgICAgIGhlaWdodDogZWwub2Zmc2V0SGVpZ2h0LFxuICAgICAgICBodG1sOiBlbC5pbm5lckhUTUxcbiAgICAgIH0pO1xuICAgICAgaWYgKGNyb3NzT3JpZ2luKSB7XG4gICAgICAgIGltZy5jcm9zc09yaWdpbiA9IGNyb3NzT3JpZ2luO1xuICAgICAgfVxuICAgICAgaW1nLnNyYyA9IHVybDtcbiAgICAgIGltZy5hbHQgPSBhbHQ7XG5cbiAgICAgIC8qKlxuICAgICAgICogT3ZlcnJpZGUgaW1nIGVsZW1lbnQgc3R5bGVzXG4gICAgICAgKiBBZGQgYGRpc3BsYXk6YmxvY2tgIHRvIGF2b2lkIG1hcmdpbiB0b3AgaXNzdWVcbiAgICAgICAqIEFkZCBgaGVpZ2h0OmF1dG9gIHRvIG92ZXJyaWRlIGBoZWlnaHRgIGF0dHJpYnV0ZSBvbiBJRThcbiAgICAgICAqIChPY2N1ciBvbmx5IHdoZW4gbWFyZ2luLXRvcCA8PSAtaGVpZ2h0KVxuICAgICAgICovXG4gICAgICBpbWcuc3R5bGUuY3NzVGV4dCA9ICdkaXNwbGF5OmJsb2NrOycgKyAnd2lkdGg6MTAwJTsnICsgJ2hlaWdodDphdXRvOycgKyAnbWluLXdpZHRoOjAhaW1wb3J0YW50OycgKyAnbWluLWhlaWdodDowIWltcG9ydGFudDsnICsgJ21heC13aWR0aDpub25lIWltcG9ydGFudDsnICsgJ21heC1oZWlnaHQ6bm9uZSFpbXBvcnRhbnQ7JyArICdpbWFnZS1vcmllbnRhdGlvbjowZGVnIWltcG9ydGFudDtcIic7XG4gICAgICBlbC5pbm5lckhUTUwgPSAnJztcbiAgICAgIGVsLmFwcGVuZENoaWxkKGltZyk7XG4gICAgfSk7XG4gIH0sXG4gIHJlc2V0UHJldmlldzogZnVuY3Rpb24gcmVzZXRQcmV2aWV3KCkge1xuICAgIGZvckVhY2godGhpcy5wcmV2aWV3cywgZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgIHZhciBkYXRhID0gZ2V0RGF0YShlbGVtZW50LCBEQVRBX1BSRVZJRVcpO1xuICAgICAgc2V0U3R5bGUoZWxlbWVudCwge1xuICAgICAgICB3aWR0aDogZGF0YS53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBkYXRhLmhlaWdodFxuICAgICAgfSk7XG4gICAgICBlbGVtZW50LmlubmVySFRNTCA9IGRhdGEuaHRtbDtcbiAgICAgIHJlbW92ZURhdGEoZWxlbWVudCwgREFUQV9QUkVWSUVXKTtcbiAgICB9KTtcbiAgfSxcbiAgcHJldmlldzogZnVuY3Rpb24gcHJldmlldygpIHtcbiAgICB2YXIgaW1hZ2VEYXRhID0gdGhpcy5pbWFnZURhdGEsXG4gICAgICBjYW52YXNEYXRhID0gdGhpcy5jYW52YXNEYXRhLFxuICAgICAgY3JvcEJveERhdGEgPSB0aGlzLmNyb3BCb3hEYXRhO1xuICAgIHZhciBjcm9wQm94V2lkdGggPSBjcm9wQm94RGF0YS53aWR0aCxcbiAgICAgIGNyb3BCb3hIZWlnaHQgPSBjcm9wQm94RGF0YS5oZWlnaHQ7XG4gICAgdmFyIHdpZHRoID0gaW1hZ2VEYXRhLndpZHRoLFxuICAgICAgaGVpZ2h0ID0gaW1hZ2VEYXRhLmhlaWdodDtcbiAgICB2YXIgbGVmdCA9IGNyb3BCb3hEYXRhLmxlZnQgLSBjYW52YXNEYXRhLmxlZnQgLSBpbWFnZURhdGEubGVmdDtcbiAgICB2YXIgdG9wID0gY3JvcEJveERhdGEudG9wIC0gY2FudmFzRGF0YS50b3AgLSBpbWFnZURhdGEudG9wO1xuICAgIGlmICghdGhpcy5jcm9wcGVkIHx8IHRoaXMuZGlzYWJsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc2V0U3R5bGUodGhpcy52aWV3Qm94SW1hZ2UsIGFzc2lnbih7XG4gICAgICB3aWR0aDogd2lkdGgsXG4gICAgICBoZWlnaHQ6IGhlaWdodFxuICAgIH0sIGdldFRyYW5zZm9ybXMoYXNzaWduKHtcbiAgICAgIHRyYW5zbGF0ZVg6IC1sZWZ0LFxuICAgICAgdHJhbnNsYXRlWTogLXRvcFxuICAgIH0sIGltYWdlRGF0YSkpKSk7XG4gICAgZm9yRWFjaCh0aGlzLnByZXZpZXdzLCBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgdmFyIGRhdGEgPSBnZXREYXRhKGVsZW1lbnQsIERBVEFfUFJFVklFVyk7XG4gICAgICB2YXIgb3JpZ2luYWxXaWR0aCA9IGRhdGEud2lkdGg7XG4gICAgICB2YXIgb3JpZ2luYWxIZWlnaHQgPSBkYXRhLmhlaWdodDtcbiAgICAgIHZhciBuZXdXaWR0aCA9IG9yaWdpbmFsV2lkdGg7XG4gICAgICB2YXIgbmV3SGVpZ2h0ID0gb3JpZ2luYWxIZWlnaHQ7XG4gICAgICB2YXIgcmF0aW8gPSAxO1xuICAgICAgaWYgKGNyb3BCb3hXaWR0aCkge1xuICAgICAgICByYXRpbyA9IG9yaWdpbmFsV2lkdGggLyBjcm9wQm94V2lkdGg7XG4gICAgICAgIG5ld0hlaWdodCA9IGNyb3BCb3hIZWlnaHQgKiByYXRpbztcbiAgICAgIH1cbiAgICAgIGlmIChjcm9wQm94SGVpZ2h0ICYmIG5ld0hlaWdodCA+IG9yaWdpbmFsSGVpZ2h0KSB7XG4gICAgICAgIHJhdGlvID0gb3JpZ2luYWxIZWlnaHQgLyBjcm9wQm94SGVpZ2h0O1xuICAgICAgICBuZXdXaWR0aCA9IGNyb3BCb3hXaWR0aCAqIHJhdGlvO1xuICAgICAgICBuZXdIZWlnaHQgPSBvcmlnaW5hbEhlaWdodDtcbiAgICAgIH1cbiAgICAgIHNldFN0eWxlKGVsZW1lbnQsIHtcbiAgICAgICAgd2lkdGg6IG5ld1dpZHRoLFxuICAgICAgICBoZWlnaHQ6IG5ld0hlaWdodFxuICAgICAgfSk7XG4gICAgICBzZXRTdHlsZShlbGVtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdpbWcnKVswXSwgYXNzaWduKHtcbiAgICAgICAgd2lkdGg6IHdpZHRoICogcmF0aW8sXG4gICAgICAgIGhlaWdodDogaGVpZ2h0ICogcmF0aW9cbiAgICAgIH0sIGdldFRyYW5zZm9ybXMoYXNzaWduKHtcbiAgICAgICAgdHJhbnNsYXRlWDogLWxlZnQgKiByYXRpbyxcbiAgICAgICAgdHJhbnNsYXRlWTogLXRvcCAqIHJhdGlvXG4gICAgICB9LCBpbWFnZURhdGEpKSkpO1xuICAgIH0pO1xuICB9XG59O1xuXG52YXIgZXZlbnRzID0ge1xuICBiaW5kOiBmdW5jdGlvbiBiaW5kKCkge1xuICAgIHZhciBlbGVtZW50ID0gdGhpcy5lbGVtZW50LFxuICAgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcbiAgICAgIGNyb3BwZXIgPSB0aGlzLmNyb3BwZXI7XG4gICAgaWYgKGlzRnVuY3Rpb24ob3B0aW9ucy5jcm9wc3RhcnQpKSB7XG4gICAgICBhZGRMaXN0ZW5lcihlbGVtZW50LCBFVkVOVF9DUk9QX1NUQVJULCBvcHRpb25zLmNyb3BzdGFydCk7XG4gICAgfVxuICAgIGlmIChpc0Z1bmN0aW9uKG9wdGlvbnMuY3JvcG1vdmUpKSB7XG4gICAgICBhZGRMaXN0ZW5lcihlbGVtZW50LCBFVkVOVF9DUk9QX01PVkUsIG9wdGlvbnMuY3JvcG1vdmUpO1xuICAgIH1cbiAgICBpZiAoaXNGdW5jdGlvbihvcHRpb25zLmNyb3BlbmQpKSB7XG4gICAgICBhZGRMaXN0ZW5lcihlbGVtZW50LCBFVkVOVF9DUk9QX0VORCwgb3B0aW9ucy5jcm9wZW5kKTtcbiAgICB9XG4gICAgaWYgKGlzRnVuY3Rpb24ob3B0aW9ucy5jcm9wKSkge1xuICAgICAgYWRkTGlzdGVuZXIoZWxlbWVudCwgRVZFTlRfQ1JPUCwgb3B0aW9ucy5jcm9wKTtcbiAgICB9XG4gICAgaWYgKGlzRnVuY3Rpb24ob3B0aW9ucy56b29tKSkge1xuICAgICAgYWRkTGlzdGVuZXIoZWxlbWVudCwgRVZFTlRfWk9PTSwgb3B0aW9ucy56b29tKTtcbiAgICB9XG4gICAgYWRkTGlzdGVuZXIoY3JvcHBlciwgRVZFTlRfUE9JTlRFUl9ET1dOLCB0aGlzLm9uQ3JvcFN0YXJ0ID0gdGhpcy5jcm9wU3RhcnQuYmluZCh0aGlzKSk7XG4gICAgaWYgKG9wdGlvbnMuem9vbWFibGUgJiYgb3B0aW9ucy56b29tT25XaGVlbCkge1xuICAgICAgYWRkTGlzdGVuZXIoY3JvcHBlciwgRVZFTlRfV0hFRUwsIHRoaXMub25XaGVlbCA9IHRoaXMud2hlZWwuYmluZCh0aGlzKSwge1xuICAgICAgICBwYXNzaXZlOiBmYWxzZSxcbiAgICAgICAgY2FwdHVyZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnRvZ2dsZURyYWdNb2RlT25EYmxjbGljaykge1xuICAgICAgYWRkTGlzdGVuZXIoY3JvcHBlciwgRVZFTlRfREJMQ0xJQ0ssIHRoaXMub25EYmxjbGljayA9IHRoaXMuZGJsY2xpY2suYmluZCh0aGlzKSk7XG4gICAgfVxuICAgIGFkZExpc3RlbmVyKGVsZW1lbnQub3duZXJEb2N1bWVudCwgRVZFTlRfUE9JTlRFUl9NT1ZFLCB0aGlzLm9uQ3JvcE1vdmUgPSB0aGlzLmNyb3BNb3ZlLmJpbmQodGhpcykpO1xuICAgIGFkZExpc3RlbmVyKGVsZW1lbnQub3duZXJEb2N1bWVudCwgRVZFTlRfUE9JTlRFUl9VUCwgdGhpcy5vbkNyb3BFbmQgPSB0aGlzLmNyb3BFbmQuYmluZCh0aGlzKSk7XG4gICAgaWYgKG9wdGlvbnMucmVzcG9uc2l2ZSkge1xuICAgICAgYWRkTGlzdGVuZXIod2luZG93LCBFVkVOVF9SRVNJWkUsIHRoaXMub25SZXNpemUgPSB0aGlzLnJlc2l6ZS5iaW5kKHRoaXMpKTtcbiAgICB9XG4gIH0sXG4gIHVuYmluZDogZnVuY3Rpb24gdW5iaW5kKCkge1xuICAgIHZhciBlbGVtZW50ID0gdGhpcy5lbGVtZW50LFxuICAgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcbiAgICAgIGNyb3BwZXIgPSB0aGlzLmNyb3BwZXI7XG4gICAgaWYgKGlzRnVuY3Rpb24ob3B0aW9ucy5jcm9wc3RhcnQpKSB7XG4gICAgICByZW1vdmVMaXN0ZW5lcihlbGVtZW50LCBFVkVOVF9DUk9QX1NUQVJULCBvcHRpb25zLmNyb3BzdGFydCk7XG4gICAgfVxuICAgIGlmIChpc0Z1bmN0aW9uKG9wdGlvbnMuY3JvcG1vdmUpKSB7XG4gICAgICByZW1vdmVMaXN0ZW5lcihlbGVtZW50LCBFVkVOVF9DUk9QX01PVkUsIG9wdGlvbnMuY3JvcG1vdmUpO1xuICAgIH1cbiAgICBpZiAoaXNGdW5jdGlvbihvcHRpb25zLmNyb3BlbmQpKSB7XG4gICAgICByZW1vdmVMaXN0ZW5lcihlbGVtZW50LCBFVkVOVF9DUk9QX0VORCwgb3B0aW9ucy5jcm9wZW5kKTtcbiAgICB9XG4gICAgaWYgKGlzRnVuY3Rpb24ob3B0aW9ucy5jcm9wKSkge1xuICAgICAgcmVtb3ZlTGlzdGVuZXIoZWxlbWVudCwgRVZFTlRfQ1JPUCwgb3B0aW9ucy5jcm9wKTtcbiAgICB9XG4gICAgaWYgKGlzRnVuY3Rpb24ob3B0aW9ucy56b29tKSkge1xuICAgICAgcmVtb3ZlTGlzdGVuZXIoZWxlbWVudCwgRVZFTlRfWk9PTSwgb3B0aW9ucy56b29tKTtcbiAgICB9XG4gICAgcmVtb3ZlTGlzdGVuZXIoY3JvcHBlciwgRVZFTlRfUE9JTlRFUl9ET1dOLCB0aGlzLm9uQ3JvcFN0YXJ0KTtcbiAgICBpZiAob3B0aW9ucy56b29tYWJsZSAmJiBvcHRpb25zLnpvb21PbldoZWVsKSB7XG4gICAgICByZW1vdmVMaXN0ZW5lcihjcm9wcGVyLCBFVkVOVF9XSEVFTCwgdGhpcy5vbldoZWVsLCB7XG4gICAgICAgIHBhc3NpdmU6IGZhbHNlLFxuICAgICAgICBjYXB0dXJlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMudG9nZ2xlRHJhZ01vZGVPbkRibGNsaWNrKSB7XG4gICAgICByZW1vdmVMaXN0ZW5lcihjcm9wcGVyLCBFVkVOVF9EQkxDTElDSywgdGhpcy5vbkRibGNsaWNrKTtcbiAgICB9XG4gICAgcmVtb3ZlTGlzdGVuZXIoZWxlbWVudC5vd25lckRvY3VtZW50LCBFVkVOVF9QT0lOVEVSX01PVkUsIHRoaXMub25Dcm9wTW92ZSk7XG4gICAgcmVtb3ZlTGlzdGVuZXIoZWxlbWVudC5vd25lckRvY3VtZW50LCBFVkVOVF9QT0lOVEVSX1VQLCB0aGlzLm9uQ3JvcEVuZCk7XG4gICAgaWYgKG9wdGlvbnMucmVzcG9uc2l2ZSkge1xuICAgICAgcmVtb3ZlTGlzdGVuZXIod2luZG93LCBFVkVOVF9SRVNJWkUsIHRoaXMub25SZXNpemUpO1xuICAgIH1cbiAgfVxufTtcblxudmFyIGhhbmRsZXJzID0ge1xuICByZXNpemU6IGZ1bmN0aW9uIHJlc2l6ZSgpIHtcbiAgICBpZiAodGhpcy5kaXNhYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcbiAgICAgIGNvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyLFxuICAgICAgY29udGFpbmVyRGF0YSA9IHRoaXMuY29udGFpbmVyRGF0YTtcbiAgICB2YXIgcmF0aW9YID0gY29udGFpbmVyLm9mZnNldFdpZHRoIC8gY29udGFpbmVyRGF0YS53aWR0aDtcbiAgICB2YXIgcmF0aW9ZID0gY29udGFpbmVyLm9mZnNldEhlaWdodCAvIGNvbnRhaW5lckRhdGEuaGVpZ2h0O1xuICAgIHZhciByYXRpbyA9IE1hdGguYWJzKHJhdGlvWCAtIDEpID4gTWF0aC5hYnMocmF0aW9ZIC0gMSkgPyByYXRpb1ggOiByYXRpb1k7XG5cbiAgICAvLyBSZXNpemUgd2hlbiB3aWR0aCBjaGFuZ2VkIG9yIGhlaWdodCBjaGFuZ2VkXG4gICAgaWYgKHJhdGlvICE9PSAxKSB7XG4gICAgICB2YXIgY2FudmFzRGF0YTtcbiAgICAgIHZhciBjcm9wQm94RGF0YTtcbiAgICAgIGlmIChvcHRpb25zLnJlc3RvcmUpIHtcbiAgICAgICAgY2FudmFzRGF0YSA9IHRoaXMuZ2V0Q2FudmFzRGF0YSgpO1xuICAgICAgICBjcm9wQm94RGF0YSA9IHRoaXMuZ2V0Q3JvcEJveERhdGEoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgICBpZiAob3B0aW9ucy5yZXN0b3JlKSB7XG4gICAgICAgIHRoaXMuc2V0Q2FudmFzRGF0YShmb3JFYWNoKGNhbnZhc0RhdGEsIGZ1bmN0aW9uIChuLCBpKSB7XG4gICAgICAgICAgY2FudmFzRGF0YVtpXSA9IG4gKiByYXRpbztcbiAgICAgICAgfSkpO1xuICAgICAgICB0aGlzLnNldENyb3BCb3hEYXRhKGZvckVhY2goY3JvcEJveERhdGEsIGZ1bmN0aW9uIChuLCBpKSB7XG4gICAgICAgICAgY3JvcEJveERhdGFbaV0gPSBuICogcmF0aW87XG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGRibGNsaWNrOiBmdW5jdGlvbiBkYmxjbGljaygpIHtcbiAgICBpZiAodGhpcy5kaXNhYmxlZCB8fCB0aGlzLm9wdGlvbnMuZHJhZ01vZGUgPT09IERSQUdfTU9ERV9OT05FKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuc2V0RHJhZ01vZGUoaGFzQ2xhc3ModGhpcy5kcmFnQm94LCBDTEFTU19DUk9QKSA/IERSQUdfTU9ERV9NT1ZFIDogRFJBR19NT0RFX0NST1ApO1xuICB9LFxuICB3aGVlbDogZnVuY3Rpb24gd2hlZWwoZXZlbnQpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHZhciByYXRpbyA9IE51bWJlcih0aGlzLm9wdGlvbnMud2hlZWxab29tUmF0aW8pIHx8IDAuMTtcbiAgICB2YXIgZGVsdGEgPSAxO1xuICAgIGlmICh0aGlzLmRpc2FibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAvLyBMaW1pdCB3aGVlbCBzcGVlZCB0byBwcmV2ZW50IHpvb20gdG9vIGZhc3QgKCMyMSlcbiAgICBpZiAodGhpcy53aGVlbGluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLndoZWVsaW5nID0gdHJ1ZTtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzLndoZWVsaW5nID0gZmFsc2U7XG4gICAgfSwgNTApO1xuICAgIGlmIChldmVudC5kZWx0YVkpIHtcbiAgICAgIGRlbHRhID0gZXZlbnQuZGVsdGFZID4gMCA/IDEgOiAtMTtcbiAgICB9IGVsc2UgaWYgKGV2ZW50LndoZWVsRGVsdGEpIHtcbiAgICAgIGRlbHRhID0gLWV2ZW50LndoZWVsRGVsdGEgLyAxMjA7XG4gICAgfSBlbHNlIGlmIChldmVudC5kZXRhaWwpIHtcbiAgICAgIGRlbHRhID0gZXZlbnQuZGV0YWlsID4gMCA/IDEgOiAtMTtcbiAgICB9XG4gICAgdGhpcy56b29tKC1kZWx0YSAqIHJhdGlvLCBldmVudCk7XG4gIH0sXG4gIGNyb3BTdGFydDogZnVuY3Rpb24gY3JvcFN0YXJ0KGV2ZW50KSB7XG4gICAgdmFyIGJ1dHRvbnMgPSBldmVudC5idXR0b25zLFxuICAgICAgYnV0dG9uID0gZXZlbnQuYnV0dG9uO1xuICAgIGlmICh0aGlzLmRpc2FibGVkXG5cbiAgICAvLyBIYW5kbGUgbW91c2UgZXZlbnQgYW5kIHBvaW50ZXIgZXZlbnQgYW5kIGlnbm9yZSB0b3VjaCBldmVudFxuICAgIHx8IChldmVudC50eXBlID09PSAnbW91c2Vkb3duJyB8fCBldmVudC50eXBlID09PSAncG9pbnRlcmRvd24nICYmIGV2ZW50LnBvaW50ZXJUeXBlID09PSAnbW91c2UnKSAmJiAoXG4gICAgLy8gTm8gcHJpbWFyeSBidXR0b24gKFVzdWFsbHkgdGhlIGxlZnQgYnV0dG9uKVxuICAgIGlzTnVtYmVyKGJ1dHRvbnMpICYmIGJ1dHRvbnMgIT09IDEgfHwgaXNOdW1iZXIoYnV0dG9uKSAmJiBidXR0b24gIT09IDBcblxuICAgIC8vIE9wZW4gY29udGV4dCBtZW51XG4gICAgfHwgZXZlbnQuY3RybEtleSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG4gICAgICBwb2ludGVycyA9IHRoaXMucG9pbnRlcnM7XG4gICAgdmFyIGFjdGlvbjtcbiAgICBpZiAoZXZlbnQuY2hhbmdlZFRvdWNoZXMpIHtcbiAgICAgIC8vIEhhbmRsZSB0b3VjaCBldmVudFxuICAgICAgZm9yRWFjaChldmVudC5jaGFuZ2VkVG91Y2hlcywgZnVuY3Rpb24gKHRvdWNoKSB7XG4gICAgICAgIHBvaW50ZXJzW3RvdWNoLmlkZW50aWZpZXJdID0gZ2V0UG9pbnRlcih0b3VjaCk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSGFuZGxlIG1vdXNlIGV2ZW50IGFuZCBwb2ludGVyIGV2ZW50XG4gICAgICBwb2ludGVyc1tldmVudC5wb2ludGVySWQgfHwgMF0gPSBnZXRQb2ludGVyKGV2ZW50KTtcbiAgICB9XG4gICAgaWYgKE9iamVjdC5rZXlzKHBvaW50ZXJzKS5sZW5ndGggPiAxICYmIG9wdGlvbnMuem9vbWFibGUgJiYgb3B0aW9ucy56b29tT25Ub3VjaCkge1xuICAgICAgYWN0aW9uID0gQUNUSU9OX1pPT007XG4gICAgfSBlbHNlIHtcbiAgICAgIGFjdGlvbiA9IGdldERhdGEoZXZlbnQudGFyZ2V0LCBEQVRBX0FDVElPTik7XG4gICAgfVxuICAgIGlmICghUkVHRVhQX0FDVElPTlMudGVzdChhY3Rpb24pKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChkaXNwYXRjaEV2ZW50KHRoaXMuZWxlbWVudCwgRVZFTlRfQ1JPUF9TVEFSVCwge1xuICAgICAgb3JpZ2luYWxFdmVudDogZXZlbnQsXG4gICAgICBhY3Rpb246IGFjdGlvblxuICAgIH0pID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFRoaXMgbGluZSBpcyByZXF1aXJlZCBmb3IgcHJldmVudGluZyBwYWdlIHpvb21pbmcgaW4gaU9TIGJyb3dzZXJzXG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB0aGlzLmFjdGlvbiA9IGFjdGlvbjtcbiAgICB0aGlzLmNyb3BwaW5nID0gZmFsc2U7XG4gICAgaWYgKGFjdGlvbiA9PT0gQUNUSU9OX0NST1ApIHtcbiAgICAgIHRoaXMuY3JvcHBpbmcgPSB0cnVlO1xuICAgICAgYWRkQ2xhc3ModGhpcy5kcmFnQm94LCBDTEFTU19NT0RBTCk7XG4gICAgfVxuICB9LFxuICBjcm9wTW92ZTogZnVuY3Rpb24gY3JvcE1vdmUoZXZlbnQpIHtcbiAgICB2YXIgYWN0aW9uID0gdGhpcy5hY3Rpb247XG4gICAgaWYgKHRoaXMuZGlzYWJsZWQgfHwgIWFjdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgcG9pbnRlcnMgPSB0aGlzLnBvaW50ZXJzO1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgaWYgKGRpc3BhdGNoRXZlbnQodGhpcy5lbGVtZW50LCBFVkVOVF9DUk9QX01PVkUsIHtcbiAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2ZW50LFxuICAgICAgYWN0aW9uOiBhY3Rpb25cbiAgICB9KSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGV2ZW50LmNoYW5nZWRUb3VjaGVzKSB7XG4gICAgICBmb3JFYWNoKGV2ZW50LmNoYW5nZWRUb3VjaGVzLCBmdW5jdGlvbiAodG91Y2gpIHtcbiAgICAgICAgLy8gVGhlIGZpcnN0IHBhcmFtZXRlciBzaG91bGQgbm90IGJlIHVuZGVmaW5lZCAoIzQzMilcbiAgICAgICAgYXNzaWduKHBvaW50ZXJzW3RvdWNoLmlkZW50aWZpZXJdIHx8IHt9LCBnZXRQb2ludGVyKHRvdWNoLCB0cnVlKSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXNzaWduKHBvaW50ZXJzW2V2ZW50LnBvaW50ZXJJZCB8fCAwXSB8fCB7fSwgZ2V0UG9pbnRlcihldmVudCwgdHJ1ZSkpO1xuICAgIH1cbiAgICB0aGlzLmNoYW5nZShldmVudCk7XG4gIH0sXG4gIGNyb3BFbmQ6IGZ1bmN0aW9uIGNyb3BFbmQoZXZlbnQpIHtcbiAgICBpZiAodGhpcy5kaXNhYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgYWN0aW9uID0gdGhpcy5hY3Rpb24sXG4gICAgICBwb2ludGVycyA9IHRoaXMucG9pbnRlcnM7XG4gICAgaWYgKGV2ZW50LmNoYW5nZWRUb3VjaGVzKSB7XG4gICAgICBmb3JFYWNoKGV2ZW50LmNoYW5nZWRUb3VjaGVzLCBmdW5jdGlvbiAodG91Y2gpIHtcbiAgICAgICAgZGVsZXRlIHBvaW50ZXJzW3RvdWNoLmlkZW50aWZpZXJdO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSBwb2ludGVyc1tldmVudC5wb2ludGVySWQgfHwgMF07XG4gICAgfVxuICAgIGlmICghYWN0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgaWYgKCFPYmplY3Qua2V5cyhwb2ludGVycykubGVuZ3RoKSB7XG4gICAgICB0aGlzLmFjdGlvbiA9ICcnO1xuICAgIH1cbiAgICBpZiAodGhpcy5jcm9wcGluZykge1xuICAgICAgdGhpcy5jcm9wcGluZyA9IGZhbHNlO1xuICAgICAgdG9nZ2xlQ2xhc3ModGhpcy5kcmFnQm94LCBDTEFTU19NT0RBTCwgdGhpcy5jcm9wcGVkICYmIHRoaXMub3B0aW9ucy5tb2RhbCk7XG4gICAgfVxuICAgIGRpc3BhdGNoRXZlbnQodGhpcy5lbGVtZW50LCBFVkVOVF9DUk9QX0VORCwge1xuICAgICAgb3JpZ2luYWxFdmVudDogZXZlbnQsXG4gICAgICBhY3Rpb246IGFjdGlvblxuICAgIH0pO1xuICB9XG59O1xuXG52YXIgY2hhbmdlID0ge1xuICBjaGFuZ2U6IGZ1bmN0aW9uIGNoYW5nZShldmVudCkge1xuICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuICAgICAgY2FudmFzRGF0YSA9IHRoaXMuY2FudmFzRGF0YSxcbiAgICAgIGNvbnRhaW5lckRhdGEgPSB0aGlzLmNvbnRhaW5lckRhdGEsXG4gICAgICBjcm9wQm94RGF0YSA9IHRoaXMuY3JvcEJveERhdGEsXG4gICAgICBwb2ludGVycyA9IHRoaXMucG9pbnRlcnM7XG4gICAgdmFyIGFjdGlvbiA9IHRoaXMuYWN0aW9uO1xuICAgIHZhciBhc3BlY3RSYXRpbyA9IG9wdGlvbnMuYXNwZWN0UmF0aW87XG4gICAgdmFyIGxlZnQgPSBjcm9wQm94RGF0YS5sZWZ0LFxuICAgICAgdG9wID0gY3JvcEJveERhdGEudG9wLFxuICAgICAgd2lkdGggPSBjcm9wQm94RGF0YS53aWR0aCxcbiAgICAgIGhlaWdodCA9IGNyb3BCb3hEYXRhLmhlaWdodDtcbiAgICB2YXIgcmlnaHQgPSBsZWZ0ICsgd2lkdGg7XG4gICAgdmFyIGJvdHRvbSA9IHRvcCArIGhlaWdodDtcbiAgICB2YXIgbWluTGVmdCA9IDA7XG4gICAgdmFyIG1pblRvcCA9IDA7XG4gICAgdmFyIG1heFdpZHRoID0gY29udGFpbmVyRGF0YS53aWR0aDtcbiAgICB2YXIgbWF4SGVpZ2h0ID0gY29udGFpbmVyRGF0YS5oZWlnaHQ7XG4gICAgdmFyIHJlbmRlcmFibGUgPSB0cnVlO1xuICAgIHZhciBvZmZzZXQ7XG5cbiAgICAvLyBMb2NraW5nIGFzcGVjdCByYXRpbyBpbiBcImZyZWUgbW9kZVwiIGJ5IGhvbGRpbmcgc2hpZnQga2V5XG4gICAgaWYgKCFhc3BlY3RSYXRpbyAmJiBldmVudC5zaGlmdEtleSkge1xuICAgICAgYXNwZWN0UmF0aW8gPSB3aWR0aCAmJiBoZWlnaHQgPyB3aWR0aCAvIGhlaWdodCA6IDE7XG4gICAgfVxuICAgIGlmICh0aGlzLmxpbWl0ZWQpIHtcbiAgICAgIG1pbkxlZnQgPSBjcm9wQm94RGF0YS5taW5MZWZ0O1xuICAgICAgbWluVG9wID0gY3JvcEJveERhdGEubWluVG9wO1xuICAgICAgbWF4V2lkdGggPSBtaW5MZWZ0ICsgTWF0aC5taW4oY29udGFpbmVyRGF0YS53aWR0aCwgY2FudmFzRGF0YS53aWR0aCwgY2FudmFzRGF0YS5sZWZ0ICsgY2FudmFzRGF0YS53aWR0aCk7XG4gICAgICBtYXhIZWlnaHQgPSBtaW5Ub3AgKyBNYXRoLm1pbihjb250YWluZXJEYXRhLmhlaWdodCwgY2FudmFzRGF0YS5oZWlnaHQsIGNhbnZhc0RhdGEudG9wICsgY2FudmFzRGF0YS5oZWlnaHQpO1xuICAgIH1cbiAgICB2YXIgcG9pbnRlciA9IHBvaW50ZXJzW09iamVjdC5rZXlzKHBvaW50ZXJzKVswXV07XG4gICAgdmFyIHJhbmdlID0ge1xuICAgICAgeDogcG9pbnRlci5lbmRYIC0gcG9pbnRlci5zdGFydFgsXG4gICAgICB5OiBwb2ludGVyLmVuZFkgLSBwb2ludGVyLnN0YXJ0WVxuICAgIH07XG4gICAgdmFyIGNoZWNrID0gZnVuY3Rpb24gY2hlY2soc2lkZSkge1xuICAgICAgc3dpdGNoIChzaWRlKSB7XG4gICAgICAgIGNhc2UgQUNUSU9OX0VBU1Q6XG4gICAgICAgICAgaWYgKHJpZ2h0ICsgcmFuZ2UueCA+IG1heFdpZHRoKSB7XG4gICAgICAgICAgICByYW5nZS54ID0gbWF4V2lkdGggLSByaWdodDtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgQUNUSU9OX1dFU1Q6XG4gICAgICAgICAgaWYgKGxlZnQgKyByYW5nZS54IDwgbWluTGVmdCkge1xuICAgICAgICAgICAgcmFuZ2UueCA9IG1pbkxlZnQgLSBsZWZ0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBBQ1RJT05fTk9SVEg6XG4gICAgICAgICAgaWYgKHRvcCArIHJhbmdlLnkgPCBtaW5Ub3ApIHtcbiAgICAgICAgICAgIHJhbmdlLnkgPSBtaW5Ub3AgLSB0b3A7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEFDVElPTl9TT1VUSDpcbiAgICAgICAgICBpZiAoYm90dG9tICsgcmFuZ2UueSA+IG1heEhlaWdodCkge1xuICAgICAgICAgICAgcmFuZ2UueSA9IG1heEhlaWdodCAtIGJvdHRvbTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfTtcbiAgICBzd2l0Y2ggKGFjdGlvbikge1xuICAgICAgLy8gTW92ZSBjcm9wIGJveFxuICAgICAgY2FzZSBBQ1RJT05fQUxMOlxuICAgICAgICBsZWZ0ICs9IHJhbmdlLng7XG4gICAgICAgIHRvcCArPSByYW5nZS55O1xuICAgICAgICBicmVhaztcblxuICAgICAgLy8gUmVzaXplIGNyb3AgYm94XG4gICAgICBjYXNlIEFDVElPTl9FQVNUOlxuICAgICAgICBpZiAocmFuZ2UueCA+PSAwICYmIChyaWdodCA+PSBtYXhXaWR0aCB8fCBhc3BlY3RSYXRpbyAmJiAodG9wIDw9IG1pblRvcCB8fCBib3R0b20gPj0gbWF4SGVpZ2h0KSkpIHtcbiAgICAgICAgICByZW5kZXJhYmxlID0gZmFsc2U7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2hlY2soQUNUSU9OX0VBU1QpO1xuICAgICAgICB3aWR0aCArPSByYW5nZS54O1xuICAgICAgICBpZiAod2lkdGggPCAwKSB7XG4gICAgICAgICAgYWN0aW9uID0gQUNUSU9OX1dFU1Q7XG4gICAgICAgICAgd2lkdGggPSAtd2lkdGg7XG4gICAgICAgICAgbGVmdCAtPSB3aWR0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXNwZWN0UmF0aW8pIHtcbiAgICAgICAgICBoZWlnaHQgPSB3aWR0aCAvIGFzcGVjdFJhdGlvO1xuICAgICAgICAgIHRvcCArPSAoY3JvcEJveERhdGEuaGVpZ2h0IC0gaGVpZ2h0KSAvIDI7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEFDVElPTl9OT1JUSDpcbiAgICAgICAgaWYgKHJhbmdlLnkgPD0gMCAmJiAodG9wIDw9IG1pblRvcCB8fCBhc3BlY3RSYXRpbyAmJiAobGVmdCA8PSBtaW5MZWZ0IHx8IHJpZ2h0ID49IG1heFdpZHRoKSkpIHtcbiAgICAgICAgICByZW5kZXJhYmxlID0gZmFsc2U7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2hlY2soQUNUSU9OX05PUlRIKTtcbiAgICAgICAgaGVpZ2h0IC09IHJhbmdlLnk7XG4gICAgICAgIHRvcCArPSByYW5nZS55O1xuICAgICAgICBpZiAoaGVpZ2h0IDwgMCkge1xuICAgICAgICAgIGFjdGlvbiA9IEFDVElPTl9TT1VUSDtcbiAgICAgICAgICBoZWlnaHQgPSAtaGVpZ2h0O1xuICAgICAgICAgIHRvcCAtPSBoZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFzcGVjdFJhdGlvKSB7XG4gICAgICAgICAgd2lkdGggPSBoZWlnaHQgKiBhc3BlY3RSYXRpbztcbiAgICAgICAgICBsZWZ0ICs9IChjcm9wQm94RGF0YS53aWR0aCAtIHdpZHRoKSAvIDI7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEFDVElPTl9XRVNUOlxuICAgICAgICBpZiAocmFuZ2UueCA8PSAwICYmIChsZWZ0IDw9IG1pbkxlZnQgfHwgYXNwZWN0UmF0aW8gJiYgKHRvcCA8PSBtaW5Ub3AgfHwgYm90dG9tID49IG1heEhlaWdodCkpKSB7XG4gICAgICAgICAgcmVuZGVyYWJsZSA9IGZhbHNlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNoZWNrKEFDVElPTl9XRVNUKTtcbiAgICAgICAgd2lkdGggLT0gcmFuZ2UueDtcbiAgICAgICAgbGVmdCArPSByYW5nZS54O1xuICAgICAgICBpZiAod2lkdGggPCAwKSB7XG4gICAgICAgICAgYWN0aW9uID0gQUNUSU9OX0VBU1Q7XG4gICAgICAgICAgd2lkdGggPSAtd2lkdGg7XG4gICAgICAgICAgbGVmdCAtPSB3aWR0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXNwZWN0UmF0aW8pIHtcbiAgICAgICAgICBoZWlnaHQgPSB3aWR0aCAvIGFzcGVjdFJhdGlvO1xuICAgICAgICAgIHRvcCArPSAoY3JvcEJveERhdGEuaGVpZ2h0IC0gaGVpZ2h0KSAvIDI7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEFDVElPTl9TT1VUSDpcbiAgICAgICAgaWYgKHJhbmdlLnkgPj0gMCAmJiAoYm90dG9tID49IG1heEhlaWdodCB8fCBhc3BlY3RSYXRpbyAmJiAobGVmdCA8PSBtaW5MZWZ0IHx8IHJpZ2h0ID49IG1heFdpZHRoKSkpIHtcbiAgICAgICAgICByZW5kZXJhYmxlID0gZmFsc2U7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2hlY2soQUNUSU9OX1NPVVRIKTtcbiAgICAgICAgaGVpZ2h0ICs9IHJhbmdlLnk7XG4gICAgICAgIGlmIChoZWlnaHQgPCAwKSB7XG4gICAgICAgICAgYWN0aW9uID0gQUNUSU9OX05PUlRIO1xuICAgICAgICAgIGhlaWdodCA9IC1oZWlnaHQ7XG4gICAgICAgICAgdG9wIC09IGhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXNwZWN0UmF0aW8pIHtcbiAgICAgICAgICB3aWR0aCA9IGhlaWdodCAqIGFzcGVjdFJhdGlvO1xuICAgICAgICAgIGxlZnQgKz0gKGNyb3BCb3hEYXRhLndpZHRoIC0gd2lkdGgpIC8gMjtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQUNUSU9OX05PUlRIX0VBU1Q6XG4gICAgICAgIGlmIChhc3BlY3RSYXRpbykge1xuICAgICAgICAgIGlmIChyYW5nZS55IDw9IDAgJiYgKHRvcCA8PSBtaW5Ub3AgfHwgcmlnaHQgPj0gbWF4V2lkdGgpKSB7XG4gICAgICAgICAgICByZW5kZXJhYmxlID0gZmFsc2U7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2hlY2soQUNUSU9OX05PUlRIKTtcbiAgICAgICAgICBoZWlnaHQgLT0gcmFuZ2UueTtcbiAgICAgICAgICB0b3AgKz0gcmFuZ2UueTtcbiAgICAgICAgICB3aWR0aCA9IGhlaWdodCAqIGFzcGVjdFJhdGlvO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNoZWNrKEFDVElPTl9OT1JUSCk7XG4gICAgICAgICAgY2hlY2soQUNUSU9OX0VBU1QpO1xuICAgICAgICAgIGlmIChyYW5nZS54ID49IDApIHtcbiAgICAgICAgICAgIGlmIChyaWdodCA8IG1heFdpZHRoKSB7XG4gICAgICAgICAgICAgIHdpZHRoICs9IHJhbmdlLng7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHJhbmdlLnkgPD0gMCAmJiB0b3AgPD0gbWluVG9wKSB7XG4gICAgICAgICAgICAgIHJlbmRlcmFibGUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd2lkdGggKz0gcmFuZ2UueDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJhbmdlLnkgPD0gMCkge1xuICAgICAgICAgICAgaWYgKHRvcCA+IG1pblRvcCkge1xuICAgICAgICAgICAgICBoZWlnaHQgLT0gcmFuZ2UueTtcbiAgICAgICAgICAgICAgdG9wICs9IHJhbmdlLnk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGhlaWdodCAtPSByYW5nZS55O1xuICAgICAgICAgICAgdG9wICs9IHJhbmdlLnk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh3aWR0aCA8IDAgJiYgaGVpZ2h0IDwgMCkge1xuICAgICAgICAgIGFjdGlvbiA9IEFDVElPTl9TT1VUSF9XRVNUO1xuICAgICAgICAgIGhlaWdodCA9IC1oZWlnaHQ7XG4gICAgICAgICAgd2lkdGggPSAtd2lkdGg7XG4gICAgICAgICAgdG9wIC09IGhlaWdodDtcbiAgICAgICAgICBsZWZ0IC09IHdpZHRoO1xuICAgICAgICB9IGVsc2UgaWYgKHdpZHRoIDwgMCkge1xuICAgICAgICAgIGFjdGlvbiA9IEFDVElPTl9OT1JUSF9XRVNUO1xuICAgICAgICAgIHdpZHRoID0gLXdpZHRoO1xuICAgICAgICAgIGxlZnQgLT0gd2lkdGg7XG4gICAgICAgIH0gZWxzZSBpZiAoaGVpZ2h0IDwgMCkge1xuICAgICAgICAgIGFjdGlvbiA9IEFDVElPTl9TT1VUSF9FQVNUO1xuICAgICAgICAgIGhlaWdodCA9IC1oZWlnaHQ7XG4gICAgICAgICAgdG9wIC09IGhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQUNUSU9OX05PUlRIX1dFU1Q6XG4gICAgICAgIGlmIChhc3BlY3RSYXRpbykge1xuICAgICAgICAgIGlmIChyYW5nZS55IDw9IDAgJiYgKHRvcCA8PSBtaW5Ub3AgfHwgbGVmdCA8PSBtaW5MZWZ0KSkge1xuICAgICAgICAgICAgcmVuZGVyYWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNoZWNrKEFDVElPTl9OT1JUSCk7XG4gICAgICAgICAgaGVpZ2h0IC09IHJhbmdlLnk7XG4gICAgICAgICAgdG9wICs9IHJhbmdlLnk7XG4gICAgICAgICAgd2lkdGggPSBoZWlnaHQgKiBhc3BlY3RSYXRpbztcbiAgICAgICAgICBsZWZ0ICs9IGNyb3BCb3hEYXRhLndpZHRoIC0gd2lkdGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2hlY2soQUNUSU9OX05PUlRIKTtcbiAgICAgICAgICBjaGVjayhBQ1RJT05fV0VTVCk7XG4gICAgICAgICAgaWYgKHJhbmdlLnggPD0gMCkge1xuICAgICAgICAgICAgaWYgKGxlZnQgPiBtaW5MZWZ0KSB7XG4gICAgICAgICAgICAgIHdpZHRoIC09IHJhbmdlLng7XG4gICAgICAgICAgICAgIGxlZnQgKz0gcmFuZ2UueDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocmFuZ2UueSA8PSAwICYmIHRvcCA8PSBtaW5Ub3ApIHtcbiAgICAgICAgICAgICAgcmVuZGVyYWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3aWR0aCAtPSByYW5nZS54O1xuICAgICAgICAgICAgbGVmdCArPSByYW5nZS54O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocmFuZ2UueSA8PSAwKSB7XG4gICAgICAgICAgICBpZiAodG9wID4gbWluVG9wKSB7XG4gICAgICAgICAgICAgIGhlaWdodCAtPSByYW5nZS55O1xuICAgICAgICAgICAgICB0b3AgKz0gcmFuZ2UueTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaGVpZ2h0IC09IHJhbmdlLnk7XG4gICAgICAgICAgICB0b3AgKz0gcmFuZ2UueTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdpZHRoIDwgMCAmJiBoZWlnaHQgPCAwKSB7XG4gICAgICAgICAgYWN0aW9uID0gQUNUSU9OX1NPVVRIX0VBU1Q7XG4gICAgICAgICAgaGVpZ2h0ID0gLWhlaWdodDtcbiAgICAgICAgICB3aWR0aCA9IC13aWR0aDtcbiAgICAgICAgICB0b3AgLT0gaGVpZ2h0O1xuICAgICAgICAgIGxlZnQgLT0gd2lkdGg7XG4gICAgICAgIH0gZWxzZSBpZiAod2lkdGggPCAwKSB7XG4gICAgICAgICAgYWN0aW9uID0gQUNUSU9OX05PUlRIX0VBU1Q7XG4gICAgICAgICAgd2lkdGggPSAtd2lkdGg7XG4gICAgICAgICAgbGVmdCAtPSB3aWR0aDtcbiAgICAgICAgfSBlbHNlIGlmIChoZWlnaHQgPCAwKSB7XG4gICAgICAgICAgYWN0aW9uID0gQUNUSU9OX1NPVVRIX1dFU1Q7XG4gICAgICAgICAgaGVpZ2h0ID0gLWhlaWdodDtcbiAgICAgICAgICB0b3AgLT0gaGVpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBBQ1RJT05fU09VVEhfV0VTVDpcbiAgICAgICAgaWYgKGFzcGVjdFJhdGlvKSB7XG4gICAgICAgICAgaWYgKHJhbmdlLnggPD0gMCAmJiAobGVmdCA8PSBtaW5MZWZ0IHx8IGJvdHRvbSA+PSBtYXhIZWlnaHQpKSB7XG4gICAgICAgICAgICByZW5kZXJhYmxlID0gZmFsc2U7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2hlY2soQUNUSU9OX1dFU1QpO1xuICAgICAgICAgIHdpZHRoIC09IHJhbmdlLng7XG4gICAgICAgICAgbGVmdCArPSByYW5nZS54O1xuICAgICAgICAgIGhlaWdodCA9IHdpZHRoIC8gYXNwZWN0UmF0aW87XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2hlY2soQUNUSU9OX1NPVVRIKTtcbiAgICAgICAgICBjaGVjayhBQ1RJT05fV0VTVCk7XG4gICAgICAgICAgaWYgKHJhbmdlLnggPD0gMCkge1xuICAgICAgICAgICAgaWYgKGxlZnQgPiBtaW5MZWZ0KSB7XG4gICAgICAgICAgICAgIHdpZHRoIC09IHJhbmdlLng7XG4gICAgICAgICAgICAgIGxlZnQgKz0gcmFuZ2UueDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocmFuZ2UueSA+PSAwICYmIGJvdHRvbSA+PSBtYXhIZWlnaHQpIHtcbiAgICAgICAgICAgICAgcmVuZGVyYWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3aWR0aCAtPSByYW5nZS54O1xuICAgICAgICAgICAgbGVmdCArPSByYW5nZS54O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocmFuZ2UueSA+PSAwKSB7XG4gICAgICAgICAgICBpZiAoYm90dG9tIDwgbWF4SGVpZ2h0KSB7XG4gICAgICAgICAgICAgIGhlaWdodCArPSByYW5nZS55O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBoZWlnaHQgKz0gcmFuZ2UueTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdpZHRoIDwgMCAmJiBoZWlnaHQgPCAwKSB7XG4gICAgICAgICAgYWN0aW9uID0gQUNUSU9OX05PUlRIX0VBU1Q7XG4gICAgICAgICAgaGVpZ2h0ID0gLWhlaWdodDtcbiAgICAgICAgICB3aWR0aCA9IC13aWR0aDtcbiAgICAgICAgICB0b3AgLT0gaGVpZ2h0O1xuICAgICAgICAgIGxlZnQgLT0gd2lkdGg7XG4gICAgICAgIH0gZWxzZSBpZiAod2lkdGggPCAwKSB7XG4gICAgICAgICAgYWN0aW9uID0gQUNUSU9OX1NPVVRIX0VBU1Q7XG4gICAgICAgICAgd2lkdGggPSAtd2lkdGg7XG4gICAgICAgICAgbGVmdCAtPSB3aWR0aDtcbiAgICAgICAgfSBlbHNlIGlmIChoZWlnaHQgPCAwKSB7XG4gICAgICAgICAgYWN0aW9uID0gQUNUSU9OX05PUlRIX1dFU1Q7XG4gICAgICAgICAgaGVpZ2h0ID0gLWhlaWdodDtcbiAgICAgICAgICB0b3AgLT0gaGVpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBBQ1RJT05fU09VVEhfRUFTVDpcbiAgICAgICAgaWYgKGFzcGVjdFJhdGlvKSB7XG4gICAgICAgICAgaWYgKHJhbmdlLnggPj0gMCAmJiAocmlnaHQgPj0gbWF4V2lkdGggfHwgYm90dG9tID49IG1heEhlaWdodCkpIHtcbiAgICAgICAgICAgIHJlbmRlcmFibGUgPSBmYWxzZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjaGVjayhBQ1RJT05fRUFTVCk7XG4gICAgICAgICAgd2lkdGggKz0gcmFuZ2UueDtcbiAgICAgICAgICBoZWlnaHQgPSB3aWR0aCAvIGFzcGVjdFJhdGlvO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNoZWNrKEFDVElPTl9TT1VUSCk7XG4gICAgICAgICAgY2hlY2soQUNUSU9OX0VBU1QpO1xuICAgICAgICAgIGlmIChyYW5nZS54ID49IDApIHtcbiAgICAgICAgICAgIGlmIChyaWdodCA8IG1heFdpZHRoKSB7XG4gICAgICAgICAgICAgIHdpZHRoICs9IHJhbmdlLng7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHJhbmdlLnkgPj0gMCAmJiBib3R0b20gPj0gbWF4SGVpZ2h0KSB7XG4gICAgICAgICAgICAgIHJlbmRlcmFibGUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd2lkdGggKz0gcmFuZ2UueDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJhbmdlLnkgPj0gMCkge1xuICAgICAgICAgICAgaWYgKGJvdHRvbSA8IG1heEhlaWdodCkge1xuICAgICAgICAgICAgICBoZWlnaHQgKz0gcmFuZ2UueTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaGVpZ2h0ICs9IHJhbmdlLnk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh3aWR0aCA8IDAgJiYgaGVpZ2h0IDwgMCkge1xuICAgICAgICAgIGFjdGlvbiA9IEFDVElPTl9OT1JUSF9XRVNUO1xuICAgICAgICAgIGhlaWdodCA9IC1oZWlnaHQ7XG4gICAgICAgICAgd2lkdGggPSAtd2lkdGg7XG4gICAgICAgICAgdG9wIC09IGhlaWdodDtcbiAgICAgICAgICBsZWZ0IC09IHdpZHRoO1xuICAgICAgICB9IGVsc2UgaWYgKHdpZHRoIDwgMCkge1xuICAgICAgICAgIGFjdGlvbiA9IEFDVElPTl9TT1VUSF9XRVNUO1xuICAgICAgICAgIHdpZHRoID0gLXdpZHRoO1xuICAgICAgICAgIGxlZnQgLT0gd2lkdGg7XG4gICAgICAgIH0gZWxzZSBpZiAoaGVpZ2h0IDwgMCkge1xuICAgICAgICAgIGFjdGlvbiA9IEFDVElPTl9OT1JUSF9FQVNUO1xuICAgICAgICAgIGhlaWdodCA9IC1oZWlnaHQ7XG4gICAgICAgICAgdG9wIC09IGhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgICAgLy8gTW92ZSBjYW52YXNcbiAgICAgIGNhc2UgQUNUSU9OX01PVkU6XG4gICAgICAgIHRoaXMubW92ZShyYW5nZS54LCByYW5nZS55KTtcbiAgICAgICAgcmVuZGVyYWJsZSA9IGZhbHNlO1xuICAgICAgICBicmVhaztcblxuICAgICAgLy8gWm9vbSBjYW52YXNcbiAgICAgIGNhc2UgQUNUSU9OX1pPT006XG4gICAgICAgIHRoaXMuem9vbShnZXRNYXhab29tUmF0aW8ocG9pbnRlcnMpLCBldmVudCk7XG4gICAgICAgIHJlbmRlcmFibGUgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIC8vIENyZWF0ZSBjcm9wIGJveFxuICAgICAgY2FzZSBBQ1RJT05fQ1JPUDpcbiAgICAgICAgaWYgKCFyYW5nZS54IHx8ICFyYW5nZS55KSB7XG4gICAgICAgICAgcmVuZGVyYWJsZSA9IGZhbHNlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIG9mZnNldCA9IGdldE9mZnNldCh0aGlzLmNyb3BwZXIpO1xuICAgICAgICBsZWZ0ID0gcG9pbnRlci5zdGFydFggLSBvZmZzZXQubGVmdDtcbiAgICAgICAgdG9wID0gcG9pbnRlci5zdGFydFkgLSBvZmZzZXQudG9wO1xuICAgICAgICB3aWR0aCA9IGNyb3BCb3hEYXRhLm1pbldpZHRoO1xuICAgICAgICBoZWlnaHQgPSBjcm9wQm94RGF0YS5taW5IZWlnaHQ7XG4gICAgICAgIGlmIChyYW5nZS54ID4gMCkge1xuICAgICAgICAgIGFjdGlvbiA9IHJhbmdlLnkgPiAwID8gQUNUSU9OX1NPVVRIX0VBU1QgOiBBQ1RJT05fTk9SVEhfRUFTVDtcbiAgICAgICAgfSBlbHNlIGlmIChyYW5nZS54IDwgMCkge1xuICAgICAgICAgIGxlZnQgLT0gd2lkdGg7XG4gICAgICAgICAgYWN0aW9uID0gcmFuZ2UueSA+IDAgPyBBQ1RJT05fU09VVEhfV0VTVCA6IEFDVElPTl9OT1JUSF9XRVNUO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyYW5nZS55IDwgMCkge1xuICAgICAgICAgIHRvcCAtPSBoZWlnaHQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTaG93IHRoZSBjcm9wIGJveCBpZiBpcyBoaWRkZW5cbiAgICAgICAgaWYgKCF0aGlzLmNyb3BwZWQpIHtcbiAgICAgICAgICByZW1vdmVDbGFzcyh0aGlzLmNyb3BCb3gsIENMQVNTX0hJRERFTik7XG4gICAgICAgICAgdGhpcy5jcm9wcGVkID0gdHJ1ZTtcbiAgICAgICAgICBpZiAodGhpcy5saW1pdGVkKSB7XG4gICAgICAgICAgICB0aGlzLmxpbWl0Q3JvcEJveCh0cnVlLCB0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmIChyZW5kZXJhYmxlKSB7XG4gICAgICBjcm9wQm94RGF0YS53aWR0aCA9IHdpZHRoO1xuICAgICAgY3JvcEJveERhdGEuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgY3JvcEJveERhdGEubGVmdCA9IGxlZnQ7XG4gICAgICBjcm9wQm94RGF0YS50b3AgPSB0b3A7XG4gICAgICB0aGlzLmFjdGlvbiA9IGFjdGlvbjtcbiAgICAgIHRoaXMucmVuZGVyQ3JvcEJveCgpO1xuICAgIH1cblxuICAgIC8vIE92ZXJyaWRlXG4gICAgZm9yRWFjaChwb2ludGVycywgZnVuY3Rpb24gKHApIHtcbiAgICAgIHAuc3RhcnRYID0gcC5lbmRYO1xuICAgICAgcC5zdGFydFkgPSBwLmVuZFk7XG4gICAgfSk7XG4gIH1cbn07XG5cbnZhciBtZXRob2RzID0ge1xuICAvLyBTaG93IHRoZSBjcm9wIGJveCBtYW51YWxseVxuICBjcm9wOiBmdW5jdGlvbiBjcm9wKCkge1xuICAgIGlmICh0aGlzLnJlYWR5ICYmICF0aGlzLmNyb3BwZWQgJiYgIXRoaXMuZGlzYWJsZWQpIHtcbiAgICAgIHRoaXMuY3JvcHBlZCA9IHRydWU7XG4gICAgICB0aGlzLmxpbWl0Q3JvcEJveCh0cnVlLCB0cnVlKTtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMubW9kYWwpIHtcbiAgICAgICAgYWRkQ2xhc3ModGhpcy5kcmFnQm94LCBDTEFTU19NT0RBTCk7XG4gICAgICB9XG4gICAgICByZW1vdmVDbGFzcyh0aGlzLmNyb3BCb3gsIENMQVNTX0hJRERFTik7XG4gICAgICB0aGlzLnNldENyb3BCb3hEYXRhKHRoaXMuaW5pdGlhbENyb3BCb3hEYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIC8vIFJlc2V0IHRoZSBpbWFnZSBhbmQgY3JvcCBib3ggdG8gdGhlaXIgaW5pdGlhbCBzdGF0ZXNcbiAgcmVzZXQ6IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgIGlmICh0aGlzLnJlYWR5ICYmICF0aGlzLmRpc2FibGVkKSB7XG4gICAgICB0aGlzLmltYWdlRGF0YSA9IGFzc2lnbih7fSwgdGhpcy5pbml0aWFsSW1hZ2VEYXRhKTtcbiAgICAgIHRoaXMuY2FudmFzRGF0YSA9IGFzc2lnbih7fSwgdGhpcy5pbml0aWFsQ2FudmFzRGF0YSk7XG4gICAgICB0aGlzLmNyb3BCb3hEYXRhID0gYXNzaWduKHt9LCB0aGlzLmluaXRpYWxDcm9wQm94RGF0YSk7XG4gICAgICB0aGlzLnJlbmRlckNhbnZhcygpO1xuICAgICAgaWYgKHRoaXMuY3JvcHBlZCkge1xuICAgICAgICB0aGlzLnJlbmRlckNyb3BCb3goKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIC8vIENsZWFyIHRoZSBjcm9wIGJveFxuICBjbGVhcjogZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgaWYgKHRoaXMuY3JvcHBlZCAmJiAhdGhpcy5kaXNhYmxlZCkge1xuICAgICAgYXNzaWduKHRoaXMuY3JvcEJveERhdGEsIHtcbiAgICAgICAgbGVmdDogMCxcbiAgICAgICAgdG9wOiAwLFxuICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgaGVpZ2h0OiAwXG4gICAgICB9KTtcbiAgICAgIHRoaXMuY3JvcHBlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5yZW5kZXJDcm9wQm94KCk7XG4gICAgICB0aGlzLmxpbWl0Q2FudmFzKHRydWUsIHRydWUpO1xuXG4gICAgICAvLyBSZW5kZXIgY2FudmFzIGFmdGVyIGNyb3AgYm94IHJlbmRlcmVkXG4gICAgICB0aGlzLnJlbmRlckNhbnZhcygpO1xuICAgICAgcmVtb3ZlQ2xhc3ModGhpcy5kcmFnQm94LCBDTEFTU19NT0RBTCk7XG4gICAgICBhZGRDbGFzcyh0aGlzLmNyb3BCb3gsIENMQVNTX0hJRERFTik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICAvKipcbiAgICogUmVwbGFjZSB0aGUgaW1hZ2UncyBzcmMgYW5kIHJlYnVpbGQgdGhlIGNyb3BwZXJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHVybCAtIFRoZSBuZXcgVVJMLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtoYXNTYW1lU2l6ZV0gLSBJbmRpY2F0ZSBpZiB0aGUgbmV3IGltYWdlIGhhcyB0aGUgc2FtZSBzaXplIGFzIHRoZSBvbGQgb25lLlxuICAgKiBAcmV0dXJucyB7Q3JvcHBlcn0gdGhpc1xuICAgKi9cbiAgcmVwbGFjZTogZnVuY3Rpb24gcmVwbGFjZSh1cmwpIHtcbiAgICB2YXIgaGFzU2FtZVNpemUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuICAgIGlmICghdGhpcy5kaXNhYmxlZCAmJiB1cmwpIHtcbiAgICAgIGlmICh0aGlzLmlzSW1nKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudC5zcmMgPSB1cmw7XG4gICAgICB9XG4gICAgICBpZiAoaGFzU2FtZVNpemUpIHtcbiAgICAgICAgdGhpcy51cmwgPSB1cmw7XG4gICAgICAgIHRoaXMuaW1hZ2Uuc3JjID0gdXJsO1xuICAgICAgICBpZiAodGhpcy5yZWFkeSkge1xuICAgICAgICAgIHRoaXMudmlld0JveEltYWdlLnNyYyA9IHVybDtcbiAgICAgICAgICBmb3JFYWNoKHRoaXMucHJldmlld3MsIGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgICAgICBlbGVtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdpbWcnKVswXS5zcmMgPSB1cmw7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0aGlzLmlzSW1nKSB7XG4gICAgICAgICAgdGhpcy5yZXBsYWNlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vcHRpb25zLmRhdGEgPSBudWxsO1xuICAgICAgICB0aGlzLnVuY3JlYXRlKCk7XG4gICAgICAgIHRoaXMubG9hZCh1cmwpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgLy8gRW5hYmxlICh1bmZyZWV6ZSkgdGhlIGNyb3BwZXJcbiAgZW5hYmxlOiBmdW5jdGlvbiBlbmFibGUoKSB7XG4gICAgaWYgKHRoaXMucmVhZHkgJiYgdGhpcy5kaXNhYmxlZCkge1xuICAgICAgdGhpcy5kaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgcmVtb3ZlQ2xhc3ModGhpcy5jcm9wcGVyLCBDTEFTU19ESVNBQkxFRCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICAvLyBEaXNhYmxlIChmcmVlemUpIHRoZSBjcm9wcGVyXG4gIGRpc2FibGU6IGZ1bmN0aW9uIGRpc2FibGUoKSB7XG4gICAgaWYgKHRoaXMucmVhZHkgJiYgIXRoaXMuZGlzYWJsZWQpIHtcbiAgICAgIHRoaXMuZGlzYWJsZWQgPSB0cnVlO1xuICAgICAgYWRkQ2xhc3ModGhpcy5jcm9wcGVyLCBDTEFTU19ESVNBQkxFRCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICAvKipcbiAgICogRGVzdHJveSB0aGUgY3JvcHBlciBhbmQgcmVtb3ZlIHRoZSBpbnN0YW5jZSBmcm9tIHRoZSBpbWFnZVxuICAgKiBAcmV0dXJucyB7Q3JvcHBlcn0gdGhpc1xuICAgKi9cbiAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICB2YXIgZWxlbWVudCA9IHRoaXMuZWxlbWVudDtcbiAgICBpZiAoIWVsZW1lbnRbTkFNRVNQQUNFXSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGVsZW1lbnRbTkFNRVNQQUNFXSA9IHVuZGVmaW5lZDtcbiAgICBpZiAodGhpcy5pc0ltZyAmJiB0aGlzLnJlcGxhY2VkKSB7XG4gICAgICBlbGVtZW50LnNyYyA9IHRoaXMub3JpZ2luYWxVcmw7XG4gICAgfVxuICAgIHRoaXMudW5jcmVhdGUoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgLyoqXG4gICAqIE1vdmUgdGhlIGNhbnZhcyB3aXRoIHJlbGF0aXZlIG9mZnNldHNcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFggLSBUaGUgcmVsYXRpdmUgb2Zmc2V0IGRpc3RhbmNlIG9uIHRoZSB4LWF4aXMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb2Zmc2V0WT1vZmZzZXRYXSAtIFRoZSByZWxhdGl2ZSBvZmZzZXQgZGlzdGFuY2Ugb24gdGhlIHktYXhpcy5cbiAgICogQHJldHVybnMge0Nyb3BwZXJ9IHRoaXNcbiAgICovXG4gIG1vdmU6IGZ1bmN0aW9uIG1vdmUob2Zmc2V0WCkge1xuICAgIHZhciBvZmZzZXRZID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBvZmZzZXRYO1xuICAgIHZhciBfdGhpcyRjYW52YXNEYXRhID0gdGhpcy5jYW52YXNEYXRhLFxuICAgICAgbGVmdCA9IF90aGlzJGNhbnZhc0RhdGEubGVmdCxcbiAgICAgIHRvcCA9IF90aGlzJGNhbnZhc0RhdGEudG9wO1xuICAgIHJldHVybiB0aGlzLm1vdmVUbyhpc1VuZGVmaW5lZChvZmZzZXRYKSA/IG9mZnNldFggOiBsZWZ0ICsgTnVtYmVyKG9mZnNldFgpLCBpc1VuZGVmaW5lZChvZmZzZXRZKSA/IG9mZnNldFkgOiB0b3AgKyBOdW1iZXIob2Zmc2V0WSkpO1xuICB9LFxuICAvKipcbiAgICogTW92ZSB0aGUgY2FudmFzIHRvIGFuIGFic29sdXRlIHBvaW50XG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gVGhlIHgtYXhpcyBjb29yZGluYXRlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW3k9eF0gLSBUaGUgeS1heGlzIGNvb3JkaW5hdGUuXG4gICAqIEByZXR1cm5zIHtDcm9wcGVyfSB0aGlzXG4gICAqL1xuICBtb3ZlVG86IGZ1bmN0aW9uIG1vdmVUbyh4KSB7XG4gICAgdmFyIHkgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHg7XG4gICAgdmFyIGNhbnZhc0RhdGEgPSB0aGlzLmNhbnZhc0RhdGE7XG4gICAgdmFyIGNoYW5nZWQgPSBmYWxzZTtcbiAgICB4ID0gTnVtYmVyKHgpO1xuICAgIHkgPSBOdW1iZXIoeSk7XG4gICAgaWYgKHRoaXMucmVhZHkgJiYgIXRoaXMuZGlzYWJsZWQgJiYgdGhpcy5vcHRpb25zLm1vdmFibGUpIHtcbiAgICAgIGlmIChpc051bWJlcih4KSkge1xuICAgICAgICBjYW52YXNEYXRhLmxlZnQgPSB4O1xuICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChpc051bWJlcih5KSkge1xuICAgICAgICBjYW52YXNEYXRhLnRvcCA9IHk7XG4gICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJDYW52YXModHJ1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICAvKipcbiAgICogWm9vbSB0aGUgY2FudmFzIHdpdGggYSByZWxhdGl2ZSByYXRpb1xuICAgKiBAcGFyYW0ge251bWJlcn0gcmF0aW8gLSBUaGUgdGFyZ2V0IHJhdGlvLlxuICAgKiBAcGFyYW0ge0V2ZW50fSBfb3JpZ2luYWxFdmVudCAtIFRoZSBvcmlnaW5hbCBldmVudCBpZiBhbnkuXG4gICAqIEByZXR1cm5zIHtDcm9wcGVyfSB0aGlzXG4gICAqL1xuICB6b29tOiBmdW5jdGlvbiB6b29tKHJhdGlvLCBfb3JpZ2luYWxFdmVudCkge1xuICAgIHZhciBjYW52YXNEYXRhID0gdGhpcy5jYW52YXNEYXRhO1xuICAgIHJhdGlvID0gTnVtYmVyKHJhdGlvKTtcbiAgICBpZiAocmF0aW8gPCAwKSB7XG4gICAgICByYXRpbyA9IDEgLyAoMSAtIHJhdGlvKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmF0aW8gPSAxICsgcmF0aW87XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnpvb21UbyhjYW52YXNEYXRhLndpZHRoICogcmF0aW8gLyBjYW52YXNEYXRhLm5hdHVyYWxXaWR0aCwgbnVsbCwgX29yaWdpbmFsRXZlbnQpO1xuICB9LFxuICAvKipcbiAgICogWm9vbSB0aGUgY2FudmFzIHRvIGFuIGFic29sdXRlIHJhdGlvXG4gICAqIEBwYXJhbSB7bnVtYmVyfSByYXRpbyAtIFRoZSB0YXJnZXQgcmF0aW8uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwaXZvdCAtIFRoZSB6b29tIHBpdm90IHBvaW50IGNvb3JkaW5hdGUuXG4gICAqIEBwYXJhbSB7RXZlbnR9IF9vcmlnaW5hbEV2ZW50IC0gVGhlIG9yaWdpbmFsIGV2ZW50IGlmIGFueS5cbiAgICogQHJldHVybnMge0Nyb3BwZXJ9IHRoaXNcbiAgICovXG4gIHpvb21UbzogZnVuY3Rpb24gem9vbVRvKHJhdGlvLCBwaXZvdCwgX29yaWdpbmFsRXZlbnQpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcbiAgICAgIGNhbnZhc0RhdGEgPSB0aGlzLmNhbnZhc0RhdGE7XG4gICAgdmFyIHdpZHRoID0gY2FudmFzRGF0YS53aWR0aCxcbiAgICAgIGhlaWdodCA9IGNhbnZhc0RhdGEuaGVpZ2h0LFxuICAgICAgbmF0dXJhbFdpZHRoID0gY2FudmFzRGF0YS5uYXR1cmFsV2lkdGgsXG4gICAgICBuYXR1cmFsSGVpZ2h0ID0gY2FudmFzRGF0YS5uYXR1cmFsSGVpZ2h0O1xuICAgIHJhdGlvID0gTnVtYmVyKHJhdGlvKTtcbiAgICBpZiAocmF0aW8gPj0gMCAmJiB0aGlzLnJlYWR5ICYmICF0aGlzLmRpc2FibGVkICYmIG9wdGlvbnMuem9vbWFibGUpIHtcbiAgICAgIHZhciBuZXdXaWR0aCA9IG5hdHVyYWxXaWR0aCAqIHJhdGlvO1xuICAgICAgdmFyIG5ld0hlaWdodCA9IG5hdHVyYWxIZWlnaHQgKiByYXRpbztcbiAgICAgIGlmIChkaXNwYXRjaEV2ZW50KHRoaXMuZWxlbWVudCwgRVZFTlRfWk9PTSwge1xuICAgICAgICByYXRpbzogcmF0aW8sXG4gICAgICAgIG9sZFJhdGlvOiB3aWR0aCAvIG5hdHVyYWxXaWR0aCxcbiAgICAgICAgb3JpZ2luYWxFdmVudDogX29yaWdpbmFsRXZlbnRcbiAgICAgIH0pID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIGlmIChfb3JpZ2luYWxFdmVudCkge1xuICAgICAgICB2YXIgcG9pbnRlcnMgPSB0aGlzLnBvaW50ZXJzO1xuICAgICAgICB2YXIgb2Zmc2V0ID0gZ2V0T2Zmc2V0KHRoaXMuY3JvcHBlcik7XG4gICAgICAgIHZhciBjZW50ZXIgPSBwb2ludGVycyAmJiBPYmplY3Qua2V5cyhwb2ludGVycykubGVuZ3RoID8gZ2V0UG9pbnRlcnNDZW50ZXIocG9pbnRlcnMpIDoge1xuICAgICAgICAgIHBhZ2VYOiBfb3JpZ2luYWxFdmVudC5wYWdlWCxcbiAgICAgICAgICBwYWdlWTogX29yaWdpbmFsRXZlbnQucGFnZVlcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBab29tIGZyb20gdGhlIHRyaWdnZXJpbmcgcG9pbnQgb2YgdGhlIGV2ZW50XG4gICAgICAgIGNhbnZhc0RhdGEubGVmdCAtPSAobmV3V2lkdGggLSB3aWR0aCkgKiAoKGNlbnRlci5wYWdlWCAtIG9mZnNldC5sZWZ0IC0gY2FudmFzRGF0YS5sZWZ0KSAvIHdpZHRoKTtcbiAgICAgICAgY2FudmFzRGF0YS50b3AgLT0gKG5ld0hlaWdodCAtIGhlaWdodCkgKiAoKGNlbnRlci5wYWdlWSAtIG9mZnNldC50b3AgLSBjYW52YXNEYXRhLnRvcCkgLyBoZWlnaHQpO1xuICAgICAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHBpdm90KSAmJiBpc051bWJlcihwaXZvdC54KSAmJiBpc051bWJlcihwaXZvdC55KSkge1xuICAgICAgICBjYW52YXNEYXRhLmxlZnQgLT0gKG5ld1dpZHRoIC0gd2lkdGgpICogKChwaXZvdC54IC0gY2FudmFzRGF0YS5sZWZ0KSAvIHdpZHRoKTtcbiAgICAgICAgY2FudmFzRGF0YS50b3AgLT0gKG5ld0hlaWdodCAtIGhlaWdodCkgKiAoKHBpdm90LnkgLSBjYW52YXNEYXRhLnRvcCkgLyBoZWlnaHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gWm9vbSBmcm9tIHRoZSBjZW50ZXIgb2YgdGhlIGNhbnZhc1xuICAgICAgICBjYW52YXNEYXRhLmxlZnQgLT0gKG5ld1dpZHRoIC0gd2lkdGgpIC8gMjtcbiAgICAgICAgY2FudmFzRGF0YS50b3AgLT0gKG5ld0hlaWdodCAtIGhlaWdodCkgLyAyO1xuICAgICAgfVxuICAgICAgY2FudmFzRGF0YS53aWR0aCA9IG5ld1dpZHRoO1xuICAgICAgY2FudmFzRGF0YS5oZWlnaHQgPSBuZXdIZWlnaHQ7XG4gICAgICB0aGlzLnJlbmRlckNhbnZhcyh0cnVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIC8qKlxuICAgKiBSb3RhdGUgdGhlIGNhbnZhcyB3aXRoIGEgcmVsYXRpdmUgZGVncmVlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkZWdyZWUgLSBUaGUgcm90YXRlIGRlZ3JlZS5cbiAgICogQHJldHVybnMge0Nyb3BwZXJ9IHRoaXNcbiAgICovXG4gIHJvdGF0ZTogZnVuY3Rpb24gcm90YXRlKGRlZ3JlZSkge1xuICAgIHJldHVybiB0aGlzLnJvdGF0ZVRvKCh0aGlzLmltYWdlRGF0YS5yb3RhdGUgfHwgMCkgKyBOdW1iZXIoZGVncmVlKSk7XG4gIH0sXG4gIC8qKlxuICAgKiBSb3RhdGUgdGhlIGNhbnZhcyB0byBhbiBhYnNvbHV0ZSBkZWdyZWVcbiAgICogQHBhcmFtIHtudW1iZXJ9IGRlZ3JlZSAtIFRoZSByb3RhdGUgZGVncmVlLlxuICAgKiBAcmV0dXJucyB7Q3JvcHBlcn0gdGhpc1xuICAgKi9cbiAgcm90YXRlVG86IGZ1bmN0aW9uIHJvdGF0ZVRvKGRlZ3JlZSkge1xuICAgIGRlZ3JlZSA9IE51bWJlcihkZWdyZWUpO1xuICAgIGlmIChpc051bWJlcihkZWdyZWUpICYmIHRoaXMucmVhZHkgJiYgIXRoaXMuZGlzYWJsZWQgJiYgdGhpcy5vcHRpb25zLnJvdGF0YWJsZSkge1xuICAgICAgdGhpcy5pbWFnZURhdGEucm90YXRlID0gZGVncmVlICUgMzYwO1xuICAgICAgdGhpcy5yZW5kZXJDYW52YXModHJ1ZSwgdHJ1ZSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICAvKipcbiAgICogU2NhbGUgdGhlIGltYWdlIG9uIHRoZSB4LWF4aXMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzY2FsZVggLSBUaGUgc2NhbGUgcmF0aW8gb24gdGhlIHgtYXhpcy5cbiAgICogQHJldHVybnMge0Nyb3BwZXJ9IHRoaXNcbiAgICovXG4gIHNjYWxlWDogZnVuY3Rpb24gc2NhbGVYKF9zY2FsZVgpIHtcbiAgICB2YXIgc2NhbGVZID0gdGhpcy5pbWFnZURhdGEuc2NhbGVZO1xuICAgIHJldHVybiB0aGlzLnNjYWxlKF9zY2FsZVgsIGlzTnVtYmVyKHNjYWxlWSkgPyBzY2FsZVkgOiAxKTtcbiAgfSxcbiAgLyoqXG4gICAqIFNjYWxlIHRoZSBpbWFnZSBvbiB0aGUgeS1heGlzLlxuICAgKiBAcGFyYW0ge251bWJlcn0gc2NhbGVZIC0gVGhlIHNjYWxlIHJhdGlvIG9uIHRoZSB5LWF4aXMuXG4gICAqIEByZXR1cm5zIHtDcm9wcGVyfSB0aGlzXG4gICAqL1xuICBzY2FsZVk6IGZ1bmN0aW9uIHNjYWxlWShfc2NhbGVZKSB7XG4gICAgdmFyIHNjYWxlWCA9IHRoaXMuaW1hZ2VEYXRhLnNjYWxlWDtcbiAgICByZXR1cm4gdGhpcy5zY2FsZShpc051bWJlcihzY2FsZVgpID8gc2NhbGVYIDogMSwgX3NjYWxlWSk7XG4gIH0sXG4gIC8qKlxuICAgKiBTY2FsZSB0aGUgaW1hZ2VcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNjYWxlWCAtIFRoZSBzY2FsZSByYXRpbyBvbiB0aGUgeC1heGlzLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW3NjYWxlWT1zY2FsZVhdIC0gVGhlIHNjYWxlIHJhdGlvIG9uIHRoZSB5LWF4aXMuXG4gICAqIEByZXR1cm5zIHtDcm9wcGVyfSB0aGlzXG4gICAqL1xuICBzY2FsZTogZnVuY3Rpb24gc2NhbGUoc2NhbGVYKSB7XG4gICAgdmFyIHNjYWxlWSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogc2NhbGVYO1xuICAgIHZhciBpbWFnZURhdGEgPSB0aGlzLmltYWdlRGF0YTtcbiAgICB2YXIgdHJhbnNmb3JtZWQgPSBmYWxzZTtcbiAgICBzY2FsZVggPSBOdW1iZXIoc2NhbGVYKTtcbiAgICBzY2FsZVkgPSBOdW1iZXIoc2NhbGVZKTtcbiAgICBpZiAodGhpcy5yZWFkeSAmJiAhdGhpcy5kaXNhYmxlZCAmJiB0aGlzLm9wdGlvbnMuc2NhbGFibGUpIHtcbiAgICAgIGlmIChpc051bWJlcihzY2FsZVgpKSB7XG4gICAgICAgIGltYWdlRGF0YS5zY2FsZVggPSBzY2FsZVg7XG4gICAgICAgIHRyYW5zZm9ybWVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChpc051bWJlcihzY2FsZVkpKSB7XG4gICAgICAgIGltYWdlRGF0YS5zY2FsZVkgPSBzY2FsZVk7XG4gICAgICAgIHRyYW5zZm9ybWVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICh0cmFuc2Zvcm1lZCkge1xuICAgICAgICB0aGlzLnJlbmRlckNhbnZhcyh0cnVlLCB0cnVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIC8qKlxuICAgKiBHZXQgdGhlIGNyb3BwZWQgYXJlYSBwb3NpdGlvbiBhbmQgc2l6ZSBkYXRhIChiYXNlIG9uIHRoZSBvcmlnaW5hbCBpbWFnZSlcbiAgICogQHBhcmFtIHtib29sZWFufSBbcm91bmRlZD1mYWxzZV0gLSBJbmRpY2F0ZSBpZiByb3VuZCB0aGUgZGF0YSB2YWx1ZXMgb3Igbm90LlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgcmVzdWx0IGNyb3BwZWQgZGF0YS5cbiAgICovXG4gIGdldERhdGE6IGZ1bmN0aW9uIGdldERhdGEoKSB7XG4gICAgdmFyIHJvdW5kZWQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGZhbHNlO1xuICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuICAgICAgaW1hZ2VEYXRhID0gdGhpcy5pbWFnZURhdGEsXG4gICAgICBjYW52YXNEYXRhID0gdGhpcy5jYW52YXNEYXRhLFxuICAgICAgY3JvcEJveERhdGEgPSB0aGlzLmNyb3BCb3hEYXRhO1xuICAgIHZhciBkYXRhO1xuICAgIGlmICh0aGlzLnJlYWR5ICYmIHRoaXMuY3JvcHBlZCkge1xuICAgICAgZGF0YSA9IHtcbiAgICAgICAgeDogY3JvcEJveERhdGEubGVmdCAtIGNhbnZhc0RhdGEubGVmdCxcbiAgICAgICAgeTogY3JvcEJveERhdGEudG9wIC0gY2FudmFzRGF0YS50b3AsXG4gICAgICAgIHdpZHRoOiBjcm9wQm94RGF0YS53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBjcm9wQm94RGF0YS5oZWlnaHRcbiAgICAgIH07XG4gICAgICB2YXIgcmF0aW8gPSBpbWFnZURhdGEud2lkdGggLyBpbWFnZURhdGEubmF0dXJhbFdpZHRoO1xuICAgICAgZm9yRWFjaChkYXRhLCBmdW5jdGlvbiAobiwgaSkge1xuICAgICAgICBkYXRhW2ldID0gbiAvIHJhdGlvO1xuICAgICAgfSk7XG4gICAgICBpZiAocm91bmRlZCkge1xuICAgICAgICAvLyBJbiBjYXNlIHJvdW5kaW5nIG9mZiBsZWFkcyB0byBleHRyYSAxcHggaW4gcmlnaHQgb3IgYm90dG9tIGJvcmRlclxuICAgICAgICAvLyB3ZSBzaG91bGQgcm91bmQgdGhlIHRvcC1sZWZ0IGNvcm5lciBhbmQgdGhlIGRpbWVuc2lvbiAoIzM0MykuXG4gICAgICAgIHZhciBib3R0b20gPSBNYXRoLnJvdW5kKGRhdGEueSArIGRhdGEuaGVpZ2h0KTtcbiAgICAgICAgdmFyIHJpZ2h0ID0gTWF0aC5yb3VuZChkYXRhLnggKyBkYXRhLndpZHRoKTtcbiAgICAgICAgZGF0YS54ID0gTWF0aC5yb3VuZChkYXRhLngpO1xuICAgICAgICBkYXRhLnkgPSBNYXRoLnJvdW5kKGRhdGEueSk7XG4gICAgICAgIGRhdGEud2lkdGggPSByaWdodCAtIGRhdGEueDtcbiAgICAgICAgZGF0YS5oZWlnaHQgPSBib3R0b20gLSBkYXRhLnk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGRhdGEgPSB7XG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDAsXG4gICAgICAgIHdpZHRoOiAwLFxuICAgICAgICBoZWlnaHQ6IDBcbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnJvdGF0YWJsZSkge1xuICAgICAgZGF0YS5yb3RhdGUgPSBpbWFnZURhdGEucm90YXRlIHx8IDA7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnNjYWxhYmxlKSB7XG4gICAgICBkYXRhLnNjYWxlWCA9IGltYWdlRGF0YS5zY2FsZVggfHwgMTtcbiAgICAgIGRhdGEuc2NhbGVZID0gaW1hZ2VEYXRhLnNjYWxlWSB8fCAxO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbiAgfSxcbiAgLyoqXG4gICAqIFNldCB0aGUgY3JvcHBlZCBhcmVhIHBvc2l0aW9uIGFuZCBzaXplIHdpdGggbmV3IGRhdGFcbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgLSBUaGUgbmV3IGRhdGEuXG4gICAqIEByZXR1cm5zIHtDcm9wcGVyfSB0aGlzXG4gICAqL1xuICBzZXREYXRhOiBmdW5jdGlvbiBzZXREYXRhKGRhdGEpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcbiAgICAgIGltYWdlRGF0YSA9IHRoaXMuaW1hZ2VEYXRhLFxuICAgICAgY2FudmFzRGF0YSA9IHRoaXMuY2FudmFzRGF0YTtcbiAgICB2YXIgY3JvcEJveERhdGEgPSB7fTtcbiAgICBpZiAodGhpcy5yZWFkeSAmJiAhdGhpcy5kaXNhYmxlZCAmJiBpc1BsYWluT2JqZWN0KGRhdGEpKSB7XG4gICAgICB2YXIgdHJhbnNmb3JtZWQgPSBmYWxzZTtcbiAgICAgIGlmIChvcHRpb25zLnJvdGF0YWJsZSkge1xuICAgICAgICBpZiAoaXNOdW1iZXIoZGF0YS5yb3RhdGUpICYmIGRhdGEucm90YXRlICE9PSBpbWFnZURhdGEucm90YXRlKSB7XG4gICAgICAgICAgaW1hZ2VEYXRhLnJvdGF0ZSA9IGRhdGEucm90YXRlO1xuICAgICAgICAgIHRyYW5zZm9ybWVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMuc2NhbGFibGUpIHtcbiAgICAgICAgaWYgKGlzTnVtYmVyKGRhdGEuc2NhbGVYKSAmJiBkYXRhLnNjYWxlWCAhPT0gaW1hZ2VEYXRhLnNjYWxlWCkge1xuICAgICAgICAgIGltYWdlRGF0YS5zY2FsZVggPSBkYXRhLnNjYWxlWDtcbiAgICAgICAgICB0cmFuc2Zvcm1lZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTnVtYmVyKGRhdGEuc2NhbGVZKSAmJiBkYXRhLnNjYWxlWSAhPT0gaW1hZ2VEYXRhLnNjYWxlWSkge1xuICAgICAgICAgIGltYWdlRGF0YS5zY2FsZVkgPSBkYXRhLnNjYWxlWTtcbiAgICAgICAgICB0cmFuc2Zvcm1lZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0cmFuc2Zvcm1lZCkge1xuICAgICAgICB0aGlzLnJlbmRlckNhbnZhcyh0cnVlLCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIHZhciByYXRpbyA9IGltYWdlRGF0YS53aWR0aCAvIGltYWdlRGF0YS5uYXR1cmFsV2lkdGg7XG4gICAgICBpZiAoaXNOdW1iZXIoZGF0YS54KSkge1xuICAgICAgICBjcm9wQm94RGF0YS5sZWZ0ID0gZGF0YS54ICogcmF0aW8gKyBjYW52YXNEYXRhLmxlZnQ7XG4gICAgICB9XG4gICAgICBpZiAoaXNOdW1iZXIoZGF0YS55KSkge1xuICAgICAgICBjcm9wQm94RGF0YS50b3AgPSBkYXRhLnkgKiByYXRpbyArIGNhbnZhc0RhdGEudG9wO1xuICAgICAgfVxuICAgICAgaWYgKGlzTnVtYmVyKGRhdGEud2lkdGgpKSB7XG4gICAgICAgIGNyb3BCb3hEYXRhLndpZHRoID0gZGF0YS53aWR0aCAqIHJhdGlvO1xuICAgICAgfVxuICAgICAgaWYgKGlzTnVtYmVyKGRhdGEuaGVpZ2h0KSkge1xuICAgICAgICBjcm9wQm94RGF0YS5oZWlnaHQgPSBkYXRhLmhlaWdodCAqIHJhdGlvO1xuICAgICAgfVxuICAgICAgdGhpcy5zZXRDcm9wQm94RGF0YShjcm9wQm94RGF0YSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICAvKipcbiAgICogR2V0IHRoZSBjb250YWluZXIgc2l6ZSBkYXRhLlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgcmVzdWx0IGNvbnRhaW5lciBkYXRhLlxuICAgKi9cbiAgZ2V0Q29udGFpbmVyRGF0YTogZnVuY3Rpb24gZ2V0Q29udGFpbmVyRGF0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5yZWFkeSA/IGFzc2lnbih7fSwgdGhpcy5jb250YWluZXJEYXRhKSA6IHt9O1xuICB9LFxuICAvKipcbiAgICogR2V0IHRoZSBpbWFnZSBwb3NpdGlvbiBhbmQgc2l6ZSBkYXRhLlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgcmVzdWx0IGltYWdlIGRhdGEuXG4gICAqL1xuICBnZXRJbWFnZURhdGE6IGZ1bmN0aW9uIGdldEltYWdlRGF0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5zaXplZCA/IGFzc2lnbih7fSwgdGhpcy5pbWFnZURhdGEpIDoge307XG4gIH0sXG4gIC8qKlxuICAgKiBHZXQgdGhlIGNhbnZhcyBwb3NpdGlvbiBhbmQgc2l6ZSBkYXRhLlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgcmVzdWx0IGNhbnZhcyBkYXRhLlxuICAgKi9cbiAgZ2V0Q2FudmFzRGF0YTogZnVuY3Rpb24gZ2V0Q2FudmFzRGF0YSgpIHtcbiAgICB2YXIgY2FudmFzRGF0YSA9IHRoaXMuY2FudmFzRGF0YTtcbiAgICB2YXIgZGF0YSA9IHt9O1xuICAgIGlmICh0aGlzLnJlYWR5KSB7XG4gICAgICBmb3JFYWNoKFsnbGVmdCcsICd0b3AnLCAnd2lkdGgnLCAnaGVpZ2h0JywgJ25hdHVyYWxXaWR0aCcsICduYXR1cmFsSGVpZ2h0J10sIGZ1bmN0aW9uIChuKSB7XG4gICAgICAgIGRhdGFbbl0gPSBjYW52YXNEYXRhW25dO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBkYXRhO1xuICB9LFxuICAvKipcbiAgICogU2V0IHRoZSBjYW52YXMgcG9zaXRpb24gYW5kIHNpemUgd2l0aCBuZXcgZGF0YS5cbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgLSBUaGUgbmV3IGNhbnZhcyBkYXRhLlxuICAgKiBAcmV0dXJucyB7Q3JvcHBlcn0gdGhpc1xuICAgKi9cbiAgc2V0Q2FudmFzRGF0YTogZnVuY3Rpb24gc2V0Q2FudmFzRGF0YShkYXRhKSB7XG4gICAgdmFyIGNhbnZhc0RhdGEgPSB0aGlzLmNhbnZhc0RhdGE7XG4gICAgdmFyIGFzcGVjdFJhdGlvID0gY2FudmFzRGF0YS5hc3BlY3RSYXRpbztcbiAgICBpZiAodGhpcy5yZWFkeSAmJiAhdGhpcy5kaXNhYmxlZCAmJiBpc1BsYWluT2JqZWN0KGRhdGEpKSB7XG4gICAgICBpZiAoaXNOdW1iZXIoZGF0YS5sZWZ0KSkge1xuICAgICAgICBjYW52YXNEYXRhLmxlZnQgPSBkYXRhLmxlZnQ7XG4gICAgICB9XG4gICAgICBpZiAoaXNOdW1iZXIoZGF0YS50b3ApKSB7XG4gICAgICAgIGNhbnZhc0RhdGEudG9wID0gZGF0YS50b3A7XG4gICAgICB9XG4gICAgICBpZiAoaXNOdW1iZXIoZGF0YS53aWR0aCkpIHtcbiAgICAgICAgY2FudmFzRGF0YS53aWR0aCA9IGRhdGEud2lkdGg7XG4gICAgICAgIGNhbnZhc0RhdGEuaGVpZ2h0ID0gZGF0YS53aWR0aCAvIGFzcGVjdFJhdGlvO1xuICAgICAgfSBlbHNlIGlmIChpc051bWJlcihkYXRhLmhlaWdodCkpIHtcbiAgICAgICAgY2FudmFzRGF0YS5oZWlnaHQgPSBkYXRhLmhlaWdodDtcbiAgICAgICAgY2FudmFzRGF0YS53aWR0aCA9IGRhdGEuaGVpZ2h0ICogYXNwZWN0UmF0aW87XG4gICAgICB9XG4gICAgICB0aGlzLnJlbmRlckNhbnZhcyh0cnVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIC8qKlxuICAgKiBHZXQgdGhlIGNyb3AgYm94IHBvc2l0aW9uIGFuZCBzaXplIGRhdGEuXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSByZXN1bHQgY3JvcCBib3ggZGF0YS5cbiAgICovXG4gIGdldENyb3BCb3hEYXRhOiBmdW5jdGlvbiBnZXRDcm9wQm94RGF0YSgpIHtcbiAgICB2YXIgY3JvcEJveERhdGEgPSB0aGlzLmNyb3BCb3hEYXRhO1xuICAgIHZhciBkYXRhO1xuICAgIGlmICh0aGlzLnJlYWR5ICYmIHRoaXMuY3JvcHBlZCkge1xuICAgICAgZGF0YSA9IHtcbiAgICAgICAgbGVmdDogY3JvcEJveERhdGEubGVmdCxcbiAgICAgICAgdG9wOiBjcm9wQm94RGF0YS50b3AsXG4gICAgICAgIHdpZHRoOiBjcm9wQm94RGF0YS53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBjcm9wQm94RGF0YS5oZWlnaHRcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBkYXRhIHx8IHt9O1xuICB9LFxuICAvKipcbiAgICogU2V0IHRoZSBjcm9wIGJveCBwb3NpdGlvbiBhbmQgc2l6ZSB3aXRoIG5ldyBkYXRhLlxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSAtIFRoZSBuZXcgY3JvcCBib3ggZGF0YS5cbiAgICogQHJldHVybnMge0Nyb3BwZXJ9IHRoaXNcbiAgICovXG4gIHNldENyb3BCb3hEYXRhOiBmdW5jdGlvbiBzZXRDcm9wQm94RGF0YShkYXRhKSB7XG4gICAgdmFyIGNyb3BCb3hEYXRhID0gdGhpcy5jcm9wQm94RGF0YTtcbiAgICB2YXIgYXNwZWN0UmF0aW8gPSB0aGlzLm9wdGlvbnMuYXNwZWN0UmF0aW87XG4gICAgdmFyIHdpZHRoQ2hhbmdlZDtcbiAgICB2YXIgaGVpZ2h0Q2hhbmdlZDtcbiAgICBpZiAodGhpcy5yZWFkeSAmJiB0aGlzLmNyb3BwZWQgJiYgIXRoaXMuZGlzYWJsZWQgJiYgaXNQbGFpbk9iamVjdChkYXRhKSkge1xuICAgICAgaWYgKGlzTnVtYmVyKGRhdGEubGVmdCkpIHtcbiAgICAgICAgY3JvcEJveERhdGEubGVmdCA9IGRhdGEubGVmdDtcbiAgICAgIH1cbiAgICAgIGlmIChpc051bWJlcihkYXRhLnRvcCkpIHtcbiAgICAgICAgY3JvcEJveERhdGEudG9wID0gZGF0YS50b3A7XG4gICAgICB9XG4gICAgICBpZiAoaXNOdW1iZXIoZGF0YS53aWR0aCkgJiYgZGF0YS53aWR0aCAhPT0gY3JvcEJveERhdGEud2lkdGgpIHtcbiAgICAgICAgd2lkdGhDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgY3JvcEJveERhdGEud2lkdGggPSBkYXRhLndpZHRoO1xuICAgICAgfVxuICAgICAgaWYgKGlzTnVtYmVyKGRhdGEuaGVpZ2h0KSAmJiBkYXRhLmhlaWdodCAhPT0gY3JvcEJveERhdGEuaGVpZ2h0KSB7XG4gICAgICAgIGhlaWdodENoYW5nZWQgPSB0cnVlO1xuICAgICAgICBjcm9wQm94RGF0YS5oZWlnaHQgPSBkYXRhLmhlaWdodDtcbiAgICAgIH1cbiAgICAgIGlmIChhc3BlY3RSYXRpbykge1xuICAgICAgICBpZiAod2lkdGhDaGFuZ2VkKSB7XG4gICAgICAgICAgY3JvcEJveERhdGEuaGVpZ2h0ID0gY3JvcEJveERhdGEud2lkdGggLyBhc3BlY3RSYXRpbztcbiAgICAgICAgfSBlbHNlIGlmIChoZWlnaHRDaGFuZ2VkKSB7XG4gICAgICAgICAgY3JvcEJveERhdGEud2lkdGggPSBjcm9wQm94RGF0YS5oZWlnaHQgKiBhc3BlY3RSYXRpbztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5yZW5kZXJDcm9wQm94KCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICAvKipcbiAgICogR2V0IGEgY2FudmFzIGRyYXduIHRoZSBjcm9wcGVkIGltYWdlLlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIC0gVGhlIGNvbmZpZyBvcHRpb25zLlxuICAgKiBAcmV0dXJucyB7SFRNTENhbnZhc0VsZW1lbnR9IC0gVGhlIHJlc3VsdCBjYW52YXMuXG4gICAqL1xuICBnZXRDcm9wcGVkQ2FudmFzOiBmdW5jdGlvbiBnZXRDcm9wcGVkQ2FudmFzKCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICBpZiAoIXRoaXMucmVhZHkgfHwgIXdpbmRvdy5IVE1MQ2FudmFzRWxlbWVudCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBjYW52YXNEYXRhID0gdGhpcy5jYW52YXNEYXRhO1xuICAgIHZhciBzb3VyY2UgPSBnZXRTb3VyY2VDYW52YXModGhpcy5pbWFnZSwgdGhpcy5pbWFnZURhdGEsIGNhbnZhc0RhdGEsIG9wdGlvbnMpO1xuXG4gICAgLy8gUmV0dXJucyB0aGUgc291cmNlIGNhbnZhcyBpZiBpdCBpcyBub3QgY3JvcHBlZC5cbiAgICBpZiAoIXRoaXMuY3JvcHBlZCkge1xuICAgICAgcmV0dXJuIHNvdXJjZTtcbiAgICB9XG4gICAgdmFyIF90aGlzJGdldERhdGEgPSB0aGlzLmdldERhdGEob3B0aW9ucy5yb3VuZGVkKSxcbiAgICAgIGluaXRpYWxYID0gX3RoaXMkZ2V0RGF0YS54LFxuICAgICAgaW5pdGlhbFkgPSBfdGhpcyRnZXREYXRhLnksXG4gICAgICBpbml0aWFsV2lkdGggPSBfdGhpcyRnZXREYXRhLndpZHRoLFxuICAgICAgaW5pdGlhbEhlaWdodCA9IF90aGlzJGdldERhdGEuaGVpZ2h0O1xuICAgIHZhciByYXRpbyA9IHNvdXJjZS53aWR0aCAvIE1hdGguZmxvb3IoY2FudmFzRGF0YS5uYXR1cmFsV2lkdGgpO1xuICAgIGlmIChyYXRpbyAhPT0gMSkge1xuICAgICAgaW5pdGlhbFggKj0gcmF0aW87XG4gICAgICBpbml0aWFsWSAqPSByYXRpbztcbiAgICAgIGluaXRpYWxXaWR0aCAqPSByYXRpbztcbiAgICAgIGluaXRpYWxIZWlnaHQgKj0gcmF0aW87XG4gICAgfVxuICAgIHZhciBhc3BlY3RSYXRpbyA9IGluaXRpYWxXaWR0aCAvIGluaXRpYWxIZWlnaHQ7XG4gICAgdmFyIG1heFNpemVzID0gZ2V0QWRqdXN0ZWRTaXplcyh7XG4gICAgICBhc3BlY3RSYXRpbzogYXNwZWN0UmF0aW8sXG4gICAgICB3aWR0aDogb3B0aW9ucy5tYXhXaWR0aCB8fCBJbmZpbml0eSxcbiAgICAgIGhlaWdodDogb3B0aW9ucy5tYXhIZWlnaHQgfHwgSW5maW5pdHlcbiAgICB9KTtcbiAgICB2YXIgbWluU2l6ZXMgPSBnZXRBZGp1c3RlZFNpemVzKHtcbiAgICAgIGFzcGVjdFJhdGlvOiBhc3BlY3RSYXRpbyxcbiAgICAgIHdpZHRoOiBvcHRpb25zLm1pbldpZHRoIHx8IDAsXG4gICAgICBoZWlnaHQ6IG9wdGlvbnMubWluSGVpZ2h0IHx8IDBcbiAgICB9LCAnY292ZXInKTtcbiAgICB2YXIgX2dldEFkanVzdGVkU2l6ZXMgPSBnZXRBZGp1c3RlZFNpemVzKHtcbiAgICAgICAgYXNwZWN0UmF0aW86IGFzcGVjdFJhdGlvLFxuICAgICAgICB3aWR0aDogb3B0aW9ucy53aWR0aCB8fCAocmF0aW8gIT09IDEgPyBzb3VyY2Uud2lkdGggOiBpbml0aWFsV2lkdGgpLFxuICAgICAgICBoZWlnaHQ6IG9wdGlvbnMuaGVpZ2h0IHx8IChyYXRpbyAhPT0gMSA/IHNvdXJjZS5oZWlnaHQgOiBpbml0aWFsSGVpZ2h0KVxuICAgICAgfSksXG4gICAgICB3aWR0aCA9IF9nZXRBZGp1c3RlZFNpemVzLndpZHRoLFxuICAgICAgaGVpZ2h0ID0gX2dldEFkanVzdGVkU2l6ZXMuaGVpZ2h0O1xuICAgIHdpZHRoID0gTWF0aC5taW4obWF4U2l6ZXMud2lkdGgsIE1hdGgubWF4KG1pblNpemVzLndpZHRoLCB3aWR0aCkpO1xuICAgIGhlaWdodCA9IE1hdGgubWluKG1heFNpemVzLmhlaWdodCwgTWF0aC5tYXgobWluU2l6ZXMuaGVpZ2h0LCBoZWlnaHQpKTtcbiAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgdmFyIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICBjYW52YXMud2lkdGggPSBub3JtYWxpemVEZWNpbWFsTnVtYmVyKHdpZHRoKTtcbiAgICBjYW52YXMuaGVpZ2h0ID0gbm9ybWFsaXplRGVjaW1hbE51bWJlcihoZWlnaHQpO1xuICAgIGNvbnRleHQuZmlsbFN0eWxlID0gb3B0aW9ucy5maWxsQ29sb3IgfHwgJ3RyYW5zcGFyZW50JztcbiAgICBjb250ZXh0LmZpbGxSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgIHZhciBfb3B0aW9ucyRpbWFnZVNtb290aGkgPSBvcHRpb25zLmltYWdlU21vb3RoaW5nRW5hYmxlZCxcbiAgICAgIGltYWdlU21vb3RoaW5nRW5hYmxlZCA9IF9vcHRpb25zJGltYWdlU21vb3RoaSA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJGltYWdlU21vb3RoaSxcbiAgICAgIGltYWdlU21vb3RoaW5nUXVhbGl0eSA9IG9wdGlvbnMuaW1hZ2VTbW9vdGhpbmdRdWFsaXR5O1xuICAgIGNvbnRleHQuaW1hZ2VTbW9vdGhpbmdFbmFibGVkID0gaW1hZ2VTbW9vdGhpbmdFbmFibGVkO1xuICAgIGlmIChpbWFnZVNtb290aGluZ1F1YWxpdHkpIHtcbiAgICAgIGNvbnRleHQuaW1hZ2VTbW9vdGhpbmdRdWFsaXR5ID0gaW1hZ2VTbW9vdGhpbmdRdWFsaXR5O1xuICAgIH1cblxuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQuZHJhd0ltYWdlXG4gICAgdmFyIHNvdXJjZVdpZHRoID0gc291cmNlLndpZHRoO1xuICAgIHZhciBzb3VyY2VIZWlnaHQgPSBzb3VyY2UuaGVpZ2h0O1xuXG4gICAgLy8gU291cmNlIGNhbnZhcyBwYXJhbWV0ZXJzXG4gICAgdmFyIHNyY1ggPSBpbml0aWFsWDtcbiAgICB2YXIgc3JjWSA9IGluaXRpYWxZO1xuICAgIHZhciBzcmNXaWR0aDtcbiAgICB2YXIgc3JjSGVpZ2h0O1xuXG4gICAgLy8gRGVzdGluYXRpb24gY2FudmFzIHBhcmFtZXRlcnNcbiAgICB2YXIgZHN0WDtcbiAgICB2YXIgZHN0WTtcbiAgICB2YXIgZHN0V2lkdGg7XG4gICAgdmFyIGRzdEhlaWdodDtcbiAgICBpZiAoc3JjWCA8PSAtaW5pdGlhbFdpZHRoIHx8IHNyY1ggPiBzb3VyY2VXaWR0aCkge1xuICAgICAgc3JjWCA9IDA7XG4gICAgICBzcmNXaWR0aCA9IDA7XG4gICAgICBkc3RYID0gMDtcbiAgICAgIGRzdFdpZHRoID0gMDtcbiAgICB9IGVsc2UgaWYgKHNyY1ggPD0gMCkge1xuICAgICAgZHN0WCA9IC1zcmNYO1xuICAgICAgc3JjWCA9IDA7XG4gICAgICBzcmNXaWR0aCA9IE1hdGgubWluKHNvdXJjZVdpZHRoLCBpbml0aWFsV2lkdGggKyBzcmNYKTtcbiAgICAgIGRzdFdpZHRoID0gc3JjV2lkdGg7XG4gICAgfSBlbHNlIGlmIChzcmNYIDw9IHNvdXJjZVdpZHRoKSB7XG4gICAgICBkc3RYID0gMDtcbiAgICAgIHNyY1dpZHRoID0gTWF0aC5taW4oaW5pdGlhbFdpZHRoLCBzb3VyY2VXaWR0aCAtIHNyY1gpO1xuICAgICAgZHN0V2lkdGggPSBzcmNXaWR0aDtcbiAgICB9XG4gICAgaWYgKHNyY1dpZHRoIDw9IDAgfHwgc3JjWSA8PSAtaW5pdGlhbEhlaWdodCB8fCBzcmNZID4gc291cmNlSGVpZ2h0KSB7XG4gICAgICBzcmNZID0gMDtcbiAgICAgIHNyY0hlaWdodCA9IDA7XG4gICAgICBkc3RZID0gMDtcbiAgICAgIGRzdEhlaWdodCA9IDA7XG4gICAgfSBlbHNlIGlmIChzcmNZIDw9IDApIHtcbiAgICAgIGRzdFkgPSAtc3JjWTtcbiAgICAgIHNyY1kgPSAwO1xuICAgICAgc3JjSGVpZ2h0ID0gTWF0aC5taW4oc291cmNlSGVpZ2h0LCBpbml0aWFsSGVpZ2h0ICsgc3JjWSk7XG4gICAgICBkc3RIZWlnaHQgPSBzcmNIZWlnaHQ7XG4gICAgfSBlbHNlIGlmIChzcmNZIDw9IHNvdXJjZUhlaWdodCkge1xuICAgICAgZHN0WSA9IDA7XG4gICAgICBzcmNIZWlnaHQgPSBNYXRoLm1pbihpbml0aWFsSGVpZ2h0LCBzb3VyY2VIZWlnaHQgLSBzcmNZKTtcbiAgICAgIGRzdEhlaWdodCA9IHNyY0hlaWdodDtcbiAgICB9XG4gICAgdmFyIHBhcmFtcyA9IFtzcmNYLCBzcmNZLCBzcmNXaWR0aCwgc3JjSGVpZ2h0XTtcblxuICAgIC8vIEF2b2lkIFwiSW5kZXhTaXplRXJyb3JcIlxuICAgIGlmIChkc3RXaWR0aCA+IDAgJiYgZHN0SGVpZ2h0ID4gMCkge1xuICAgICAgdmFyIHNjYWxlID0gd2lkdGggLyBpbml0aWFsV2lkdGg7XG4gICAgICBwYXJhbXMucHVzaChkc3RYICogc2NhbGUsIGRzdFkgKiBzY2FsZSwgZHN0V2lkdGggKiBzY2FsZSwgZHN0SGVpZ2h0ICogc2NhbGUpO1xuICAgIH1cblxuICAgIC8vIEFsbCB0aGUgbnVtZXJpY2FsIHBhcmFtZXRlcnMgc2hvdWxkIGJlIGludGVnZXIgZm9yIGBkcmF3SW1hZ2VgXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2Zlbmd5dWFuY2hlbi9jcm9wcGVyL2lzc3Vlcy80NzZcbiAgICBjb250ZXh0LmRyYXdJbWFnZS5hcHBseShjb250ZXh0LCBbc291cmNlXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KHBhcmFtcy5tYXAoZnVuY3Rpb24gKHBhcmFtKSB7XG4gICAgICByZXR1cm4gTWF0aC5mbG9vcihub3JtYWxpemVEZWNpbWFsTnVtYmVyKHBhcmFtKSk7XG4gICAgfSkpKSk7XG4gICAgcmV0dXJuIGNhbnZhcztcbiAgfSxcbiAgLyoqXG4gICAqIENoYW5nZSB0aGUgYXNwZWN0IHJhdGlvIG9mIHRoZSBjcm9wIGJveC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGFzcGVjdFJhdGlvIC0gVGhlIG5ldyBhc3BlY3QgcmF0aW8uXG4gICAqIEByZXR1cm5zIHtDcm9wcGVyfSB0aGlzXG4gICAqL1xuICBzZXRBc3BlY3RSYXRpbzogZnVuY3Rpb24gc2V0QXNwZWN0UmF0aW8oYXNwZWN0UmF0aW8pIHtcbiAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBpZiAoIXRoaXMuZGlzYWJsZWQgJiYgIWlzVW5kZWZpbmVkKGFzcGVjdFJhdGlvKSkge1xuICAgICAgLy8gMCAtPiBOYU5cbiAgICAgIG9wdGlvbnMuYXNwZWN0UmF0aW8gPSBNYXRoLm1heCgwLCBhc3BlY3RSYXRpbykgfHwgTmFOO1xuICAgICAgaWYgKHRoaXMucmVhZHkpIHtcbiAgICAgICAgdGhpcy5pbml0Q3JvcEJveCgpO1xuICAgICAgICBpZiAodGhpcy5jcm9wcGVkKSB7XG4gICAgICAgICAgdGhpcy5yZW5kZXJDcm9wQm94KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIC8qKlxuICAgKiBDaGFuZ2UgdGhlIGRyYWcgbW9kZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG1vZGUgLSBUaGUgbmV3IGRyYWcgbW9kZS5cbiAgICogQHJldHVybnMge0Nyb3BwZXJ9IHRoaXNcbiAgICovXG4gIHNldERyYWdNb2RlOiBmdW5jdGlvbiBzZXREcmFnTW9kZShtb2RlKSB7XG4gICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG4gICAgICBkcmFnQm94ID0gdGhpcy5kcmFnQm94LFxuICAgICAgZmFjZSA9IHRoaXMuZmFjZTtcbiAgICBpZiAodGhpcy5yZWFkeSAmJiAhdGhpcy5kaXNhYmxlZCkge1xuICAgICAgdmFyIGNyb3BwYWJsZSA9IG1vZGUgPT09IERSQUdfTU9ERV9DUk9QO1xuICAgICAgdmFyIG1vdmFibGUgPSBvcHRpb25zLm1vdmFibGUgJiYgbW9kZSA9PT0gRFJBR19NT0RFX01PVkU7XG4gICAgICBtb2RlID0gY3JvcHBhYmxlIHx8IG1vdmFibGUgPyBtb2RlIDogRFJBR19NT0RFX05PTkU7XG4gICAgICBvcHRpb25zLmRyYWdNb2RlID0gbW9kZTtcbiAgICAgIHNldERhdGEoZHJhZ0JveCwgREFUQV9BQ1RJT04sIG1vZGUpO1xuICAgICAgdG9nZ2xlQ2xhc3MoZHJhZ0JveCwgQ0xBU1NfQ1JPUCwgY3JvcHBhYmxlKTtcbiAgICAgIHRvZ2dsZUNsYXNzKGRyYWdCb3gsIENMQVNTX01PVkUsIG1vdmFibGUpO1xuICAgICAgaWYgKCFvcHRpb25zLmNyb3BCb3hNb3ZhYmxlKSB7XG4gICAgICAgIC8vIFN5bmMgZHJhZyBtb2RlIHRvIGNyb3AgYm94IHdoZW4gaXQgaXMgbm90IG1vdmFibGVcbiAgICAgICAgc2V0RGF0YShmYWNlLCBEQVRBX0FDVElPTiwgbW9kZSk7XG4gICAgICAgIHRvZ2dsZUNsYXNzKGZhY2UsIENMQVNTX0NST1AsIGNyb3BwYWJsZSk7XG4gICAgICAgIHRvZ2dsZUNsYXNzKGZhY2UsIENMQVNTX01PVkUsIG1vdmFibGUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxufTtcblxudmFyIEFub3RoZXJDcm9wcGVyID0gV0lORE9XLkNyb3BwZXI7XG52YXIgQ3JvcHBlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgQ3JvcHBlci5cbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IC0gVGhlIHRhcmdldCBlbGVtZW50IGZvciBjcm9wcGluZy5cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSAtIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMuXG4gICAqL1xuICBmdW5jdGlvbiBDcm9wcGVyKGVsZW1lbnQpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENyb3BwZXIpO1xuICAgIGlmICghZWxlbWVudCB8fCAhUkVHRVhQX1RBR19OQU1FLnRlc3QoZWxlbWVudC50YWdOYW1lKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgZmlyc3QgYXJndW1lbnQgaXMgcmVxdWlyZWQgYW5kIG11c3QgYmUgYW4gPGltZz4gb3IgPGNhbnZhcz4gZWxlbWVudC4nKTtcbiAgICB9XG4gICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICB0aGlzLm9wdGlvbnMgPSBhc3NpZ24oe30sIERFRkFVTFRTLCBpc1BsYWluT2JqZWN0KG9wdGlvbnMpICYmIG9wdGlvbnMpO1xuICAgIHRoaXMuY3JvcHBlZCA9IGZhbHNlO1xuICAgIHRoaXMuZGlzYWJsZWQgPSBmYWxzZTtcbiAgICB0aGlzLnBvaW50ZXJzID0ge307XG4gICAgdGhpcy5yZWFkeSA9IGZhbHNlO1xuICAgIHRoaXMucmVsb2FkaW5nID0gZmFsc2U7XG4gICAgdGhpcy5yZXBsYWNlZCA9IGZhbHNlO1xuICAgIHRoaXMuc2l6ZWQgPSBmYWxzZTtcbiAgICB0aGlzLnNpemluZyA9IGZhbHNlO1xuICAgIHRoaXMuaW5pdCgpO1xuICB9XG4gIF9jcmVhdGVDbGFzcyhDcm9wcGVyLCBbe1xuICAgIGtleTogXCJpbml0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgICB2YXIgZWxlbWVudCA9IHRoaXMuZWxlbWVudDtcbiAgICAgIHZhciB0YWdOYW1lID0gZWxlbWVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICB2YXIgdXJsO1xuICAgICAgaWYgKGVsZW1lbnRbTkFNRVNQQUNFXSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBlbGVtZW50W05BTUVTUEFDRV0gPSB0aGlzO1xuICAgICAgaWYgKHRhZ05hbWUgPT09ICdpbWcnKSB7XG4gICAgICAgIHRoaXMuaXNJbWcgPSB0cnVlO1xuXG4gICAgICAgIC8vIGUuZy46IFwiaW1nL3BpY3R1cmUuanBnXCJcbiAgICAgICAgdXJsID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3NyYycpIHx8ICcnO1xuICAgICAgICB0aGlzLm9yaWdpbmFsVXJsID0gdXJsO1xuXG4gICAgICAgIC8vIFN0b3Agd2hlbiBpdCdzIGEgYmxhbmsgaW1hZ2VcbiAgICAgICAgaWYgKCF1cmwpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBlLmcuOiBcImh0dHBzOi8vZXhhbXBsZS5jb20vaW1nL3BpY3R1cmUuanBnXCJcbiAgICAgICAgdXJsID0gZWxlbWVudC5zcmM7XG4gICAgICB9IGVsc2UgaWYgKHRhZ05hbWUgPT09ICdjYW52YXMnICYmIHdpbmRvdy5IVE1MQ2FudmFzRWxlbWVudCkge1xuICAgICAgICB1cmwgPSBlbGVtZW50LnRvRGF0YVVSTCgpO1xuICAgICAgfVxuICAgICAgdGhpcy5sb2FkKHVybCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImxvYWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbG9hZCh1cmwpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICBpZiAoIXVybCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLnVybCA9IHVybDtcbiAgICAgIHRoaXMuaW1hZ2VEYXRhID0ge307XG4gICAgICB2YXIgZWxlbWVudCA9IHRoaXMuZWxlbWVudCxcbiAgICAgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICAgIGlmICghb3B0aW9ucy5yb3RhdGFibGUgJiYgIW9wdGlvbnMuc2NhbGFibGUpIHtcbiAgICAgICAgb3B0aW9ucy5jaGVja09yaWVudGF0aW9uID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8vIE9ubHkgSUUxMCsgc3VwcG9ydHMgVHlwZWQgQXJyYXlzXG4gICAgICBpZiAoIW9wdGlvbnMuY2hlY2tPcmllbnRhdGlvbiB8fCAhd2luZG93LkFycmF5QnVmZmVyKSB7XG4gICAgICAgIHRoaXMuY2xvbmUoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBEZXRlY3QgdGhlIG1pbWUgdHlwZSBvZiB0aGUgaW1hZ2UgZGlyZWN0bHkgaWYgaXQgaXMgYSBEYXRhIFVSTFxuICAgICAgaWYgKFJFR0VYUF9EQVRBX1VSTC50ZXN0KHVybCkpIHtcbiAgICAgICAgLy8gUmVhZCBBcnJheUJ1ZmZlciBmcm9tIERhdGEgVVJMIG9mIEpQRUcgaW1hZ2VzIGRpcmVjdGx5IGZvciBiZXR0ZXIgcGVyZm9ybWFuY2VcbiAgICAgICAgaWYgKFJFR0VYUF9EQVRBX1VSTF9KUEVHLnRlc3QodXJsKSkge1xuICAgICAgICAgIHRoaXMucmVhZChkYXRhVVJMVG9BcnJheUJ1ZmZlcih1cmwpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBPbmx5IGEgSlBFRyBpbWFnZSBtYXkgY29udGFpbnMgRXhpZiBPcmllbnRhdGlvbiBpbmZvcm1hdGlvbixcbiAgICAgICAgICAvLyB0aGUgcmVzdCB0eXBlcyBvZiBEYXRhIFVSTHMgYXJlIG5vdCBuZWNlc3NhcnkgdG8gY2hlY2sgb3JpZW50YXRpb24gYXQgYWxsLlxuICAgICAgICAgIHRoaXMuY2xvbmUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIDEuIERldGVjdCB0aGUgbWltZSB0eXBlIG9mIHRoZSBpbWFnZSBieSBhIFhNTEh0dHBSZXF1ZXN0LlxuICAgICAgLy8gMi4gTG9hZCB0aGUgaW1hZ2UgYXMgQXJyYXlCdWZmZXIgZm9yIHJlYWRpbmcgb3JpZW50YXRpb24gaWYgaXRzIGEgSlBFRyBpbWFnZS5cbiAgICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgIHZhciBjbG9uZSA9IHRoaXMuY2xvbmUuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMucmVsb2FkaW5nID0gdHJ1ZTtcbiAgICAgIHRoaXMueGhyID0geGhyO1xuXG4gICAgICAvLyAxLiBDcm9zcyBvcmlnaW4gcmVxdWVzdHMgYXJlIG9ubHkgc3VwcG9ydGVkIGZvciBwcm90b2NvbCBzY2hlbWVzOlxuICAgICAgLy8gaHR0cCwgaHR0cHMsIGRhdGEsIGNocm9tZSwgY2hyb21lLWV4dGVuc2lvbi5cbiAgICAgIC8vIDIuIEFjY2VzcyB0byBYTUxIdHRwUmVxdWVzdCBmcm9tIGEgRGF0YSBVUkwgd2lsbCBiZSBibG9ja2VkIGJ5IENPUlMgcG9saWN5XG4gICAgICAvLyBpbiBzb21lIGJyb3dzZXJzIGFzIElFMTEgYW5kIFNhZmFyaS5cbiAgICAgIHhoci5vbmFib3J0ID0gY2xvbmU7XG4gICAgICB4aHIub25lcnJvciA9IGNsb25lO1xuICAgICAgeGhyLm9udGltZW91dCA9IGNsb25lO1xuICAgICAgeGhyLm9ucHJvZ3Jlc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIEFib3J0IHRoZSByZXF1ZXN0IGRpcmVjdGx5IGlmIGl0IG5vdCBhIEpQRUcgaW1hZ2UgZm9yIGJldHRlciBwZXJmb3JtYW5jZVxuICAgICAgICBpZiAoeGhyLmdldFJlc3BvbnNlSGVhZGVyKCdjb250ZW50LXR5cGUnKSAhPT0gTUlNRV9UWVBFX0pQRUcpIHtcbiAgICAgICAgICB4aHIuYWJvcnQoKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHhoci5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzLnJlYWQoeGhyLnJlc3BvbnNlKTtcbiAgICAgIH07XG4gICAgICB4aHIub25sb2FkZW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpcy5yZWxvYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgX3RoaXMueGhyID0gbnVsbDtcbiAgICAgIH07XG5cbiAgICAgIC8vIEJ1c3QgY2FjaGUgd2hlbiB0aGVyZSBpcyBhIFwiY3Jvc3NPcmlnaW5cIiBwcm9wZXJ0eSB0byBhdm9pZCBicm93c2VyIGNhY2hlIGVycm9yXG4gICAgICBpZiAob3B0aW9ucy5jaGVja0Nyb3NzT3JpZ2luICYmIGlzQ3Jvc3NPcmlnaW5VUkwodXJsKSAmJiBlbGVtZW50LmNyb3NzT3JpZ2luKSB7XG4gICAgICAgIHVybCA9IGFkZFRpbWVzdGFtcCh1cmwpO1xuICAgICAgfVxuXG4gICAgICAvLyBUaGUgdGhpcmQgcGFyYW1ldGVyIGlzIHJlcXVpcmVkIGZvciBhdm9pZGluZyBzaWRlLWVmZmVjdCAoIzY4MilcbiAgICAgIHhoci5vcGVuKCdHRVQnLCB1cmwsIHRydWUpO1xuICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9ICdhcnJheWJ1ZmZlcic7XG4gICAgICB4aHIud2l0aENyZWRlbnRpYWxzID0gZWxlbWVudC5jcm9zc09yaWdpbiA9PT0gJ3VzZS1jcmVkZW50aWFscyc7XG4gICAgICB4aHIuc2VuZCgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZWFkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlYWQoYXJyYXlCdWZmZXIpIHtcbiAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuICAgICAgICBpbWFnZURhdGEgPSB0aGlzLmltYWdlRGF0YTtcblxuICAgICAgLy8gUmVzZXQgdGhlIG9yaWVudGF0aW9uIHZhbHVlIHRvIGl0cyBkZWZhdWx0IHZhbHVlIDFcbiAgICAgIC8vIGFzIHNvbWUgaU9TIGJyb3dzZXJzIHdpbGwgcmVuZGVyIGltYWdlIHdpdGggaXRzIG9yaWVudGF0aW9uXG4gICAgICB2YXIgb3JpZW50YXRpb24gPSByZXNldEFuZEdldE9yaWVudGF0aW9uKGFycmF5QnVmZmVyKTtcbiAgICAgIHZhciByb3RhdGUgPSAwO1xuICAgICAgdmFyIHNjYWxlWCA9IDE7XG4gICAgICB2YXIgc2NhbGVZID0gMTtcbiAgICAgIGlmIChvcmllbnRhdGlvbiA+IDEpIHtcbiAgICAgICAgLy8gR2VuZXJhdGUgYSBuZXcgVVJMIHdoaWNoIGhhcyB0aGUgZGVmYXVsdCBvcmllbnRhdGlvbiB2YWx1ZVxuICAgICAgICB0aGlzLnVybCA9IGFycmF5QnVmZmVyVG9EYXRhVVJMKGFycmF5QnVmZmVyLCBNSU1FX1RZUEVfSlBFRyk7XG4gICAgICAgIHZhciBfcGFyc2VPcmllbnRhdGlvbiA9IHBhcnNlT3JpZW50YXRpb24ob3JpZW50YXRpb24pO1xuICAgICAgICByb3RhdGUgPSBfcGFyc2VPcmllbnRhdGlvbi5yb3RhdGU7XG4gICAgICAgIHNjYWxlWCA9IF9wYXJzZU9yaWVudGF0aW9uLnNjYWxlWDtcbiAgICAgICAgc2NhbGVZID0gX3BhcnNlT3JpZW50YXRpb24uc2NhbGVZO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMucm90YXRhYmxlKSB7XG4gICAgICAgIGltYWdlRGF0YS5yb3RhdGUgPSByb3RhdGU7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5zY2FsYWJsZSkge1xuICAgICAgICBpbWFnZURhdGEuc2NhbGVYID0gc2NhbGVYO1xuICAgICAgICBpbWFnZURhdGEuc2NhbGVZID0gc2NhbGVZO1xuICAgICAgfVxuICAgICAgdGhpcy5jbG9uZSgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjbG9uZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9uZSgpIHtcbiAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5lbGVtZW50LFxuICAgICAgICB1cmwgPSB0aGlzLnVybDtcbiAgICAgIHZhciBjcm9zc09yaWdpbiA9IGVsZW1lbnQuY3Jvc3NPcmlnaW47XG4gICAgICB2YXIgY3Jvc3NPcmlnaW5VcmwgPSB1cmw7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmNoZWNrQ3Jvc3NPcmlnaW4gJiYgaXNDcm9zc09yaWdpblVSTCh1cmwpKSB7XG4gICAgICAgIGlmICghY3Jvc3NPcmlnaW4pIHtcbiAgICAgICAgICBjcm9zc09yaWdpbiA9ICdhbm9ueW1vdXMnO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQnVzdCBjYWNoZSB3aGVuIHRoZXJlIGlzIG5vdCBhIFwiY3Jvc3NPcmlnaW5cIiBwcm9wZXJ0eSAoIzUxOSlcbiAgICAgICAgY3Jvc3NPcmlnaW5VcmwgPSBhZGRUaW1lc3RhbXAodXJsKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY3Jvc3NPcmlnaW4gPSBjcm9zc09yaWdpbjtcbiAgICAgIHRoaXMuY3Jvc3NPcmlnaW5VcmwgPSBjcm9zc09yaWdpblVybDtcbiAgICAgIHZhciBpbWFnZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2ltZycpO1xuICAgICAgaWYgKGNyb3NzT3JpZ2luKSB7XG4gICAgICAgIGltYWdlLmNyb3NzT3JpZ2luID0gY3Jvc3NPcmlnaW47XG4gICAgICB9XG4gICAgICBpbWFnZS5zcmMgPSBjcm9zc09yaWdpblVybCB8fCB1cmw7XG4gICAgICBpbWFnZS5hbHQgPSBlbGVtZW50LmFsdCB8fCAnVGhlIGltYWdlIHRvIGNyb3AnO1xuICAgICAgdGhpcy5pbWFnZSA9IGltYWdlO1xuICAgICAgaW1hZ2Uub25sb2FkID0gdGhpcy5zdGFydC5iaW5kKHRoaXMpO1xuICAgICAgaW1hZ2Uub25lcnJvciA9IHRoaXMuc3RvcC5iaW5kKHRoaXMpO1xuICAgICAgYWRkQ2xhc3MoaW1hZ2UsIENMQVNTX0hJREUpO1xuICAgICAgZWxlbWVudC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShpbWFnZSwgZWxlbWVudC5uZXh0U2libGluZyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInN0YXJ0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0YXJ0KCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG4gICAgICB2YXIgaW1hZ2UgPSB0aGlzLmltYWdlO1xuICAgICAgaW1hZ2Uub25sb2FkID0gbnVsbDtcbiAgICAgIGltYWdlLm9uZXJyb3IgPSBudWxsO1xuICAgICAgdGhpcy5zaXppbmcgPSB0cnVlO1xuXG4gICAgICAvLyBNYXRjaCBhbGwgYnJvd3NlcnMgdGhhdCB1c2UgV2ViS2l0IGFzIHRoZSBsYXlvdXQgZW5naW5lIGluIGlPUyBkZXZpY2VzLFxuICAgICAgLy8gc3VjaCBhcyBTYWZhcmkgZm9yIGlPUywgQ2hyb21lIGZvciBpT1MsIGFuZCBpbi1hcHAgYnJvd3NlcnMuXG4gICAgICB2YXIgaXNJT1NXZWJLaXQgPSBXSU5ET1cubmF2aWdhdG9yICYmIC8oPzppUGFkfGlQaG9uZXxpUG9kKS4qP0FwcGxlV2ViS2l0L2kudGVzdChXSU5ET1cubmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gICAgICB2YXIgZG9uZSA9IGZ1bmN0aW9uIGRvbmUobmF0dXJhbFdpZHRoLCBuYXR1cmFsSGVpZ2h0KSB7XG4gICAgICAgIGFzc2lnbihfdGhpczIuaW1hZ2VEYXRhLCB7XG4gICAgICAgICAgbmF0dXJhbFdpZHRoOiBuYXR1cmFsV2lkdGgsXG4gICAgICAgICAgbmF0dXJhbEhlaWdodDogbmF0dXJhbEhlaWdodCxcbiAgICAgICAgICBhc3BlY3RSYXRpbzogbmF0dXJhbFdpZHRoIC8gbmF0dXJhbEhlaWdodFxuICAgICAgICB9KTtcbiAgICAgICAgX3RoaXMyLmluaXRpYWxJbWFnZURhdGEgPSBhc3NpZ24oe30sIF90aGlzMi5pbWFnZURhdGEpO1xuICAgICAgICBfdGhpczIuc2l6aW5nID0gZmFsc2U7XG4gICAgICAgIF90aGlzMi5zaXplZCA9IHRydWU7XG4gICAgICAgIF90aGlzMi5idWlsZCgpO1xuICAgICAgfTtcblxuICAgICAgLy8gTW9zdCBtb2Rlcm4gYnJvd3NlcnMgKGV4Y2VwdHMgaU9TIFdlYktpdClcbiAgICAgIGlmIChpbWFnZS5uYXR1cmFsV2lkdGggJiYgIWlzSU9TV2ViS2l0KSB7XG4gICAgICAgIGRvbmUoaW1hZ2UubmF0dXJhbFdpZHRoLCBpbWFnZS5uYXR1cmFsSGVpZ2h0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIHNpemluZ0ltYWdlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJyk7XG4gICAgICB2YXIgYm9keSA9IGRvY3VtZW50LmJvZHkgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgdGhpcy5zaXppbmdJbWFnZSA9IHNpemluZ0ltYWdlO1xuICAgICAgc2l6aW5nSW1hZ2Uub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBkb25lKHNpemluZ0ltYWdlLndpZHRoLCBzaXppbmdJbWFnZS5oZWlnaHQpO1xuICAgICAgICBpZiAoIWlzSU9TV2ViS2l0KSB7XG4gICAgICAgICAgYm9keS5yZW1vdmVDaGlsZChzaXppbmdJbWFnZSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBzaXppbmdJbWFnZS5zcmMgPSBpbWFnZS5zcmM7XG5cbiAgICAgIC8vIGlPUyBXZWJLaXQgd2lsbCBjb252ZXJ0IHRoZSBpbWFnZSBhdXRvbWF0aWNhbGx5XG4gICAgICAvLyB3aXRoIGl0cyBvcmllbnRhdGlvbiBvbmNlIGFwcGVuZCBpdCBpbnRvIERPTSAoIzI3OSlcbiAgICAgIGlmICghaXNJT1NXZWJLaXQpIHtcbiAgICAgICAgc2l6aW5nSW1hZ2Uuc3R5bGUuY3NzVGV4dCA9ICdsZWZ0OjA7JyArICdtYXgtaGVpZ2h0Om5vbmUhaW1wb3J0YW50OycgKyAnbWF4LXdpZHRoOm5vbmUhaW1wb3J0YW50OycgKyAnbWluLWhlaWdodDowIWltcG9ydGFudDsnICsgJ21pbi13aWR0aDowIWltcG9ydGFudDsnICsgJ29wYWNpdHk6MDsnICsgJ3Bvc2l0aW9uOmFic29sdXRlOycgKyAndG9wOjA7JyArICd6LWluZGV4Oi0xOyc7XG4gICAgICAgIGJvZHkuYXBwZW5kQ2hpbGQoc2l6aW5nSW1hZ2UpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzdG9wXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0b3AoKSB7XG4gICAgICB2YXIgaW1hZ2UgPSB0aGlzLmltYWdlO1xuICAgICAgaW1hZ2Uub25sb2FkID0gbnVsbDtcbiAgICAgIGltYWdlLm9uZXJyb3IgPSBudWxsO1xuICAgICAgaW1hZ2UucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChpbWFnZSk7XG4gICAgICB0aGlzLmltYWdlID0gbnVsbDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYnVpbGRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYnVpbGQoKSB7XG4gICAgICBpZiAoIXRoaXMuc2l6ZWQgfHwgdGhpcy5yZWFkeSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgZWxlbWVudCA9IHRoaXMuZWxlbWVudCxcbiAgICAgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgaW1hZ2UgPSB0aGlzLmltYWdlO1xuXG4gICAgICAvLyBDcmVhdGUgY3JvcHBlciBlbGVtZW50c1xuICAgICAgdmFyIGNvbnRhaW5lciA9IGVsZW1lbnQucGFyZW50Tm9kZTtcbiAgICAgIHZhciB0ZW1wbGF0ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgdGVtcGxhdGUuaW5uZXJIVE1MID0gVEVNUExBVEU7XG4gICAgICB2YXIgY3JvcHBlciA9IHRlbXBsYXRlLnF1ZXJ5U2VsZWN0b3IoXCIuXCIuY29uY2F0KE5BTUVTUEFDRSwgXCItY29udGFpbmVyXCIpKTtcbiAgICAgIHZhciBjYW52YXMgPSBjcm9wcGVyLnF1ZXJ5U2VsZWN0b3IoXCIuXCIuY29uY2F0KE5BTUVTUEFDRSwgXCItY2FudmFzXCIpKTtcbiAgICAgIHZhciBkcmFnQm94ID0gY3JvcHBlci5xdWVyeVNlbGVjdG9yKFwiLlwiLmNvbmNhdChOQU1FU1BBQ0UsIFwiLWRyYWctYm94XCIpKTtcbiAgICAgIHZhciBjcm9wQm94ID0gY3JvcHBlci5xdWVyeVNlbGVjdG9yKFwiLlwiLmNvbmNhdChOQU1FU1BBQ0UsIFwiLWNyb3AtYm94XCIpKTtcbiAgICAgIHZhciBmYWNlID0gY3JvcEJveC5xdWVyeVNlbGVjdG9yKFwiLlwiLmNvbmNhdChOQU1FU1BBQ0UsIFwiLWZhY2VcIikpO1xuICAgICAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XG4gICAgICB0aGlzLmNyb3BwZXIgPSBjcm9wcGVyO1xuICAgICAgdGhpcy5jYW52YXMgPSBjYW52YXM7XG4gICAgICB0aGlzLmRyYWdCb3ggPSBkcmFnQm94O1xuICAgICAgdGhpcy5jcm9wQm94ID0gY3JvcEJveDtcbiAgICAgIHRoaXMudmlld0JveCA9IGNyb3BwZXIucXVlcnlTZWxlY3RvcihcIi5cIi5jb25jYXQoTkFNRVNQQUNFLCBcIi12aWV3LWJveFwiKSk7XG4gICAgICB0aGlzLmZhY2UgPSBmYWNlO1xuICAgICAgY2FudmFzLmFwcGVuZENoaWxkKGltYWdlKTtcblxuICAgICAgLy8gSGlkZSB0aGUgb3JpZ2luYWwgaW1hZ2VcbiAgICAgIGFkZENsYXNzKGVsZW1lbnQsIENMQVNTX0hJRERFTik7XG5cbiAgICAgIC8vIEluc2VydHMgdGhlIGNyb3BwZXIgYWZ0ZXIgdG8gdGhlIGN1cnJlbnQgaW1hZ2VcbiAgICAgIGNvbnRhaW5lci5pbnNlcnRCZWZvcmUoY3JvcHBlciwgZWxlbWVudC5uZXh0U2libGluZyk7XG5cbiAgICAgIC8vIFNob3cgdGhlIGhpZGRlbiBpbWFnZVxuICAgICAgcmVtb3ZlQ2xhc3MoaW1hZ2UsIENMQVNTX0hJREUpO1xuICAgICAgdGhpcy5pbml0UHJldmlldygpO1xuICAgICAgdGhpcy5iaW5kKCk7XG4gICAgICBvcHRpb25zLmluaXRpYWxBc3BlY3RSYXRpbyA9IE1hdGgubWF4KDAsIG9wdGlvbnMuaW5pdGlhbEFzcGVjdFJhdGlvKSB8fCBOYU47XG4gICAgICBvcHRpb25zLmFzcGVjdFJhdGlvID0gTWF0aC5tYXgoMCwgb3B0aW9ucy5hc3BlY3RSYXRpbykgfHwgTmFOO1xuICAgICAgb3B0aW9ucy52aWV3TW9kZSA9IE1hdGgubWF4KDAsIE1hdGgubWluKDMsIE1hdGgucm91bmQob3B0aW9ucy52aWV3TW9kZSkpKSB8fCAwO1xuICAgICAgYWRkQ2xhc3MoY3JvcEJveCwgQ0xBU1NfSElEREVOKTtcbiAgICAgIGlmICghb3B0aW9ucy5ndWlkZXMpIHtcbiAgICAgICAgYWRkQ2xhc3MoY3JvcEJveC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKFwiXCIuY29uY2F0KE5BTUVTUEFDRSwgXCItZGFzaGVkXCIpKSwgQ0xBU1NfSElEREVOKTtcbiAgICAgIH1cbiAgICAgIGlmICghb3B0aW9ucy5jZW50ZXIpIHtcbiAgICAgICAgYWRkQ2xhc3MoY3JvcEJveC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKFwiXCIuY29uY2F0KE5BTUVTUEFDRSwgXCItY2VudGVyXCIpKSwgQ0xBU1NfSElEREVOKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLmJhY2tncm91bmQpIHtcbiAgICAgICAgYWRkQ2xhc3MoY3JvcHBlciwgXCJcIi5jb25jYXQoTkFNRVNQQUNFLCBcIi1iZ1wiKSk7XG4gICAgICB9XG4gICAgICBpZiAoIW9wdGlvbnMuaGlnaGxpZ2h0KSB7XG4gICAgICAgIGFkZENsYXNzKGZhY2UsIENMQVNTX0lOVklTSUJMRSk7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5jcm9wQm94TW92YWJsZSkge1xuICAgICAgICBhZGRDbGFzcyhmYWNlLCBDTEFTU19NT1ZFKTtcbiAgICAgICAgc2V0RGF0YShmYWNlLCBEQVRBX0FDVElPTiwgQUNUSU9OX0FMTCk7XG4gICAgICB9XG4gICAgICBpZiAoIW9wdGlvbnMuY3JvcEJveFJlc2l6YWJsZSkge1xuICAgICAgICBhZGRDbGFzcyhjcm9wQm94LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoXCJcIi5jb25jYXQoTkFNRVNQQUNFLCBcIi1saW5lXCIpKSwgQ0xBU1NfSElEREVOKTtcbiAgICAgICAgYWRkQ2xhc3MoY3JvcEJveC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKFwiXCIuY29uY2F0KE5BTUVTUEFDRSwgXCItcG9pbnRcIikpLCBDTEFTU19ISURERU4pO1xuICAgICAgfVxuICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICAgIHRoaXMucmVhZHkgPSB0cnVlO1xuICAgICAgdGhpcy5zZXREcmFnTW9kZShvcHRpb25zLmRyYWdNb2RlKTtcbiAgICAgIGlmIChvcHRpb25zLmF1dG9Dcm9wKSB7XG4gICAgICAgIHRoaXMuY3JvcCgpO1xuICAgICAgfVxuICAgICAgdGhpcy5zZXREYXRhKG9wdGlvbnMuZGF0YSk7XG4gICAgICBpZiAoaXNGdW5jdGlvbihvcHRpb25zLnJlYWR5KSkge1xuICAgICAgICBhZGRMaXN0ZW5lcihlbGVtZW50LCBFVkVOVF9SRUFEWSwgb3B0aW9ucy5yZWFkeSwge1xuICAgICAgICAgIG9uY2U6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBkaXNwYXRjaEV2ZW50KGVsZW1lbnQsIEVWRU5UX1JFQURZKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidW5idWlsZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1bmJ1aWxkKCkge1xuICAgICAgaWYgKCF0aGlzLnJlYWR5KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMucmVhZHkgPSBmYWxzZTtcbiAgICAgIHRoaXMudW5iaW5kKCk7XG4gICAgICB0aGlzLnJlc2V0UHJldmlldygpO1xuICAgICAgdmFyIHBhcmVudE5vZGUgPSB0aGlzLmNyb3BwZXIucGFyZW50Tm9kZTtcbiAgICAgIGlmIChwYXJlbnROb2RlKSB7XG4gICAgICAgIHBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5jcm9wcGVyKTtcbiAgICAgIH1cbiAgICAgIHJlbW92ZUNsYXNzKHRoaXMuZWxlbWVudCwgQ0xBU1NfSElEREVOKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidW5jcmVhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdW5jcmVhdGUoKSB7XG4gICAgICBpZiAodGhpcy5yZWFkeSkge1xuICAgICAgICB0aGlzLnVuYnVpbGQoKTtcbiAgICAgICAgdGhpcy5yZWFkeSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNyb3BwZWQgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5zaXppbmcpIHtcbiAgICAgICAgdGhpcy5zaXppbmdJbWFnZS5vbmxvYWQgPSBudWxsO1xuICAgICAgICB0aGlzLnNpemluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnNpemVkID0gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMucmVsb2FkaW5nKSB7XG4gICAgICAgIHRoaXMueGhyLm9uYWJvcnQgPSBudWxsO1xuICAgICAgICB0aGlzLnhoci5hYm9ydCgpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmltYWdlKSB7XG4gICAgICAgIHRoaXMuc3RvcCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgbm8gY29uZmxpY3QgY3JvcHBlciBjbGFzcy5cbiAgICAgKiBAcmV0dXJucyB7Q3JvcHBlcn0gVGhlIGNyb3BwZXIgY2xhc3MuXG4gICAgICovXG4gIH1dLCBbe1xuICAgIGtleTogXCJub0NvbmZsaWN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG5vQ29uZmxpY3QoKSB7XG4gICAgICB3aW5kb3cuQ3JvcHBlciA9IEFub3RoZXJDcm9wcGVyO1xuICAgICAgcmV0dXJuIENyb3BwZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hhbmdlIHRoZSBkZWZhdWx0IG9wdGlvbnMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBUaGUgbmV3IGRlZmF1bHQgb3B0aW9ucy5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJzZXREZWZhdWx0c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXREZWZhdWx0cyhvcHRpb25zKSB7XG4gICAgICBhc3NpZ24oREVGQVVMVFMsIGlzUGxhaW5PYmplY3Qob3B0aW9ucykgJiYgb3B0aW9ucyk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBDcm9wcGVyO1xufSgpO1xuYXNzaWduKENyb3BwZXIucHJvdG90eXBlLCByZW5kZXIsIHByZXZpZXcsIGV2ZW50cywgaGFuZGxlcnMsIGNoYW5nZSwgbWV0aG9kcyk7XG5cbmV4cG9ydCB7IENyb3BwZXIgYXMgZGVmYXVsdCB9O1xuIl0sIm5hbWVzIjpbIm93bktleXMiLCJlIiwiciIsInQiLCJPYmplY3QiLCJrZXlzIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwibyIsImZpbHRlciIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImVudW1lcmFibGUiLCJwdXNoIiwiYXBwbHkiLCJfb2JqZWN0U3ByZWFkMiIsImFyZ3VtZW50cyIsImxlbmd0aCIsImZvckVhY2giLCJfZGVmaW5lUHJvcGVydHkiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzIiwiZGVmaW5lUHJvcGVydGllcyIsImRlZmluZVByb3BlcnR5IiwiX3R5cGVvZiIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiY29uc3RydWN0b3IiLCJwcm90b3R5cGUiLCJfY2xhc3NDYWxsQ2hlY2siLCJpbnN0YW5jZSIsIkNvbnN0cnVjdG9yIiwiVHlwZUVycm9yIiwiX2RlZmluZVByb3BlcnRpZXMiLCJ0YXJnZXQiLCJwcm9wcyIsImkiLCJkZXNjcmlwdG9yIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJfdG9Qcm9wZXJ0eUtleSIsImtleSIsIl9jcmVhdGVDbGFzcyIsInByb3RvUHJvcHMiLCJzdGF0aWNQcm9wcyIsIm9iaiIsInZhbHVlIiwiX3RvQ29uc3VtYWJsZUFycmF5IiwiYXJyIiwiX2FycmF5V2l0aG91dEhvbGVzIiwiX2l0ZXJhYmxlVG9BcnJheSIsIl91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSIsIl9ub25JdGVyYWJsZVNwcmVhZCIsIkFycmF5IiwiaXNBcnJheSIsIl9hcnJheUxpa2VUb0FycmF5IiwiaXRlciIsImZyb20iLCJtaW5MZW4iLCJuIiwidG9TdHJpbmciLCJjYWxsIiwic2xpY2UiLCJuYW1lIiwidGVzdCIsImxlbiIsImFycjIiLCJfdG9QcmltaXRpdmUiLCJpbnB1dCIsImhpbnQiLCJwcmltIiwidG9QcmltaXRpdmUiLCJ1bmRlZmluZWQiLCJyZXMiLCJTdHJpbmciLCJOdW1iZXIiLCJhcmciLCJJU19CUk9XU0VSIiwid2luZG93IiwiZG9jdW1lbnQiLCJXSU5ET1ciLCJJU19UT1VDSF9ERVZJQ0UiLCJkb2N1bWVudEVsZW1lbnQiLCJIQVNfUE9JTlRFUl9FVkVOVCIsIk5BTUVTUEFDRSIsIkFDVElPTl9BTEwiLCJBQ1RJT05fQ1JPUCIsIkFDVElPTl9NT1ZFIiwiQUNUSU9OX1pPT00iLCJBQ1RJT05fRUFTVCIsIkFDVElPTl9XRVNUIiwiQUNUSU9OX1NPVVRIIiwiQUNUSU9OX05PUlRIIiwiQUNUSU9OX05PUlRIX0VBU1QiLCJBQ1RJT05fTk9SVEhfV0VTVCIsIkFDVElPTl9TT1VUSF9FQVNUIiwiQUNUSU9OX1NPVVRIX1dFU1QiLCJDTEFTU19DUk9QIiwiY29uY2F0IiwiQ0xBU1NfRElTQUJMRUQiLCJDTEFTU19ISURERU4iLCJDTEFTU19ISURFIiwiQ0xBU1NfSU5WSVNJQkxFIiwiQ0xBU1NfTU9EQUwiLCJDTEFTU19NT1ZFIiwiREFUQV9BQ1RJT04iLCJEQVRBX1BSRVZJRVciLCJEUkFHX01PREVfQ1JPUCIsIkRSQUdfTU9ERV9NT1ZFIiwiRFJBR19NT0RFX05PTkUiLCJFVkVOVF9DUk9QIiwiRVZFTlRfQ1JPUF9FTkQiLCJFVkVOVF9DUk9QX01PVkUiLCJFVkVOVF9DUk9QX1NUQVJUIiwiRVZFTlRfREJMQ0xJQ0siLCJFVkVOVF9UT1VDSF9TVEFSVCIsIkVWRU5UX1RPVUNIX01PVkUiLCJFVkVOVF9UT1VDSF9FTkQiLCJFVkVOVF9QT0lOVEVSX0RPV04iLCJFVkVOVF9QT0lOVEVSX01PVkUiLCJFVkVOVF9QT0lOVEVSX1VQIiwiRVZFTlRfUkVBRFkiLCJFVkVOVF9SRVNJWkUiLCJFVkVOVF9XSEVFTCIsIkVWRU5UX1pPT00iLCJNSU1FX1RZUEVfSlBFRyIsIlJFR0VYUF9BQ1RJT05TIiwiUkVHRVhQX0RBVEFfVVJMIiwiUkVHRVhQX0RBVEFfVVJMX0pQRUciLCJSRUdFWFBfVEFHX05BTUUiLCJNSU5fQ09OVEFJTkVSX1dJRFRIIiwiTUlOX0NPTlRBSU5FUl9IRUlHSFQiLCJERUZBVUxUUyIsInZpZXdNb2RlIiwiZHJhZ01vZGUiLCJpbml0aWFsQXNwZWN0UmF0aW8iLCJOYU4iLCJhc3BlY3RSYXRpbyIsImRhdGEiLCJwcmV2aWV3IiwicmVzcG9uc2l2ZSIsInJlc3RvcmUiLCJjaGVja0Nyb3NzT3JpZ2luIiwiY2hlY2tPcmllbnRhdGlvbiIsIm1vZGFsIiwiZ3VpZGVzIiwiY2VudGVyIiwiaGlnaGxpZ2h0IiwiYmFja2dyb3VuZCIsImF1dG9Dcm9wIiwiYXV0b0Nyb3BBcmVhIiwibW92YWJsZSIsInJvdGF0YWJsZSIsInNjYWxhYmxlIiwiem9vbWFibGUiLCJ6b29tT25Ub3VjaCIsInpvb21PbldoZWVsIiwid2hlZWxab29tUmF0aW8iLCJjcm9wQm94TW92YWJsZSIsImNyb3BCb3hSZXNpemFibGUiLCJ0b2dnbGVEcmFnTW9kZU9uRGJsY2xpY2siLCJtaW5DYW52YXNXaWR0aCIsIm1pbkNhbnZhc0hlaWdodCIsIm1pbkNyb3BCb3hXaWR0aCIsIm1pbkNyb3BCb3hIZWlnaHQiLCJtaW5Db250YWluZXJXaWR0aCIsIm1pbkNvbnRhaW5lckhlaWdodCIsInJlYWR5IiwiY3JvcHN0YXJ0IiwiY3JvcG1vdmUiLCJjcm9wZW5kIiwiY3JvcCIsInpvb20iLCJURU1QTEFURSIsImlzTmFOIiwiaXNOdW1iZXIiLCJpc1Bvc2l0aXZlTnVtYmVyIiwiSW5maW5pdHkiLCJpc1VuZGVmaW5lZCIsImlzT2JqZWN0IiwiaGFzT3duUHJvcGVydHkiLCJpc1BsYWluT2JqZWN0IiwiX2NvbnN0cnVjdG9yIiwiZXJyb3IiLCJpc0Z1bmN0aW9uIiwidG9BcnJheSIsImNhbGxiYWNrIiwiYXNzaWduIiwiX2xlbiIsImFyZ3MiLCJfa2V5IiwiUkVHRVhQX0RFQ0lNQUxTIiwibm9ybWFsaXplRGVjaW1hbE51bWJlciIsInRpbWVzIiwiTWF0aCIsInJvdW5kIiwiUkVHRVhQX1NVRkZJWCIsInNldFN0eWxlIiwiZWxlbWVudCIsInN0eWxlcyIsInN0eWxlIiwicHJvcGVydHkiLCJoYXNDbGFzcyIsImNsYXNzTGlzdCIsImNvbnRhaW5zIiwiY2xhc3NOYW1lIiwiaW5kZXhPZiIsImFkZENsYXNzIiwiZWxlbSIsImFkZCIsInRyaW0iLCJyZW1vdmVDbGFzcyIsInJlbW92ZSIsInJlcGxhY2UiLCJ0b2dnbGVDbGFzcyIsImFkZGVkIiwiUkVHRVhQX0NBTUVMX0NBU0UiLCJ0b1BhcmFtQ2FzZSIsInRvTG93ZXJDYXNlIiwiZ2V0RGF0YSIsImRhdGFzZXQiLCJnZXRBdHRyaWJ1dGUiLCJzZXREYXRhIiwic2V0QXR0cmlidXRlIiwicmVtb3ZlRGF0YSIsInJlbW92ZUF0dHJpYnV0ZSIsIlJFR0VYUF9TUEFDRVMiLCJvbmNlU3VwcG9ydGVkIiwic3VwcG9ydGVkIiwib25jZSIsImxpc3RlbmVyIiwib3B0aW9ucyIsImdldCIsInNldCIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwicmVtb3ZlTGlzdGVuZXIiLCJ0eXBlIiwiaGFuZGxlciIsInNwbGl0IiwiZXZlbnQiLCJsaXN0ZW5lcnMiLCJhZGRMaXN0ZW5lciIsIl9oYW5kbGVyIiwiX2VsZW1lbnQkbGlzdGVuZXJzIiwiX2xlbjIiLCJfa2V5MiIsImRpc3BhdGNoRXZlbnQiLCJFdmVudCIsIkN1c3RvbUV2ZW50IiwiZGV0YWlsIiwiYnViYmxlcyIsImNhbmNlbGFibGUiLCJjcmVhdGVFdmVudCIsImluaXRDdXN0b21FdmVudCIsImdldE9mZnNldCIsImJveCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImxlZnQiLCJwYWdlWE9mZnNldCIsImNsaWVudExlZnQiLCJ0b3AiLCJwYWdlWU9mZnNldCIsImNsaWVudFRvcCIsImxvY2F0aW9uIiwiUkVHRVhQX09SSUdJTlMiLCJpc0Nyb3NzT3JpZ2luVVJMIiwidXJsIiwicGFydHMiLCJtYXRjaCIsInByb3RvY29sIiwiaG9zdG5hbWUiLCJwb3J0IiwiYWRkVGltZXN0YW1wIiwidGltZXN0YW1wIiwiRGF0ZSIsImdldFRpbWUiLCJnZXRUcmFuc2Zvcm1zIiwiX3JlZiIsInJvdGF0ZSIsInNjYWxlWCIsInNjYWxlWSIsInRyYW5zbGF0ZVgiLCJ0cmFuc2xhdGVZIiwidmFsdWVzIiwidHJhbnNmb3JtIiwiam9pbiIsIldlYmtpdFRyYW5zZm9ybSIsIm1zVHJhbnNmb3JtIiwiZ2V0TWF4Wm9vbVJhdGlvIiwicG9pbnRlcnMiLCJwb2ludGVyczIiLCJtYXhSYXRpbyIsInBvaW50ZXIiLCJwb2ludGVySWQiLCJwb2ludGVyMiIsIngxIiwiYWJzIiwic3RhcnRYIiwieTEiLCJzdGFydFkiLCJ4MiIsImVuZFgiLCJ5MiIsImVuZFkiLCJ6MSIsInNxcnQiLCJ6MiIsInJhdGlvIiwiZ2V0UG9pbnRlciIsIl9yZWYyIiwiZW5kT25seSIsInBhZ2VYIiwicGFnZVkiLCJlbmQiLCJnZXRQb2ludGVyc0NlbnRlciIsImNvdW50IiwiX3JlZjMiLCJnZXRBZGp1c3RlZFNpemVzIiwiX3JlZjQiLCJoZWlnaHQiLCJ3aWR0aCIsImlzVmFsaWRXaWR0aCIsImlzVmFsaWRIZWlnaHQiLCJhZGp1c3RlZFdpZHRoIiwiZ2V0Um90YXRlZFNpemVzIiwiX3JlZjUiLCJkZWdyZWUiLCJhcmMiLCJQSSIsInNpbkFyYyIsInNpbiIsImNvc0FyYyIsImNvcyIsIm5ld1dpZHRoIiwibmV3SGVpZ2h0IiwiZ2V0U291cmNlQ2FudmFzIiwiaW1hZ2UiLCJfcmVmNiIsIl9yZWY3IiwiX3JlZjgiLCJpbWFnZUFzcGVjdFJhdGlvIiwiaW1hZ2VOYXR1cmFsV2lkdGgiLCJuYXR1cmFsV2lkdGgiLCJpbWFnZU5hdHVyYWxIZWlnaHQiLCJuYXR1cmFsSGVpZ2h0IiwiX3JlZjYkcm90YXRlIiwiX3JlZjYkc2NhbGVYIiwiX3JlZjYkc2NhbGVZIiwiX3JlZjgkZmlsbENvbG9yIiwiZmlsbENvbG9yIiwiX3JlZjgkaW1hZ2VTbW9vdGhpbmdFIiwiaW1hZ2VTbW9vdGhpbmdFbmFibGVkIiwiX3JlZjgkaW1hZ2VTbW9vdGhpbmdRIiwiaW1hZ2VTbW9vdGhpbmdRdWFsaXR5IiwiX3JlZjgkbWF4V2lkdGgiLCJtYXhXaWR0aCIsIl9yZWY4JG1heEhlaWdodCIsIm1heEhlaWdodCIsIl9yZWY4JG1pbldpZHRoIiwibWluV2lkdGgiLCJfcmVmOCRtaW5IZWlnaHQiLCJtaW5IZWlnaHQiLCJjYW52YXMiLCJjcmVhdGVFbGVtZW50IiwiY29udGV4dCIsImdldENvbnRleHQiLCJtYXhTaXplcyIsIm1pblNpemVzIiwibWluIiwibWF4IiwiZGVzdE1heFNpemVzIiwiZGVzdE1pblNpemVzIiwiZGVzdFdpZHRoIiwiZGVzdEhlaWdodCIsInBhcmFtcyIsImZpbGxTdHlsZSIsImZpbGxSZWN0Iiwic2F2ZSIsInRyYW5zbGF0ZSIsInNjYWxlIiwiZHJhd0ltYWdlIiwibWFwIiwicGFyYW0iLCJmbG9vciIsImZyb21DaGFyQ29kZSIsImdldFN0cmluZ0Zyb21DaGFyQ29kZSIsImRhdGFWaWV3Iiwic3RhcnQiLCJzdHIiLCJnZXRVaW50OCIsIlJFR0VYUF9EQVRBX1VSTF9IRUFEIiwiZGF0YVVSTFRvQXJyYXlCdWZmZXIiLCJkYXRhVVJMIiwiYmFzZTY0IiwiYmluYXJ5IiwiYXRvYiIsImFycmF5QnVmZmVyIiwiQXJyYXlCdWZmZXIiLCJ1aW50OCIsIlVpbnQ4QXJyYXkiLCJjaGFyQ29kZUF0IiwiYXJyYXlCdWZmZXJUb0RhdGFVUkwiLCJtaW1lVHlwZSIsImNodW5rcyIsImNodW5rU2l6ZSIsInN1YmFycmF5IiwiYnRvYSIsInJlc2V0QW5kR2V0T3JpZW50YXRpb24iLCJEYXRhVmlldyIsIm9yaWVudGF0aW9uIiwibGl0dGxlRW5kaWFuIiwiYXBwMVN0YXJ0IiwiaWZkU3RhcnQiLCJieXRlTGVuZ3RoIiwib2Zmc2V0IiwiZXhpZklEQ29kZSIsInRpZmZPZmZzZXQiLCJlbmRpYW5uZXNzIiwiZ2V0VWludDE2IiwiZmlyc3RJRkRPZmZzZXQiLCJnZXRVaW50MzIiLCJfbGVuZ3RoIiwiX29mZnNldCIsInNldFVpbnQxNiIsInBhcnNlT3JpZW50YXRpb24iLCJyZW5kZXIiLCJpbml0Q29udGFpbmVyIiwiaW5pdENhbnZhcyIsImluaXRDcm9wQm94IiwicmVuZGVyQ2FudmFzIiwiY3JvcHBlZCIsInJlbmRlckNyb3BCb3giLCJjb250YWluZXIiLCJjcm9wcGVyIiwiY29udGFpbmVyRGF0YSIsIm9mZnNldFdpZHRoIiwib2Zmc2V0SGVpZ2h0IiwiaW1hZ2VEYXRhIiwicm90YXRlZCIsImNhbnZhc1dpZHRoIiwiY2FudmFzSGVpZ2h0IiwiY2FudmFzRGF0YSIsImxpbWl0ZWQiLCJsaW1pdENhbnZhcyIsIm9sZExlZnQiLCJvbGRUb3AiLCJpbml0aWFsQ2FudmFzRGF0YSIsInNpemVMaW1pdGVkIiwicG9zaXRpb25MaW1pdGVkIiwiY3JvcEJveERhdGEiLCJfZ2V0QWRqdXN0ZWRTaXplcyIsIm5ld0NhbnZhc0xlZnQiLCJuZXdDYW52YXNUb3AiLCJtaW5MZWZ0IiwibWluVG9wIiwibWF4TGVmdCIsIm1heFRvcCIsImNoYW5nZWQiLCJ0cmFuc2Zvcm1lZCIsIl9nZXRSb3RhdGVkU2l6ZXMiLCJyZW5kZXJJbWFnZSIsImxpbWl0Q3JvcEJveCIsIm91dHB1dCIsImluaXRpYWxDcm9wQm94RGF0YSIsIm1heENyb3BCb3hXaWR0aCIsIm1heENyb3BCb3hIZWlnaHQiLCJmYWNlIiwiY3JvcEJveCIsImRpc2FibGVkIiwiaW5pdFByZXZpZXciLCJjcm9zc09yaWdpbiIsImNyb3NzT3JpZ2luVXJsIiwiYWx0Iiwic3JjIiwidmlld0JveCIsImFwcGVuZENoaWxkIiwidmlld0JveEltYWdlIiwicHJldmlld3MiLCJvd25lckRvY3VtZW50IiwicXVlcnlTZWxlY3RvckFsbCIsInF1ZXJ5U2VsZWN0b3IiLCJlbCIsImltZyIsImh0bWwiLCJpbm5lckhUTUwiLCJjc3NUZXh0IiwicmVzZXRQcmV2aWV3IiwiY3JvcEJveFdpZHRoIiwiY3JvcEJveEhlaWdodCIsIm9yaWdpbmFsV2lkdGgiLCJvcmlnaW5hbEhlaWdodCIsImdldEVsZW1lbnRzQnlUYWdOYW1lIiwiZXZlbnRzIiwiYmluZCIsIm9uQ3JvcFN0YXJ0IiwiY3JvcFN0YXJ0Iiwib25XaGVlbCIsIndoZWVsIiwicGFzc2l2ZSIsImNhcHR1cmUiLCJvbkRibGNsaWNrIiwiZGJsY2xpY2siLCJvbkNyb3BNb3ZlIiwiY3JvcE1vdmUiLCJvbkNyb3BFbmQiLCJjcm9wRW5kIiwib25SZXNpemUiLCJyZXNpemUiLCJ1bmJpbmQiLCJoYW5kbGVycyIsInJhdGlvWCIsInJhdGlvWSIsImdldENhbnZhc0RhdGEiLCJnZXRDcm9wQm94RGF0YSIsInNldENhbnZhc0RhdGEiLCJzZXRDcm9wQm94RGF0YSIsInNldERyYWdNb2RlIiwiZHJhZ0JveCIsIl90aGlzIiwiZGVsdGEiLCJwcmV2ZW50RGVmYXVsdCIsIndoZWVsaW5nIiwic2V0VGltZW91dCIsImRlbHRhWSIsIndoZWVsRGVsdGEiLCJidXR0b25zIiwiYnV0dG9uIiwicG9pbnRlclR5cGUiLCJjdHJsS2V5IiwiYWN0aW9uIiwiY2hhbmdlZFRvdWNoZXMiLCJ0b3VjaCIsImlkZW50aWZpZXIiLCJvcmlnaW5hbEV2ZW50IiwiY3JvcHBpbmciLCJjaGFuZ2UiLCJyaWdodCIsImJvdHRvbSIsInJlbmRlcmFibGUiLCJzaGlmdEtleSIsInJhbmdlIiwieCIsInkiLCJjaGVjayIsInNpZGUiLCJtb3ZlIiwicCIsIm1ldGhvZHMiLCJyZXNldCIsImluaXRpYWxJbWFnZURhdGEiLCJjbGVhciIsImhhc1NhbWVTaXplIiwiaXNJbWciLCJyZXBsYWNlZCIsInVuY3JlYXRlIiwibG9hZCIsImVuYWJsZSIsImRpc2FibGUiLCJkZXN0cm95Iiwib3JpZ2luYWxVcmwiLCJvZmZzZXRYIiwib2Zmc2V0WSIsIl90aGlzJGNhbnZhc0RhdGEiLCJtb3ZlVG8iLCJfb3JpZ2luYWxFdmVudCIsInpvb21UbyIsInBpdm90Iiwib2xkUmF0aW8iLCJyb3RhdGVUbyIsIl9zY2FsZVgiLCJfc2NhbGVZIiwicm91bmRlZCIsImdldENvbnRhaW5lckRhdGEiLCJnZXRJbWFnZURhdGEiLCJzaXplZCIsIndpZHRoQ2hhbmdlZCIsImhlaWdodENoYW5nZWQiLCJnZXRDcm9wcGVkQ2FudmFzIiwiSFRNTENhbnZhc0VsZW1lbnQiLCJzb3VyY2UiLCJfdGhpcyRnZXREYXRhIiwiaW5pdGlhbFgiLCJpbml0aWFsWSIsImluaXRpYWxXaWR0aCIsImluaXRpYWxIZWlnaHQiLCJfb3B0aW9ucyRpbWFnZVNtb290aGkiLCJzb3VyY2VXaWR0aCIsInNvdXJjZUhlaWdodCIsInNyY1giLCJzcmNZIiwic3JjV2lkdGgiLCJzcmNIZWlnaHQiLCJkc3RYIiwiZHN0WSIsImRzdFdpZHRoIiwiZHN0SGVpZ2h0Iiwic2V0QXNwZWN0UmF0aW8iLCJtb2RlIiwiY3JvcHBhYmxlIiwiQW5vdGhlckNyb3BwZXIiLCJDcm9wcGVyIiwidGFnTmFtZSIsIkVycm9yIiwicmVsb2FkaW5nIiwic2l6aW5nIiwiaW5pdCIsInRvRGF0YVVSTCIsImNsb25lIiwicmVhZCIsInhociIsIlhNTEh0dHBSZXF1ZXN0Iiwib25hYm9ydCIsIm9uZXJyb3IiLCJvbnRpbWVvdXQiLCJvbnByb2dyZXNzIiwiZ2V0UmVzcG9uc2VIZWFkZXIiLCJhYm9ydCIsIm9ubG9hZCIsInJlc3BvbnNlIiwib25sb2FkZW5kIiwib3BlbiIsInJlc3BvbnNlVHlwZSIsIndpdGhDcmVkZW50aWFscyIsInNlbmQiLCJfcGFyc2VPcmllbnRhdGlvbiIsInN0b3AiLCJwYXJlbnROb2RlIiwiaW5zZXJ0QmVmb3JlIiwibmV4dFNpYmxpbmciLCJfdGhpczIiLCJpc0lPU1dlYktpdCIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsImRvbmUiLCJidWlsZCIsInNpemluZ0ltYWdlIiwiYm9keSIsInJlbW92ZUNoaWxkIiwidGVtcGxhdGUiLCJnZXRFbGVtZW50c0J5Q2xhc3NOYW1lIiwidW5idWlsZCIsIm5vQ29uZmxpY3QiLCJzZXREZWZhdWx0cyIsImRlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/cropperjs/dist/cropper.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/cropperjs/dist/cropper.css":
/*!*************************************************!*\
  !*** ./node_modules/cropperjs/dist/cropper.css ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"2557061948e6\");\nif (false) {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY3JvcHBlcmpzL2Rpc3QvY3JvcHBlci5jc3MiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLGlFQUFlLGNBQWM7QUFDN0IsSUFBSSxLQUFVLEVBQUUsRUFBdUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMtZWNvbW1lcmNlLXVpdC8uL25vZGVfbW9kdWxlcy9jcm9wcGVyanMvZGlzdC9jcm9wcGVyLmNzcz80NDNkIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IFwiMjU1NzA2MTk0OGU2XCJcbmlmIChtb2R1bGUuaG90KSB7IG1vZHVsZS5ob3QuYWNjZXB0KCkgfVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/cropperjs/dist/cropper.css\n");

/***/ })

};
;