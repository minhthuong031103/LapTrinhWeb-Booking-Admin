"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/scheduler";
exports.ids = ["vendor-chunks/scheduler"];
exports.modules = {

/***/ "(ssr)/./node_modules/scheduler/cjs/scheduler.development.js":
/*!*************************************************************!*\
  !*** ./node_modules/scheduler/cjs/scheduler.development.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("/** @license React v0.17.0\n * scheduler.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ \nif (true) {\n    (function() {\n        \"use strict\";\n        Object.defineProperty(exports, \"__esModule\", ({\n            value: true\n        }));\n        var enableSchedulerDebugging = false;\n        var enableIsInputPending = false;\n        var enableMessageLoopImplementation = true;\n        var enableProfiling = true;\n        // works by scheduling a requestAnimationFrame, storing the time for the start\n        // of the frame, then scheduling a postMessage which gets scheduled after paint.\n        // Within the postMessage handler do as much work as possible until time + frame\n        // rate. By separating the idle call into a separate event tick we ensure that\n        // layout, paint and other browser work is counted against the available time.\n        // The frame rate is dynamically adjusted.\n        var requestHostCallback;\n        var requestHostTimeout;\n        var cancelHostTimeout;\n        var shouldYieldToHost;\n        var requestPaint;\n        if (// implementation using setTimeout.\n        true) {\n            // If this accidentally gets imported in a non-browser environment, e.g. JavaScriptCore,\n            // fallback to a naive implementation.\n            var _callback = null;\n            var _timeoutID = null;\n            var _flushCallback = function() {\n                if (_callback !== null) {\n                    try {\n                        var currentTime = exports.unstable_now();\n                        var hasRemainingTime = true;\n                        _callback(hasRemainingTime, currentTime);\n                        _callback = null;\n                    } catch (e) {\n                        setTimeout(_flushCallback, 0);\n                        throw e;\n                    }\n                }\n            };\n            var initialTime = Date.now();\n            exports.unstable_now = function() {\n                return Date.now() - initialTime;\n            };\n            requestHostCallback = function(cb) {\n                if (_callback !== null) {\n                    // Protect against re-entrancy.\n                    setTimeout(requestHostCallback, 0, cb);\n                } else {\n                    _callback = cb;\n                    setTimeout(_flushCallback, 0);\n                }\n            };\n            requestHostTimeout = function(cb, ms) {\n                _timeoutID = setTimeout(cb, ms);\n            };\n            cancelHostTimeout = function() {\n                clearTimeout(_timeoutID);\n            };\n            shouldYieldToHost = function() {\n                return false;\n            };\n            requestPaint = exports.unstable_forceFrameRate = function() {};\n        } else { var onAnimationFrame, port, channel, performWorkUntilDeadline, scheduling, needsPaint, maxFrameLength, fpsLocked, frameDeadline, prevRAFInterval, prevRAFTime, frameLength, taskTimeoutID, rAFTimeoutID, scheduledHostCallback, isMessageLoopRunning, isRAFLoopRunning, _initialTime, cancelAnimationFrame, requestAnimationFrame, _clearTimeout, _setTimeout, _Date, performance; }\n        function push(heap, node) {\n            var index = heap.length;\n            heap.push(node);\n            siftUp(heap, node, index);\n        }\n        function peek(heap) {\n            var first = heap[0];\n            return first === undefined ? null : first;\n        }\n        function pop(heap) {\n            var first = heap[0];\n            if (first !== undefined) {\n                var last = heap.pop();\n                if (last !== first) {\n                    heap[0] = last;\n                    siftDown(heap, last, 0);\n                }\n                return first;\n            } else {\n                return null;\n            }\n        }\n        function siftUp(heap, node, i) {\n            var index = i;\n            while(true){\n                var parentIndex = Math.floor((index - 1) / 2);\n                var parent = heap[parentIndex];\n                if (parent !== undefined && compare(parent, node) > 0) {\n                    // The parent is larger. Swap positions.\n                    heap[parentIndex] = node;\n                    heap[index] = parent;\n                    index = parentIndex;\n                } else {\n                    // The parent is smaller. Exit.\n                    return;\n                }\n            }\n        }\n        function siftDown(heap, node, i) {\n            var index = i;\n            var length = heap.length;\n            while(index < length){\n                var leftIndex = (index + 1) * 2 - 1;\n                var left = heap[leftIndex];\n                var rightIndex = leftIndex + 1;\n                var right = heap[rightIndex]; // If the left or right node is smaller, swap with the smaller of those.\n                if (left !== undefined && compare(left, node) < 0) {\n                    if (right !== undefined && compare(right, left) < 0) {\n                        heap[index] = right;\n                        heap[rightIndex] = node;\n                        index = rightIndex;\n                    } else {\n                        heap[index] = left;\n                        heap[leftIndex] = node;\n                        index = leftIndex;\n                    }\n                } else if (right !== undefined && compare(right, node) < 0) {\n                    heap[index] = right;\n                    heap[rightIndex] = node;\n                    index = rightIndex;\n                } else {\n                    // Neither child is smaller. Exit.\n                    return;\n                }\n            }\n        }\n        function compare(a, b) {\n            // Compare sort index first, then task id.\n            var diff = a.sortIndex - b.sortIndex;\n            return diff !== 0 ? diff : a.id - b.id;\n        }\n        // TODO: Use symbols?\n        var NoPriority = 0;\n        var ImmediatePriority = 1;\n        var UserBlockingPriority = 2;\n        var NormalPriority = 3;\n        var LowPriority = 4;\n        var IdlePriority = 5;\n        var runIdCounter = 0;\n        var mainThreadIdCounter = 0;\n        var profilingStateSize = 4;\n        var sharedProfilingBuffer = enableProfiling ? typeof SharedArrayBuffer === \"function\" ? new SharedArrayBuffer(profilingStateSize * Int32Array.BYTES_PER_ELEMENT) : typeof ArrayBuffer === \"function\" ? new ArrayBuffer(profilingStateSize * Int32Array.BYTES_PER_ELEMENT) : null // Don't crash the init path on IE9\n         : null;\n        var profilingState = enableProfiling && sharedProfilingBuffer !== null ? new Int32Array(sharedProfilingBuffer) : []; // We can't read this but it helps save bytes for null checks\n        var PRIORITY = 0;\n        var CURRENT_TASK_ID = 1;\n        var CURRENT_RUN_ID = 2;\n        var QUEUE_SIZE = 3;\n        if (enableProfiling) {\n            profilingState[PRIORITY] = NoPriority; // This is maintained with a counter, because the size of the priority queue\n            // array might include canceled tasks.\n            profilingState[QUEUE_SIZE] = 0;\n            profilingState[CURRENT_TASK_ID] = 0;\n        } // Bytes per element is 4\n        var INITIAL_EVENT_LOG_SIZE = 131072;\n        var MAX_EVENT_LOG_SIZE = 524288; // Equivalent to 2 megabytes\n        var eventLogSize = 0;\n        var eventLogBuffer = null;\n        var eventLog = null;\n        var eventLogIndex = 0;\n        var TaskStartEvent = 1;\n        var TaskCompleteEvent = 2;\n        var TaskErrorEvent = 3;\n        var TaskCancelEvent = 4;\n        var TaskRunEvent = 5;\n        var TaskYieldEvent = 6;\n        var SchedulerSuspendEvent = 7;\n        var SchedulerResumeEvent = 8;\n        function logEvent(entries) {\n            if (eventLog !== null) {\n                var offset = eventLogIndex;\n                eventLogIndex += entries.length;\n                if (eventLogIndex + 1 > eventLogSize) {\n                    eventLogSize *= 2;\n                    if (eventLogSize > MAX_EVENT_LOG_SIZE) {\n                        console.error(\"Scheduler Profiling: Event log exceeded maximum size. Don't \" + \"forget to call `stopLoggingProfilingEvents()`.\");\n                        stopLoggingProfilingEvents();\n                        return;\n                    }\n                    var newEventLog = new Int32Array(eventLogSize * 4);\n                    newEventLog.set(eventLog);\n                    eventLogBuffer = newEventLog.buffer;\n                    eventLog = newEventLog;\n                }\n                eventLog.set(entries, offset);\n            }\n        }\n        function startLoggingProfilingEvents() {\n            eventLogSize = INITIAL_EVENT_LOG_SIZE;\n            eventLogBuffer = new ArrayBuffer(eventLogSize * 4);\n            eventLog = new Int32Array(eventLogBuffer);\n            eventLogIndex = 0;\n        }\n        function stopLoggingProfilingEvents() {\n            var buffer = eventLogBuffer;\n            eventLogSize = 0;\n            eventLogBuffer = null;\n            eventLog = null;\n            eventLogIndex = 0;\n            return buffer;\n        }\n        function markTaskStart(task, ms) {\n            if (enableProfiling) {\n                profilingState[QUEUE_SIZE]++;\n                if (eventLog !== null) {\n                    // performance.now returns a float, representing milliseconds. When the\n                    // event is logged, it's coerced to an int. Convert to microseconds to\n                    // maintain extra degrees of precision.\n                    logEvent([\n                        TaskStartEvent,\n                        ms * 1000,\n                        task.id,\n                        task.priorityLevel\n                    ]);\n                }\n            }\n        }\n        function markTaskCompleted(task, ms) {\n            if (enableProfiling) {\n                profilingState[PRIORITY] = NoPriority;\n                profilingState[CURRENT_TASK_ID] = 0;\n                profilingState[QUEUE_SIZE]--;\n                if (eventLog !== null) {\n                    logEvent([\n                        TaskCompleteEvent,\n                        ms * 1000,\n                        task.id\n                    ]);\n                }\n            }\n        }\n        function markTaskCanceled(task, ms) {\n            if (enableProfiling) {\n                profilingState[QUEUE_SIZE]--;\n                if (eventLog !== null) {\n                    logEvent([\n                        TaskCancelEvent,\n                        ms * 1000,\n                        task.id\n                    ]);\n                }\n            }\n        }\n        function markTaskErrored(task, ms) {\n            if (enableProfiling) {\n                profilingState[PRIORITY] = NoPriority;\n                profilingState[CURRENT_TASK_ID] = 0;\n                profilingState[QUEUE_SIZE]--;\n                if (eventLog !== null) {\n                    logEvent([\n                        TaskErrorEvent,\n                        ms * 1000,\n                        task.id\n                    ]);\n                }\n            }\n        }\n        function markTaskRun(task, ms) {\n            if (enableProfiling) {\n                runIdCounter++;\n                profilingState[PRIORITY] = task.priorityLevel;\n                profilingState[CURRENT_TASK_ID] = task.id;\n                profilingState[CURRENT_RUN_ID] = runIdCounter;\n                if (eventLog !== null) {\n                    logEvent([\n                        TaskRunEvent,\n                        ms * 1000,\n                        task.id,\n                        runIdCounter\n                    ]);\n                }\n            }\n        }\n        function markTaskYield(task, ms) {\n            if (enableProfiling) {\n                profilingState[PRIORITY] = NoPriority;\n                profilingState[CURRENT_TASK_ID] = 0;\n                profilingState[CURRENT_RUN_ID] = 0;\n                if (eventLog !== null) {\n                    logEvent([\n                        TaskYieldEvent,\n                        ms * 1000,\n                        task.id,\n                        runIdCounter\n                    ]);\n                }\n            }\n        }\n        function markSchedulerSuspended(ms) {\n            if (enableProfiling) {\n                mainThreadIdCounter++;\n                if (eventLog !== null) {\n                    logEvent([\n                        SchedulerSuspendEvent,\n                        ms * 1000,\n                        mainThreadIdCounter\n                    ]);\n                }\n            }\n        }\n        function markSchedulerUnsuspended(ms) {\n            if (enableProfiling) {\n                if (eventLog !== null) {\n                    logEvent([\n                        SchedulerResumeEvent,\n                        ms * 1000,\n                        mainThreadIdCounter\n                    ]);\n                }\n            }\n        }\n        /* eslint-disable no-var */ // Math.pow(2, 30) - 1\n        // 0b111111111111111111111111111111\n        var maxSigned31BitInt = 1073741823; // Times out immediately\n        var IMMEDIATE_PRIORITY_TIMEOUT = -1; // Eventually times out\n        var USER_BLOCKING_PRIORITY = 250;\n        var NORMAL_PRIORITY_TIMEOUT = 5000;\n        var LOW_PRIORITY_TIMEOUT = 10000; // Never times out\n        var IDLE_PRIORITY = maxSigned31BitInt; // Tasks are stored on a min heap\n        var taskQueue = [];\n        var timerQueue = []; // Incrementing id counter. Used to maintain insertion order.\n        var taskIdCounter = 1; // Pausing the scheduler is useful for debugging.\n        var isSchedulerPaused = false;\n        var currentTask = null;\n        var currentPriorityLevel = NormalPriority; // This is set while performing work, to prevent re-entrancy.\n        var isPerformingWork = false;\n        var isHostCallbackScheduled = false;\n        var isHostTimeoutScheduled = false;\n        function advanceTimers(currentTime) {\n            // Check for tasks that are no longer delayed and add them to the queue.\n            var timer = peek(timerQueue);\n            while(timer !== null){\n                if (timer.callback === null) {\n                    // Timer was cancelled.\n                    pop(timerQueue);\n                } else if (timer.startTime <= currentTime) {\n                    // Timer fired. Transfer to the task queue.\n                    pop(timerQueue);\n                    timer.sortIndex = timer.expirationTime;\n                    push(taskQueue, timer);\n                    if (enableProfiling) {\n                        markTaskStart(timer, currentTime);\n                        timer.isQueued = true;\n                    }\n                } else {\n                    // Remaining timers are pending.\n                    return;\n                }\n                timer = peek(timerQueue);\n            }\n        }\n        function handleTimeout(currentTime) {\n            isHostTimeoutScheduled = false;\n            advanceTimers(currentTime);\n            if (!isHostCallbackScheduled) {\n                if (peek(taskQueue) !== null) {\n                    isHostCallbackScheduled = true;\n                    requestHostCallback(flushWork);\n                } else {\n                    var firstTimer = peek(timerQueue);\n                    if (firstTimer !== null) {\n                        requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);\n                    }\n                }\n            }\n        }\n        function flushWork(hasTimeRemaining, initialTime) {\n            if (enableProfiling) {\n                markSchedulerUnsuspended(initialTime);\n            } // We'll need a host callback the next time work is scheduled.\n            isHostCallbackScheduled = false;\n            if (isHostTimeoutScheduled) {\n                // We scheduled a timeout but it's no longer needed. Cancel it.\n                isHostTimeoutScheduled = false;\n                cancelHostTimeout();\n            }\n            isPerformingWork = true;\n            var previousPriorityLevel = currentPriorityLevel;\n            try {\n                if (enableProfiling) {\n                    try {\n                        return workLoop(hasTimeRemaining, initialTime);\n                    } catch (error) {\n                        if (currentTask !== null) {\n                            var currentTime = exports.unstable_now();\n                            markTaskErrored(currentTask, currentTime);\n                            currentTask.isQueued = false;\n                        }\n                        throw error;\n                    }\n                } else {\n                    // No catch in prod codepath.\n                    return workLoop(hasTimeRemaining, initialTime);\n                }\n            } finally{\n                currentTask = null;\n                currentPriorityLevel = previousPriorityLevel;\n                isPerformingWork = false;\n                if (enableProfiling) {\n                    var _currentTime = exports.unstable_now();\n                    markSchedulerSuspended(_currentTime);\n                }\n            }\n        }\n        function workLoop(hasTimeRemaining, initialTime) {\n            var currentTime = initialTime;\n            advanceTimers(currentTime);\n            currentTask = peek(taskQueue);\n            while(currentTask !== null && !(enableSchedulerDebugging && isSchedulerPaused)){\n                if (currentTask.expirationTime > currentTime && (!hasTimeRemaining || shouldYieldToHost())) {\n                    break;\n                }\n                var callback = currentTask.callback;\n                if (callback !== null) {\n                    currentTask.callback = null;\n                    currentPriorityLevel = currentTask.priorityLevel;\n                    var didUserCallbackTimeout = currentTask.expirationTime <= currentTime;\n                    markTaskRun(currentTask, currentTime);\n                    var continuationCallback = callback(didUserCallbackTimeout);\n                    currentTime = exports.unstable_now();\n                    if (typeof continuationCallback === \"function\") {\n                        currentTask.callback = continuationCallback;\n                        markTaskYield(currentTask, currentTime);\n                    } else {\n                        if (enableProfiling) {\n                            markTaskCompleted(currentTask, currentTime);\n                            currentTask.isQueued = false;\n                        }\n                        if (currentTask === peek(taskQueue)) {\n                            pop(taskQueue);\n                        }\n                    }\n                    advanceTimers(currentTime);\n                } else {\n                    pop(taskQueue);\n                }\n                currentTask = peek(taskQueue);\n            } // Return whether there's additional work\n            if (currentTask !== null) {\n                return true;\n            } else {\n                var firstTimer = peek(timerQueue);\n                if (firstTimer !== null) {\n                    requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);\n                }\n                return false;\n            }\n        }\n        function unstable_runWithPriority(priorityLevel, eventHandler) {\n            switch(priorityLevel){\n                case ImmediatePriority:\n                case UserBlockingPriority:\n                case NormalPriority:\n                case LowPriority:\n                case IdlePriority:\n                    break;\n                default:\n                    priorityLevel = NormalPriority;\n            }\n            var previousPriorityLevel = currentPriorityLevel;\n            currentPriorityLevel = priorityLevel;\n            try {\n                return eventHandler();\n            } finally{\n                currentPriorityLevel = previousPriorityLevel;\n            }\n        }\n        function unstable_next(eventHandler) {\n            var priorityLevel;\n            switch(currentPriorityLevel){\n                case ImmediatePriority:\n                case UserBlockingPriority:\n                case NormalPriority:\n                    // Shift down to normal priority\n                    priorityLevel = NormalPriority;\n                    break;\n                default:\n                    // Anything lower than normal priority should remain at the current level.\n                    priorityLevel = currentPriorityLevel;\n                    break;\n            }\n            var previousPriorityLevel = currentPriorityLevel;\n            currentPriorityLevel = priorityLevel;\n            try {\n                return eventHandler();\n            } finally{\n                currentPriorityLevel = previousPriorityLevel;\n            }\n        }\n        function unstable_wrapCallback(callback) {\n            var parentPriorityLevel = currentPriorityLevel;\n            return function() {\n                // This is a fork of runWithPriority, inlined for performance.\n                var previousPriorityLevel = currentPriorityLevel;\n                currentPriorityLevel = parentPriorityLevel;\n                try {\n                    return callback.apply(this, arguments);\n                } finally{\n                    currentPriorityLevel = previousPriorityLevel;\n                }\n            };\n        }\n        function timeoutForPriorityLevel(priorityLevel) {\n            switch(priorityLevel){\n                case ImmediatePriority:\n                    return IMMEDIATE_PRIORITY_TIMEOUT;\n                case UserBlockingPriority:\n                    return USER_BLOCKING_PRIORITY;\n                case IdlePriority:\n                    return IDLE_PRIORITY;\n                case LowPriority:\n                    return LOW_PRIORITY_TIMEOUT;\n                case NormalPriority:\n                default:\n                    return NORMAL_PRIORITY_TIMEOUT;\n            }\n        }\n        function unstable_scheduleCallback(priorityLevel, callback, options) {\n            var currentTime = exports.unstable_now();\n            var startTime;\n            var timeout;\n            if (typeof options === \"object\" && options !== null) {\n                var delay = options.delay;\n                if (typeof delay === \"number\" && delay > 0) {\n                    startTime = currentTime + delay;\n                } else {\n                    startTime = currentTime;\n                }\n                timeout = typeof options.timeout === \"number\" ? options.timeout : timeoutForPriorityLevel(priorityLevel);\n            } else {\n                timeout = timeoutForPriorityLevel(priorityLevel);\n                startTime = currentTime;\n            }\n            var expirationTime = startTime + timeout;\n            var newTask = {\n                id: taskIdCounter++,\n                callback: callback,\n                priorityLevel: priorityLevel,\n                startTime: startTime,\n                expirationTime: expirationTime,\n                sortIndex: -1\n            };\n            if (enableProfiling) {\n                newTask.isQueued = false;\n            }\n            if (startTime > currentTime) {\n                // This is a delayed task.\n                newTask.sortIndex = startTime;\n                push(timerQueue, newTask);\n                if (peek(taskQueue) === null && newTask === peek(timerQueue)) {\n                    // All tasks are delayed, and this is the task with the earliest delay.\n                    if (isHostTimeoutScheduled) {\n                        // Cancel an existing timeout.\n                        cancelHostTimeout();\n                    } else {\n                        isHostTimeoutScheduled = true;\n                    } // Schedule a timeout.\n                    requestHostTimeout(handleTimeout, startTime - currentTime);\n                }\n            } else {\n                newTask.sortIndex = expirationTime;\n                push(taskQueue, newTask);\n                if (enableProfiling) {\n                    markTaskStart(newTask, currentTime);\n                    newTask.isQueued = true;\n                } // Schedule a host callback, if needed. If we're already performing work,\n                // wait until the next time we yield.\n                if (!isHostCallbackScheduled && !isPerformingWork) {\n                    isHostCallbackScheduled = true;\n                    requestHostCallback(flushWork);\n                }\n            }\n            return newTask;\n        }\n        function unstable_pauseExecution() {\n            isSchedulerPaused = true;\n        }\n        function unstable_continueExecution() {\n            isSchedulerPaused = false;\n            if (!isHostCallbackScheduled && !isPerformingWork) {\n                isHostCallbackScheduled = true;\n                requestHostCallback(flushWork);\n            }\n        }\n        function unstable_getFirstCallbackNode() {\n            return peek(taskQueue);\n        }\n        function unstable_cancelCallback(task) {\n            if (enableProfiling) {\n                if (task.isQueued) {\n                    var currentTime = exports.unstable_now();\n                    markTaskCanceled(task, currentTime);\n                    task.isQueued = false;\n                }\n            } // Null out the callback to indicate the task has been canceled. (Can't\n            // remove from the queue because you can't remove arbitrary nodes from an\n            // array based heap, only the first one.)\n            task.callback = null;\n        }\n        function unstable_getCurrentPriorityLevel() {\n            return currentPriorityLevel;\n        }\n        function unstable_shouldYield() {\n            var currentTime = exports.unstable_now();\n            advanceTimers(currentTime);\n            var firstTask = peek(taskQueue);\n            return firstTask !== currentTask && currentTask !== null && firstTask !== null && firstTask.callback !== null && firstTask.startTime <= currentTime && firstTask.expirationTime < currentTask.expirationTime || shouldYieldToHost();\n        }\n        var unstable_requestPaint = requestPaint;\n        var unstable_Profiling = enableProfiling ? {\n            startLoggingProfilingEvents: startLoggingProfilingEvents,\n            stopLoggingProfilingEvents: stopLoggingProfilingEvents,\n            sharedProfilingBuffer: sharedProfilingBuffer\n        } : null;\n        exports.unstable_ImmediatePriority = ImmediatePriority;\n        exports.unstable_UserBlockingPriority = UserBlockingPriority;\n        exports.unstable_NormalPriority = NormalPriority;\n        exports.unstable_IdlePriority = IdlePriority;\n        exports.unstable_LowPriority = LowPriority;\n        exports.unstable_runWithPriority = unstable_runWithPriority;\n        exports.unstable_next = unstable_next;\n        exports.unstable_scheduleCallback = unstable_scheduleCallback;\n        exports.unstable_cancelCallback = unstable_cancelCallback;\n        exports.unstable_wrapCallback = unstable_wrapCallback;\n        exports.unstable_getCurrentPriorityLevel = unstable_getCurrentPriorityLevel;\n        exports.unstable_shouldYield = unstable_shouldYield;\n        exports.unstable_requestPaint = unstable_requestPaint;\n        exports.unstable_continueExecution = unstable_continueExecution;\n        exports.unstable_pauseExecution = unstable_pauseExecution;\n        exports.unstable_getFirstCallbackNode = unstable_getFirstCallbackNode;\n        exports.unstable_Profiling = unstable_Profiling;\n    })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc2NoZWR1bGVyL2Nqcy9zY2hlZHVsZXIuZGV2ZWxvcG1lbnQuanMiLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Q0FPQyxHQUVEO0FBSUEsSUFBSUEsSUFBcUMsRUFBRTtJQUN4QztRQUNIO1FBRUFDLDhDQUE2QztZQUFFRyxPQUFPO1FBQUssQ0FBQyxFQUFDO1FBRTdELElBQUlDLDJCQUEyQjtRQUMvQixJQUFJQyx1QkFBdUI7UUFDM0IsSUFBSUMsa0NBQWtDO1FBQ3RDLElBQUlDLGtCQUFrQjtRQUV0Qiw4RUFBOEU7UUFDOUUsZ0ZBQWdGO1FBQ2hGLGdGQUFnRjtRQUNoRiw4RUFBOEU7UUFDOUUsOEVBQThFO1FBQzlFLDBDQUEwQztRQUUxQyxJQUFJQztRQUVKLElBQUlDO1FBQ0osSUFBSUM7UUFDSixJQUFJQztRQUNKLElBQUlDO1FBSUosSUFDQSxtQ0FBbUM7UUFDbkMsSUFDMEIsRUFBWTtZQUNwQyx3RkFBd0Y7WUFDeEYsc0NBQXNDO1lBQ3RDLElBQUlFLFlBQVk7WUFDaEIsSUFBSUMsYUFBYTtZQUVqQixJQUFJQyxpQkFBaUI7Z0JBQ25CLElBQUlGLGNBQWMsTUFBTTtvQkFDdEIsSUFBSTt3QkFDRixJQUFJRyxjQUFjZixRQUFRZ0IsWUFBWTt3QkFDdEMsSUFBSUMsbUJBQW1CO3dCQUV2QkwsVUFBVUssa0JBQWtCRjt3QkFFNUJILFlBQVk7b0JBQ2QsRUFBRSxPQUFPTSxHQUFHO3dCQUNWQyxXQUFXTCxnQkFBZ0I7d0JBQzNCLE1BQU1JO29CQUNSO2dCQUNGO1lBQ0Y7WUFFQSxJQUFJRSxjQUFjQyxLQUFLQyxHQUFHO1lBRTFCdEIsb0JBQW9CLEdBQUc7Z0JBQ3JCLE9BQU9xQixLQUFLQyxHQUFHLEtBQUtGO1lBQ3RCO1lBRUFkLHNCQUFzQixTQUFVaUIsRUFBRTtnQkFDaEMsSUFBSVgsY0FBYyxNQUFNO29CQUN0QiwrQkFBK0I7b0JBQy9CTyxXQUFXYixxQkFBcUIsR0FBR2lCO2dCQUNyQyxPQUFPO29CQUNMWCxZQUFZ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QUFHa007UUFDL0JsTSw2QkFBNkIsR0FBR29NO1FBQ2hDcE0sa0NBQWtDLEdBQUc4TDtRQUNyQzlMLCtCQUErQixHQUFHNkw7UUFDbEM3TCxxQ0FBcUMsR0FBRytMO1FBQ3hDL0wsMEJBQTBCLEdBQUdxTTtJQUMzQjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLWVjb21tZXJjZS11aXQvLi9ub2RlX21vZHVsZXMvc2NoZWR1bGVyL2Nqcy9zY2hlZHVsZXIuZGV2ZWxvcG1lbnQuanM/YmNkMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiogQGxpY2Vuc2UgUmVhY3QgdjAuMTcuMFxuICogc2NoZWR1bGVyLmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAoZnVuY3Rpb24oKSB7XG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBlbmFibGVTY2hlZHVsZXJEZWJ1Z2dpbmcgPSBmYWxzZTtcbnZhciBlbmFibGVJc0lucHV0UGVuZGluZyA9IGZhbHNlO1xudmFyIGVuYWJsZU1lc3NhZ2VMb29wSW1wbGVtZW50YXRpb24gPSB0cnVlO1xudmFyIGVuYWJsZVByb2ZpbGluZyA9IHRydWU7XG5cbi8vIHdvcmtzIGJ5IHNjaGVkdWxpbmcgYSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUsIHN0b3JpbmcgdGhlIHRpbWUgZm9yIHRoZSBzdGFydFxuLy8gb2YgdGhlIGZyYW1lLCB0aGVuIHNjaGVkdWxpbmcgYSBwb3N0TWVzc2FnZSB3aGljaCBnZXRzIHNjaGVkdWxlZCBhZnRlciBwYWludC5cbi8vIFdpdGhpbiB0aGUgcG9zdE1lc3NhZ2UgaGFuZGxlciBkbyBhcyBtdWNoIHdvcmsgYXMgcG9zc2libGUgdW50aWwgdGltZSArIGZyYW1lXG4vLyByYXRlLiBCeSBzZXBhcmF0aW5nIHRoZSBpZGxlIGNhbGwgaW50byBhIHNlcGFyYXRlIGV2ZW50IHRpY2sgd2UgZW5zdXJlIHRoYXRcbi8vIGxheW91dCwgcGFpbnQgYW5kIG90aGVyIGJyb3dzZXIgd29yayBpcyBjb3VudGVkIGFnYWluc3QgdGhlIGF2YWlsYWJsZSB0aW1lLlxuLy8gVGhlIGZyYW1lIHJhdGUgaXMgZHluYW1pY2FsbHkgYWRqdXN0ZWQuXG5cbnZhciByZXF1ZXN0SG9zdENhbGxiYWNrO1xuXG52YXIgcmVxdWVzdEhvc3RUaW1lb3V0O1xudmFyIGNhbmNlbEhvc3RUaW1lb3V0O1xudmFyIHNob3VsZFlpZWxkVG9Ib3N0O1xudmFyIHJlcXVlc3RQYWludDtcblxuXG5cbmlmICggLy8gSWYgU2NoZWR1bGVyIHJ1bnMgaW4gYSBub24tRE9NIGVudmlyb25tZW50LCBpdCBmYWxscyBiYWNrIHRvIGEgbmFpdmVcbi8vIGltcGxlbWVudGF0aW9uIHVzaW5nIHNldFRpbWVvdXQuXG50eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyB8fCAvLyBDaGVjayBpZiBNZXNzYWdlQ2hhbm5lbCBpcyBzdXBwb3J0ZWQsIHRvby5cbnR5cGVvZiBNZXNzYWdlQ2hhbm5lbCAhPT0gJ2Z1bmN0aW9uJykge1xuICAvLyBJZiB0aGlzIGFjY2lkZW50YWxseSBnZXRzIGltcG9ydGVkIGluIGEgbm9uLWJyb3dzZXIgZW52aXJvbm1lbnQsIGUuZy4gSmF2YVNjcmlwdENvcmUsXG4gIC8vIGZhbGxiYWNrIHRvIGEgbmFpdmUgaW1wbGVtZW50YXRpb24uXG4gIHZhciBfY2FsbGJhY2sgPSBudWxsO1xuICB2YXIgX3RpbWVvdXRJRCA9IG51bGw7XG5cbiAgdmFyIF9mbHVzaENhbGxiYWNrID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChfY2FsbGJhY2sgIT09IG51bGwpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBjdXJyZW50VGltZSA9IGV4cG9ydHMudW5zdGFibGVfbm93KCk7XG4gICAgICAgIHZhciBoYXNSZW1haW5pbmdUaW1lID0gdHJ1ZTtcblxuICAgICAgICBfY2FsbGJhY2soaGFzUmVtYWluaW5nVGltZSwgY3VycmVudFRpbWUpO1xuXG4gICAgICAgIF9jYWxsYmFjayA9IG51bGw7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHNldFRpbWVvdXQoX2ZsdXNoQ2FsbGJhY2ssIDApO1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB2YXIgaW5pdGlhbFRpbWUgPSBEYXRlLm5vdygpO1xuXG4gIGV4cG9ydHMudW5zdGFibGVfbm93ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBEYXRlLm5vdygpIC0gaW5pdGlhbFRpbWU7XG4gIH07XG5cbiAgcmVxdWVzdEhvc3RDYWxsYmFjayA9IGZ1bmN0aW9uIChjYikge1xuICAgIGlmIChfY2FsbGJhY2sgIT09IG51bGwpIHtcbiAgICAgIC8vIFByb3RlY3QgYWdhaW5zdCByZS1lbnRyYW5jeS5cbiAgICAgIHNldFRpbWVvdXQocmVxdWVzdEhvc3RDYWxsYmFjaywgMCwgY2IpO1xuICAgIH0gZWxzZSB7XG4gICAgICBfY2FsbGJhY2sgPSBjYjtcbiAgICAgIHNldFRpbWVvdXQoX2ZsdXNoQ2FsbGJhY2ssIDApO1xuICAgIH1cbiAgfTtcblxuICByZXF1ZXN0SG9zdFRpbWVvdXQgPSBmdW5jdGlvbiAoY2IsIG1zKSB7XG4gICAgX3RpbWVvdXRJRCA9IHNldFRpbWVvdXQoY2IsIG1zKTtcbiAgfTtcblxuICBjYW5jZWxIb3N0VGltZW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgICBjbGVhclRpbWVvdXQoX3RpbWVvdXRJRCk7XG4gIH07XG5cbiAgc2hvdWxkWWllbGRUb0hvc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIHJlcXVlc3RQYWludCA9IGV4cG9ydHMudW5zdGFibGVfZm9yY2VGcmFtZVJhdGUgPSBmdW5jdGlvbiAoKSB7fTtcbn0gZWxzZSB7XG4gIC8vIENhcHR1cmUgbG9jYWwgcmVmZXJlbmNlcyB0byBuYXRpdmUgQVBJcywgaW4gY2FzZSBhIHBvbHlmaWxsIG92ZXJyaWRlcyB0aGVtLlxuICB2YXIgcGVyZm9ybWFuY2UgPSB3aW5kb3cucGVyZm9ybWFuY2U7XG4gIHZhciBfRGF0ZSA9IHdpbmRvdy5EYXRlO1xuICB2YXIgX3NldFRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dDtcbiAgdmFyIF9jbGVhclRpbWVvdXQgPSB3aW5kb3cuY2xlYXJUaW1lb3V0O1xuICB2YXIgcmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZTtcbiAgdmFyIGNhbmNlbEFuaW1hdGlvbkZyYW1lID0gd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lO1xuXG4gIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvLyBUT0RPOiBSZW1vdmUgZmIubWUgbGlua1xuICAgIGlmICh0eXBlb2YgcmVxdWVzdEFuaW1hdGlvbkZyYW1lICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiVGhpcyBicm93c2VyIGRvZXNuJ3Qgc3VwcG9ydCByZXF1ZXN0QW5pbWF0aW9uRnJhbWUuIFwiICsgJ01ha2Ugc3VyZSB0aGF0IHlvdSBsb2FkIGEgJyArICdwb2x5ZmlsbCBpbiBvbGRlciBicm93c2Vycy4gaHR0cHM6Ly9mYi5tZS9yZWFjdC1wb2x5ZmlsbHMnKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGNhbmNlbEFuaW1hdGlvbkZyYW1lICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiVGhpcyBicm93c2VyIGRvZXNuJ3Qgc3VwcG9ydCBjYW5jZWxBbmltYXRpb25GcmFtZS4gXCIgKyAnTWFrZSBzdXJlIHRoYXQgeW91IGxvYWQgYSAnICsgJ3BvbHlmaWxsIGluIG9sZGVyIGJyb3dzZXJzLiBodHRwczovL2ZiLm1lL3JlYWN0LXBvbHlmaWxscycpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgcGVyZm9ybWFuY2UgPT09ICdvYmplY3QnICYmIHR5cGVvZiBwZXJmb3JtYW5jZS5ub3cgPT09ICdmdW5jdGlvbicpIHtcbiAgICBleHBvcnRzLnVuc3RhYmxlX25vdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHZhciBfaW5pdGlhbFRpbWUgPSBfRGF0ZS5ub3coKTtcblxuICAgIGV4cG9ydHMudW5zdGFibGVfbm93ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF9EYXRlLm5vdygpIC0gX2luaXRpYWxUaW1lO1xuICAgIH07XG4gIH1cblxuICB2YXIgaXNSQUZMb29wUnVubmluZyA9IGZhbHNlO1xuICB2YXIgaXNNZXNzYWdlTG9vcFJ1bm5pbmcgPSBmYWxzZTtcbiAgdmFyIHNjaGVkdWxlZEhvc3RDYWxsYmFjayA9IG51bGw7XG4gIHZhciByQUZUaW1lb3V0SUQgPSAtMTtcbiAgdmFyIHRhc2tUaW1lb3V0SUQgPSAtMTtcbiAgdmFyIGZyYW1lTGVuZ3RoID0gZW5hYmxlTWVzc2FnZUxvb3BJbXBsZW1lbnRhdGlvbiA/IC8vIFdlIHdvbid0IGF0dGVtcHQgdG8gYWxpZ24gd2l0aCB0aGUgdnN5bmMuIEluc3RlYWQgd2UnbGwgeWllbGQgbXVsdGlwbGVcbiAgLy8gdGltZXMgcGVyIGZyYW1lLCBvZnRlbiBlbm91Z2ggdG8ga2VlcCBpdCByZXNwb25zaXZlIGV2ZW4gYXQgcmVhbGx5XG4gIC8vIGhpZ2ggZnJhbWUgcmF0ZXMgPiAxMjAuXG4gIDUgOiAvLyBVc2UgYSBoZXVyaXN0aWMgdG8gbWVhc3VyZSB0aGUgZnJhbWUgcmF0ZSBhbmQgeWllbGQgYXQgdGhlIGVuZCBvZiB0aGVcbiAgLy8gZnJhbWUuIFdlIHN0YXJ0IG91dCBhc3N1bWluZyB0aGF0IHdlIHJ1biBhdCAzMGZwcyBidXQgdGhlbiB0aGVcbiAgLy8gaGV1cmlzdGljIHRyYWNraW5nIHdpbGwgYWRqdXN0IHRoaXMgdmFsdWUgdG8gYSBmYXN0ZXIgZnBzIGlmIHdlIGdldFxuICAvLyBtb3JlIGZyZXF1ZW50IGFuaW1hdGlvbiBmcmFtZXMuXG4gIDMzLjMzO1xuICB2YXIgcHJldlJBRlRpbWUgPSAtMTtcbiAgdmFyIHByZXZSQUZJbnRlcnZhbCA9IC0xO1xuICB2YXIgZnJhbWVEZWFkbGluZSA9IDA7XG4gIHZhciBmcHNMb2NrZWQgPSBmYWxzZTsgLy8gVE9ETzogTWFrZSB0aGlzIGNvbmZpZ3VyYWJsZVxuICAvLyBUT0RPOiBBZGp1c3QgdGhpcyBiYXNlZCBvbiBwcmlvcml0eT9cblxuICB2YXIgbWF4RnJhbWVMZW5ndGggPSAzMDA7XG4gIHZhciBuZWVkc1BhaW50ID0gZmFsc2U7XG5cbiAgaWYgKGVuYWJsZUlzSW5wdXRQZW5kaW5nICYmIG5hdmlnYXRvciAhPT0gdW5kZWZpbmVkICYmIG5hdmlnYXRvci5zY2hlZHVsaW5nICE9PSB1bmRlZmluZWQgJiYgbmF2aWdhdG9yLnNjaGVkdWxpbmcuaXNJbnB1dFBlbmRpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBzY2hlZHVsaW5nID0gbmF2aWdhdG9yLnNjaGVkdWxpbmc7XG5cbiAgICBzaG91bGRZaWVsZFRvSG9zdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBjdXJyZW50VGltZSA9IGV4cG9ydHMudW5zdGFibGVfbm93KCk7XG5cbiAgICAgIGlmIChjdXJyZW50VGltZSA+PSBmcmFtZURlYWRsaW5lKSB7XG4gICAgICAgIC8vIFRoZXJlJ3Mgbm8gdGltZSBsZWZ0IGluIHRoZSBmcmFtZS4gV2UgbWF5IHdhbnQgdG8geWllbGQgY29udHJvbCBvZlxuICAgICAgICAvLyB0aGUgbWFpbiB0aHJlYWQsIHNvIHRoZSBicm93c2VyIGNhbiBwZXJmb3JtIGhpZ2ggcHJpb3JpdHkgdGFza3MuIFRoZVxuICAgICAgICAvLyBtYWluIG9uZXMgYXJlIHBhaW50aW5nIGFuZCB1c2VyIGlucHV0LiBJZiB0aGVyZSdzIGEgcGVuZGluZyBwYWludCBvclxuICAgICAgICAvLyBhIHBlbmRpbmcgaW5wdXQsIHRoZW4gd2Ugc2hvdWxkIHlpZWxkLiBCdXQgaWYgdGhlcmUncyBuZWl0aGVyLCB0aGVuXG4gICAgICAgIC8vIHdlIGNhbiB5aWVsZCBsZXNzIG9mdGVuIHdoaWxlIHJlbWFpbmluZyByZXNwb25zaXZlLiBXZSdsbCBldmVudHVhbGx5XG4gICAgICAgIC8vIHlpZWxkIHJlZ2FyZGxlc3MsIHNpbmNlIHRoZXJlIGNvdWxkIGJlIGEgcGVuZGluZyBwYWludCB0aGF0IHdhc24ndFxuICAgICAgICAvLyBhY2NvbXBhbmllZCBieSBhIGNhbGwgdG8gYHJlcXVlc3RQYWludGAsIG9yIG90aGVyIG1haW4gdGhyZWFkIHRhc2tzXG4gICAgICAgIC8vIGxpa2UgbmV0d29yayBldmVudHMuXG4gICAgICAgIGlmIChuZWVkc1BhaW50IHx8IHNjaGVkdWxpbmcuaXNJbnB1dFBlbmRpbmcoKSkge1xuICAgICAgICAgIC8vIFRoZXJlIGlzIGVpdGhlciBhIHBlbmRpbmcgcGFpbnQgb3IgYSBwZW5kaW5nIGlucHV0LlxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IC8vIFRoZXJlJ3Mgbm8gcGVuZGluZyBpbnB1dC4gT25seSB5aWVsZCBpZiB3ZSd2ZSByZWFjaGVkIHRoZSBtYXhcbiAgICAgICAgLy8gZnJhbWUgbGVuZ3RoLlxuXG5cbiAgICAgICAgcmV0dXJuIGN1cnJlbnRUaW1lID49IGZyYW1lRGVhZGxpbmUgKyBtYXhGcmFtZUxlbmd0aDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRoZXJlJ3Mgc3RpbGwgdGltZSBsZWZ0IGluIHRoZSBmcmFtZS5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH07XG5cbiAgICByZXF1ZXN0UGFpbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBuZWVkc1BhaW50ID0gdHJ1ZTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIC8vIGBpc0lucHV0UGVuZGluZ2AgaXMgbm90IGF2YWlsYWJsZS4gU2luY2Ugd2UgaGF2ZSBubyB3YXkgb2Yga25vd2luZyBpZlxuICAgIC8vIHRoZXJlJ3MgcGVuZGluZyBpbnB1dCwgYWx3YXlzIHlpZWxkIGF0IHRoZSBlbmQgb2YgdGhlIGZyYW1lLlxuICAgIHNob3VsZFlpZWxkVG9Ib3N0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGV4cG9ydHMudW5zdGFibGVfbm93KCkgPj0gZnJhbWVEZWFkbGluZTtcbiAgICB9OyAvLyBTaW5jZSB3ZSB5aWVsZCBldmVyeSBmcmFtZSByZWdhcmRsZXNzLCBgcmVxdWVzdFBhaW50YCBoYXMgbm8gZWZmZWN0LlxuXG5cbiAgICByZXF1ZXN0UGFpbnQgPSBmdW5jdGlvbiAoKSB7fTtcbiAgfVxuXG4gIGV4cG9ydHMudW5zdGFibGVfZm9yY2VGcmFtZVJhdGUgPSBmdW5jdGlvbiAoZnBzKSB7XG4gICAgaWYgKGZwcyA8IDAgfHwgZnBzID4gMTI1KSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdmb3JjZUZyYW1lUmF0ZSB0YWtlcyBhIHBvc2l0aXZlIGludCBiZXR3ZWVuIDAgYW5kIDEyNSwgJyArICdmb3JjaW5nIGZyYW1lcmF0ZXMgaGlnaGVyIHRoYW4gMTI1IGZwcyBpcyBub3QgdW5zdXBwb3J0ZWQnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZnBzID4gMCkge1xuICAgICAgZnJhbWVMZW5ndGggPSBNYXRoLmZsb29yKDEwMDAgLyBmcHMpO1xuICAgICAgZnBzTG9ja2VkID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gcmVzZXQgdGhlIGZyYW1lcmF0ZVxuICAgICAgZnJhbWVMZW5ndGggPSAzMy4zMztcbiAgICAgIGZwc0xvY2tlZCA9IGZhbHNlO1xuICAgIH1cbiAgfTtcblxuICB2YXIgcGVyZm9ybVdvcmtVbnRpbERlYWRsaW5lID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChlbmFibGVNZXNzYWdlTG9vcEltcGxlbWVudGF0aW9uKSB7XG4gICAgICBpZiAoc2NoZWR1bGVkSG9zdENhbGxiYWNrICE9PSBudWxsKSB7XG4gICAgICAgIHZhciBjdXJyZW50VGltZSA9IGV4cG9ydHMudW5zdGFibGVfbm93KCk7IC8vIFlpZWxkIGFmdGVyIGBmcmFtZUxlbmd0aGAgbXMsIHJlZ2FyZGxlc3Mgb2Ygd2hlcmUgd2UgYXJlIGluIHRoZSB2c3luY1xuICAgICAgICAvLyBjeWNsZS4gVGhpcyBtZWFucyB0aGVyZSdzIGFsd2F5cyB0aW1lIHJlbWFpbmluZyBhdCB0aGUgYmVnaW5uaW5nIG9mXG4gICAgICAgIC8vIHRoZSBtZXNzYWdlIGV2ZW50LlxuXG4gICAgICAgIGZyYW1lRGVhZGxpbmUgPSBjdXJyZW50VGltZSArIGZyYW1lTGVuZ3RoO1xuICAgICAgICB2YXIgaGFzVGltZVJlbWFpbmluZyA9IHRydWU7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB2YXIgaGFzTW9yZVdvcmsgPSBzY2hlZHVsZWRIb3N0Q2FsbGJhY2soaGFzVGltZVJlbWFpbmluZywgY3VycmVudFRpbWUpO1xuXG4gICAgICAgICAgaWYgKCFoYXNNb3JlV29yaykge1xuICAgICAgICAgICAgaXNNZXNzYWdlTG9vcFJ1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHNjaGVkdWxlZEhvc3RDYWxsYmFjayA9IG51bGw7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIElmIHRoZXJlJ3MgbW9yZSB3b3JrLCBzY2hlZHVsZSB0aGUgbmV4dCBtZXNzYWdlIGV2ZW50IGF0IHRoZSBlbmRcbiAgICAgICAgICAgIC8vIG9mIHRoZSBwcmVjZWRpbmcgb25lLlxuICAgICAgICAgICAgcG9ydC5wb3N0TWVzc2FnZShudWxsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgLy8gSWYgYSBzY2hlZHVsZXIgdGFzayB0aHJvd3MsIGV4aXQgdGhlIGN1cnJlbnQgYnJvd3NlciB0YXNrIHNvIHRoZVxuICAgICAgICAgIC8vIGVycm9yIGNhbiBiZSBvYnNlcnZlZC5cbiAgICAgICAgICBwb3J0LnBvc3RNZXNzYWdlKG51bGwpO1xuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpc01lc3NhZ2VMb29wUnVubmluZyA9IGZhbHNlO1xuICAgICAgfSAvLyBZaWVsZGluZyB0byB0aGUgYnJvd3NlciB3aWxsIGdpdmUgaXQgYSBjaGFuY2UgdG8gcGFpbnQsIHNvIHdlIGNhblxuICAgICAgLy8gcmVzZXQgdGhpcy5cblxuXG4gICAgICBuZWVkc1BhaW50ID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChzY2hlZHVsZWRIb3N0Q2FsbGJhY2sgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIF9jdXJyZW50VGltZSA9IGV4cG9ydHMudW5zdGFibGVfbm93KCk7XG5cbiAgICAgICAgdmFyIF9oYXNUaW1lUmVtYWluaW5nID0gZnJhbWVEZWFkbGluZSAtIF9jdXJyZW50VGltZSA+IDA7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB2YXIgX2hhc01vcmVXb3JrID0gc2NoZWR1bGVkSG9zdENhbGxiYWNrKF9oYXNUaW1lUmVtYWluaW5nLCBfY3VycmVudFRpbWUpO1xuXG4gICAgICAgICAgaWYgKCFfaGFzTW9yZVdvcmspIHtcbiAgICAgICAgICAgIHNjaGVkdWxlZEhvc3RDYWxsYmFjayA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIC8vIElmIGEgc2NoZWR1bGVyIHRhc2sgdGhyb3dzLCBleGl0IHRoZSBjdXJyZW50IGJyb3dzZXIgdGFzayBzbyB0aGVcbiAgICAgICAgICAvLyBlcnJvciBjYW4gYmUgb2JzZXJ2ZWQsIGFuZCBwb3N0IGEgbmV3IHRhc2sgYXMgc29vbiBhcyBwb3NzaWJsZVxuICAgICAgICAgIC8vIHNvIHdlIGNhbiBjb250aW51ZSB3aGVyZSB3ZSBsZWZ0IG9mZi5cbiAgICAgICAgICBwb3J0LnBvc3RNZXNzYWdlKG51bGwpO1xuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICB9IC8vIFlpZWxkaW5nIHRvIHRoZSBicm93c2VyIHdpbGwgZ2l2ZSBpdCBhIGNoYW5jZSB0byBwYWludCwgc28gd2UgY2FuXG4gICAgICAvLyByZXNldCB0aGlzLlxuXG5cbiAgICAgIG5lZWRzUGFpbnQgPSBmYWxzZTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgdmFyIHBvcnQgPSBjaGFubmVsLnBvcnQyO1xuICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IHBlcmZvcm1Xb3JrVW50aWxEZWFkbGluZTtcblxuICB2YXIgb25BbmltYXRpb25GcmFtZSA9IGZ1bmN0aW9uIChyQUZUaW1lKSB7XG4gICAgaWYgKHNjaGVkdWxlZEhvc3RDYWxsYmFjayA9PT0gbnVsbCkge1xuICAgICAgLy8gTm8gc2NoZWR1bGVkIHdvcmsuIEV4aXQuXG4gICAgICBwcmV2UkFGVGltZSA9IC0xO1xuICAgICAgcHJldlJBRkludGVydmFsID0gLTE7XG4gICAgICBpc1JBRkxvb3BSdW5uaW5nID0gZmFsc2U7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBFYWdlcmx5IHNjaGVkdWxlIHRoZSBuZXh0IGFuaW1hdGlvbiBjYWxsYmFjayBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZVxuICAgIC8vIGZyYW1lLiBJZiB0aGUgc2NoZWR1bGVyIHF1ZXVlIGlzIG5vdCBlbXB0eSBhdCB0aGUgZW5kIG9mIHRoZSBmcmFtZSwgaXRcbiAgICAvLyB3aWxsIGNvbnRpbnVlIGZsdXNoaW5nIGluc2lkZSB0aGF0IGNhbGxiYWNrLiBJZiB0aGUgcXVldWUgKmlzKiBlbXB0eSxcbiAgICAvLyB0aGVuIGl0IHdpbGwgZXhpdCBpbW1lZGlhdGVseS4gUG9zdGluZyB0aGUgY2FsbGJhY2sgYXQgdGhlIHN0YXJ0IG9mIHRoZVxuICAgIC8vIGZyYW1lIGVuc3VyZXMgaXQncyBmaXJlZCB3aXRoaW4gdGhlIGVhcmxpZXN0IHBvc3NpYmxlIGZyYW1lLiBJZiB3ZVxuICAgIC8vIHdhaXRlZCB1bnRpbCB0aGUgZW5kIG9mIHRoZSBmcmFtZSB0byBwb3N0IHRoZSBjYWxsYmFjaywgd2UgcmlzayB0aGVcbiAgICAvLyBicm93c2VyIHNraXBwaW5nIGEgZnJhbWUgYW5kIG5vdCBmaXJpbmcgdGhlIGNhbGxiYWNrIHVudGlsIHRoZSBmcmFtZVxuICAgIC8vIGFmdGVyIHRoYXQuXG5cblxuICAgIGlzUkFGTG9vcFJ1bm5pbmcgPSB0cnVlO1xuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAobmV4dFJBRlRpbWUpIHtcbiAgICAgIF9jbGVhclRpbWVvdXQockFGVGltZW91dElEKTtcblxuICAgICAgb25BbmltYXRpb25GcmFtZShuZXh0UkFGVGltZSk7XG4gICAgfSk7IC8vIHJlcXVlc3RBbmltYXRpb25GcmFtZSBpcyB0aHJvdHRsZWQgd2hlbiB0aGUgdGFiIGlzIGJhY2tncm91bmRlZC4gV2VcbiAgICAvLyBkb24ndCB3YW50IHRvIHN0b3Agd29ya2luZyBlbnRpcmVseS4gU28gd2UnbGwgZmFsbGJhY2sgdG8gYSB0aW1lb3V0IGxvb3AuXG4gICAgLy8gVE9ETzogTmVlZCBhIGJldHRlciBoZXVyaXN0aWMgZm9yIGJhY2tncm91bmRlZCB3b3JrLlxuXG4gICAgdmFyIG9uVGltZW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGZyYW1lRGVhZGxpbmUgPSBleHBvcnRzLnVuc3RhYmxlX25vdygpICsgZnJhbWVMZW5ndGggLyAyO1xuICAgICAgcGVyZm9ybVdvcmtVbnRpbERlYWRsaW5lKCk7XG4gICAgICByQUZUaW1lb3V0SUQgPSBfc2V0VGltZW91dChvblRpbWVvdXQsIGZyYW1lTGVuZ3RoICogMyk7XG4gICAgfTtcblxuICAgIHJBRlRpbWVvdXRJRCA9IF9zZXRUaW1lb3V0KG9uVGltZW91dCwgZnJhbWVMZW5ndGggKiAzKTtcblxuICAgIGlmIChwcmV2UkFGVGltZSAhPT0gLTEgJiYgLy8gTWFrZSBzdXJlIHRoaXMgckFGIHRpbWUgaXMgZGlmZmVyZW50IGZyb20gdGhlIHByZXZpb3VzIG9uZS4gVGhpcyBjaGVja1xuICAgIC8vIGNvdWxkIGZhaWwgaWYgdHdvIHJBRnMgZmlyZSBpbiB0aGUgc2FtZSBmcmFtZS5cbiAgICByQUZUaW1lIC0gcHJldlJBRlRpbWUgPiAwLjEpIHtcbiAgICAgIHZhciByQUZJbnRlcnZhbCA9IHJBRlRpbWUgLSBwcmV2UkFGVGltZTtcblxuICAgICAgaWYgKCFmcHNMb2NrZWQgJiYgcHJldlJBRkludGVydmFsICE9PSAtMSkge1xuICAgICAgICAvLyBXZSd2ZSBvYnNlcnZlZCB0d28gY29uc2VjdXRpdmUgZnJhbWUgaW50ZXJ2YWxzLiBXZSdsbCB1c2UgdGhpcyB0b1xuICAgICAgICAvLyBkeW5hbWljYWxseSBhZGp1c3QgdGhlIGZyYW1lIHJhdGUuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIElmIG9uZSBmcmFtZSBnb2VzIGxvbmcsIHRoZW4gdGhlIG5leHQgb25lIGNhbiBiZSBzaG9ydCB0byBjYXRjaCB1cC5cbiAgICAgICAgLy8gSWYgdHdvIGZyYW1lcyBhcmUgc2hvcnQgaW4gYSByb3csIHRoZW4gdGhhdCdzIGFuIGluZGljYXRpb24gdGhhdCB3ZVxuICAgICAgICAvLyBhY3R1YWxseSBoYXZlIGEgaGlnaGVyIGZyYW1lIHJhdGUgdGhhbiB3aGF0IHdlJ3JlIGN1cnJlbnRseVxuICAgICAgICAvLyBvcHRpbWl6aW5nLiBGb3IgZXhhbXBsZSwgaWYgd2UncmUgcnVubmluZyBvbiAxMjBoeiBkaXNwbGF5IG9yIDkwaHogVlJcbiAgICAgICAgLy8gZGlzcGxheS4gVGFrZSB0aGUgbWF4IG9mIHRoZSB0d28gaW4gY2FzZSBvbmUgb2YgdGhlbSB3YXMgYW4gYW5vbWFseVxuICAgICAgICAvLyBkdWUgdG8gbWlzc2VkIGZyYW1lIGRlYWRsaW5lcy5cbiAgICAgICAgaWYgKHJBRkludGVydmFsIDwgZnJhbWVMZW5ndGggJiYgcHJldlJBRkludGVydmFsIDwgZnJhbWVMZW5ndGgpIHtcbiAgICAgICAgICBmcmFtZUxlbmd0aCA9IHJBRkludGVydmFsIDwgcHJldlJBRkludGVydmFsID8gcHJldlJBRkludGVydmFsIDogckFGSW50ZXJ2YWw7XG5cbiAgICAgICAgICBpZiAoZnJhbWVMZW5ndGggPCA4LjMzKSB7XG4gICAgICAgICAgICAvLyBEZWZlbnNpdmUgY29kaW5nLiBXZSBkb24ndCBzdXBwb3J0IGhpZ2hlciBmcmFtZSByYXRlcyB0aGFuIDEyMGh6LlxuICAgICAgICAgICAgLy8gSWYgdGhlIGNhbGN1bGF0ZWQgZnJhbWUgbGVuZ3RoIGdldHMgbG93ZXIgdGhhbiA4LCBpdCBpcyBwcm9iYWJseVxuICAgICAgICAgICAgLy8gYSBidWcuXG4gICAgICAgICAgICBmcmFtZUxlbmd0aCA9IDguMzM7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHByZXZSQUZJbnRlcnZhbCA9IHJBRkludGVydmFsO1xuICAgIH1cblxuICAgIHByZXZSQUZUaW1lID0gckFGVGltZTtcbiAgICBmcmFtZURlYWRsaW5lID0gckFGVGltZSArIGZyYW1lTGVuZ3RoOyAvLyBXZSB1c2UgdGhlIHBvc3RNZXNzYWdlIHRyaWNrIHRvIGRlZmVyIGlkbGUgd29yayB1bnRpbCBhZnRlciB0aGUgcmVwYWludC5cblxuICAgIHBvcnQucG9zdE1lc3NhZ2UobnVsbCk7XG4gIH07XG5cbiAgcmVxdWVzdEhvc3RDYWxsYmFjayA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIHNjaGVkdWxlZEhvc3RDYWxsYmFjayA9IGNhbGxiYWNrO1xuXG4gICAgaWYgKGVuYWJsZU1lc3NhZ2VMb29wSW1wbGVtZW50YXRpb24pIHtcbiAgICAgIGlmICghaXNNZXNzYWdlTG9vcFJ1bm5pbmcpIHtcbiAgICAgICAgaXNNZXNzYWdlTG9vcFJ1bm5pbmcgPSB0cnVlO1xuICAgICAgICBwb3J0LnBvc3RNZXNzYWdlKG51bGwpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIWlzUkFGTG9vcFJ1bm5pbmcpIHtcbiAgICAgICAgLy8gU3RhcnQgYSByQUYgbG9vcC5cbiAgICAgICAgaXNSQUZMb29wUnVubmluZyA9IHRydWU7XG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAockFGVGltZSkge1xuICAgICAgICAgIG9uQW5pbWF0aW9uRnJhbWUockFGVGltZSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICByZXF1ZXN0SG9zdFRpbWVvdXQgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIG1zKSB7XG4gICAgdGFza1RpbWVvdXRJRCA9IF9zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGNhbGxiYWNrKGV4cG9ydHMudW5zdGFibGVfbm93KCkpO1xuICAgIH0sIG1zKTtcbiAgfTtcblxuICBjYW5jZWxIb3N0VGltZW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgICBfY2xlYXJUaW1lb3V0KHRhc2tUaW1lb3V0SUQpO1xuXG4gICAgdGFza1RpbWVvdXRJRCA9IC0xO1xuICB9O1xufVxuXG5mdW5jdGlvbiBwdXNoKGhlYXAsIG5vZGUpIHtcbiAgdmFyIGluZGV4ID0gaGVhcC5sZW5ndGg7XG4gIGhlYXAucHVzaChub2RlKTtcbiAgc2lmdFVwKGhlYXAsIG5vZGUsIGluZGV4KTtcbn1cbmZ1bmN0aW9uIHBlZWsoaGVhcCkge1xuICB2YXIgZmlyc3QgPSBoZWFwWzBdO1xuICByZXR1cm4gZmlyc3QgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBmaXJzdDtcbn1cbmZ1bmN0aW9uIHBvcChoZWFwKSB7XG4gIHZhciBmaXJzdCA9IGhlYXBbMF07XG5cbiAgaWYgKGZpcnN0ICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgbGFzdCA9IGhlYXAucG9wKCk7XG5cbiAgICBpZiAobGFzdCAhPT0gZmlyc3QpIHtcbiAgICAgIGhlYXBbMF0gPSBsYXN0O1xuICAgICAgc2lmdERvd24oaGVhcCwgbGFzdCwgMCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZpcnN0O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNpZnRVcChoZWFwLCBub2RlLCBpKSB7XG4gIHZhciBpbmRleCA9IGk7XG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICB2YXIgcGFyZW50SW5kZXggPSBNYXRoLmZsb29yKChpbmRleCAtIDEpIC8gMik7XG4gICAgdmFyIHBhcmVudCA9IGhlYXBbcGFyZW50SW5kZXhdO1xuXG4gICAgaWYgKHBhcmVudCAhPT0gdW5kZWZpbmVkICYmIGNvbXBhcmUocGFyZW50LCBub2RlKSA+IDApIHtcbiAgICAgIC8vIFRoZSBwYXJlbnQgaXMgbGFyZ2VyLiBTd2FwIHBvc2l0aW9ucy5cbiAgICAgIGhlYXBbcGFyZW50SW5kZXhdID0gbm9kZTtcbiAgICAgIGhlYXBbaW5kZXhdID0gcGFyZW50O1xuICAgICAgaW5kZXggPSBwYXJlbnRJbmRleDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhlIHBhcmVudCBpcyBzbWFsbGVyLiBFeGl0LlxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzaWZ0RG93bihoZWFwLCBub2RlLCBpKSB7XG4gIHZhciBpbmRleCA9IGk7XG4gIHZhciBsZW5ndGggPSBoZWFwLmxlbmd0aDtcblxuICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgbGVmdEluZGV4ID0gKGluZGV4ICsgMSkgKiAyIC0gMTtcbiAgICB2YXIgbGVmdCA9IGhlYXBbbGVmdEluZGV4XTtcbiAgICB2YXIgcmlnaHRJbmRleCA9IGxlZnRJbmRleCArIDE7XG4gICAgdmFyIHJpZ2h0ID0gaGVhcFtyaWdodEluZGV4XTsgLy8gSWYgdGhlIGxlZnQgb3IgcmlnaHQgbm9kZSBpcyBzbWFsbGVyLCBzd2FwIHdpdGggdGhlIHNtYWxsZXIgb2YgdGhvc2UuXG5cbiAgICBpZiAobGVmdCAhPT0gdW5kZWZpbmVkICYmIGNvbXBhcmUobGVmdCwgbm9kZSkgPCAwKSB7XG4gICAgICBpZiAocmlnaHQgIT09IHVuZGVmaW5lZCAmJiBjb21wYXJlKHJpZ2h0LCBsZWZ0KSA8IDApIHtcbiAgICAgICAgaGVhcFtpbmRleF0gPSByaWdodDtcbiAgICAgICAgaGVhcFtyaWdodEluZGV4XSA9IG5vZGU7XG4gICAgICAgIGluZGV4ID0gcmlnaHRJbmRleDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhlYXBbaW5kZXhdID0gbGVmdDtcbiAgICAgICAgaGVhcFtsZWZ0SW5kZXhdID0gbm9kZTtcbiAgICAgICAgaW5kZXggPSBsZWZ0SW5kZXg7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChyaWdodCAhPT0gdW5kZWZpbmVkICYmIGNvbXBhcmUocmlnaHQsIG5vZGUpIDwgMCkge1xuICAgICAgaGVhcFtpbmRleF0gPSByaWdodDtcbiAgICAgIGhlYXBbcmlnaHRJbmRleF0gPSBub2RlO1xuICAgICAgaW5kZXggPSByaWdodEluZGV4O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBOZWl0aGVyIGNoaWxkIGlzIHNtYWxsZXIuIEV4aXQuXG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbXBhcmUoYSwgYikge1xuICAvLyBDb21wYXJlIHNvcnQgaW5kZXggZmlyc3QsIHRoZW4gdGFzayBpZC5cbiAgdmFyIGRpZmYgPSBhLnNvcnRJbmRleCAtIGIuc29ydEluZGV4O1xuICByZXR1cm4gZGlmZiAhPT0gMCA/IGRpZmYgOiBhLmlkIC0gYi5pZDtcbn1cblxuLy8gVE9ETzogVXNlIHN5bWJvbHM/XG52YXIgTm9Qcmlvcml0eSA9IDA7XG52YXIgSW1tZWRpYXRlUHJpb3JpdHkgPSAxO1xudmFyIFVzZXJCbG9ja2luZ1ByaW9yaXR5ID0gMjtcbnZhciBOb3JtYWxQcmlvcml0eSA9IDM7XG52YXIgTG93UHJpb3JpdHkgPSA0O1xudmFyIElkbGVQcmlvcml0eSA9IDU7XG5cbnZhciBydW5JZENvdW50ZXIgPSAwO1xudmFyIG1haW5UaHJlYWRJZENvdW50ZXIgPSAwO1xudmFyIHByb2ZpbGluZ1N0YXRlU2l6ZSA9IDQ7XG52YXIgc2hhcmVkUHJvZmlsaW5nQnVmZmVyID0gZW5hYmxlUHJvZmlsaW5nID8gLy8gJEZsb3dGaXhNZSBGbG93IGRvZXNuJ3Qga25vdyBhYm91dCBTaGFyZWRBcnJheUJ1ZmZlclxudHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyID09PSAnZnVuY3Rpb24nID8gbmV3IFNoYXJlZEFycmF5QnVmZmVyKHByb2ZpbGluZ1N0YXRlU2l6ZSAqIEludDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQpIDogLy8gJEZsb3dGaXhNZSBGbG93IGRvZXNuJ3Qga25vdyBhYm91dCBBcnJheUJ1ZmZlclxudHlwZW9mIEFycmF5QnVmZmVyID09PSAnZnVuY3Rpb24nID8gbmV3IEFycmF5QnVmZmVyKHByb2ZpbGluZ1N0YXRlU2l6ZSAqIEludDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQpIDogbnVsbCAvLyBEb24ndCBjcmFzaCB0aGUgaW5pdCBwYXRoIG9uIElFOVxuOiBudWxsO1xudmFyIHByb2ZpbGluZ1N0YXRlID0gZW5hYmxlUHJvZmlsaW5nICYmIHNoYXJlZFByb2ZpbGluZ0J1ZmZlciAhPT0gbnVsbCA/IG5ldyBJbnQzMkFycmF5KHNoYXJlZFByb2ZpbGluZ0J1ZmZlcikgOiBbXTsgLy8gV2UgY2FuJ3QgcmVhZCB0aGlzIGJ1dCBpdCBoZWxwcyBzYXZlIGJ5dGVzIGZvciBudWxsIGNoZWNrc1xuXG52YXIgUFJJT1JJVFkgPSAwO1xudmFyIENVUlJFTlRfVEFTS19JRCA9IDE7XG52YXIgQ1VSUkVOVF9SVU5fSUQgPSAyO1xudmFyIFFVRVVFX1NJWkUgPSAzO1xuXG5pZiAoZW5hYmxlUHJvZmlsaW5nKSB7XG4gIHByb2ZpbGluZ1N0YXRlW1BSSU9SSVRZXSA9IE5vUHJpb3JpdHk7IC8vIFRoaXMgaXMgbWFpbnRhaW5lZCB3aXRoIGEgY291bnRlciwgYmVjYXVzZSB0aGUgc2l6ZSBvZiB0aGUgcHJpb3JpdHkgcXVldWVcbiAgLy8gYXJyYXkgbWlnaHQgaW5jbHVkZSBjYW5jZWxlZCB0YXNrcy5cblxuICBwcm9maWxpbmdTdGF0ZVtRVUVVRV9TSVpFXSA9IDA7XG4gIHByb2ZpbGluZ1N0YXRlW0NVUlJFTlRfVEFTS19JRF0gPSAwO1xufSAvLyBCeXRlcyBwZXIgZWxlbWVudCBpcyA0XG5cblxudmFyIElOSVRJQUxfRVZFTlRfTE9HX1NJWkUgPSAxMzEwNzI7XG52YXIgTUFYX0VWRU5UX0xPR19TSVpFID0gNTI0Mjg4OyAvLyBFcXVpdmFsZW50IHRvIDIgbWVnYWJ5dGVzXG5cbnZhciBldmVudExvZ1NpemUgPSAwO1xudmFyIGV2ZW50TG9nQnVmZmVyID0gbnVsbDtcbnZhciBldmVudExvZyA9IG51bGw7XG52YXIgZXZlbnRMb2dJbmRleCA9IDA7XG52YXIgVGFza1N0YXJ0RXZlbnQgPSAxO1xudmFyIFRhc2tDb21wbGV0ZUV2ZW50ID0gMjtcbnZhciBUYXNrRXJyb3JFdmVudCA9IDM7XG52YXIgVGFza0NhbmNlbEV2ZW50ID0gNDtcbnZhciBUYXNrUnVuRXZlbnQgPSA1O1xudmFyIFRhc2tZaWVsZEV2ZW50ID0gNjtcbnZhciBTY2hlZHVsZXJTdXNwZW5kRXZlbnQgPSA3O1xudmFyIFNjaGVkdWxlclJlc3VtZUV2ZW50ID0gODtcblxuZnVuY3Rpb24gbG9nRXZlbnQoZW50cmllcykge1xuICBpZiAoZXZlbnRMb2cgIT09IG51bGwpIHtcbiAgICB2YXIgb2Zmc2V0ID0gZXZlbnRMb2dJbmRleDtcbiAgICBldmVudExvZ0luZGV4ICs9IGVudHJpZXMubGVuZ3RoO1xuXG4gICAgaWYgKGV2ZW50TG9nSW5kZXggKyAxID4gZXZlbnRMb2dTaXplKSB7XG4gICAgICBldmVudExvZ1NpemUgKj0gMjtcblxuICAgICAgaWYgKGV2ZW50TG9nU2l6ZSA+IE1BWF9FVkVOVF9MT0dfU0laRSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiU2NoZWR1bGVyIFByb2ZpbGluZzogRXZlbnQgbG9nIGV4Y2VlZGVkIG1heGltdW0gc2l6ZS4gRG9uJ3QgXCIgKyAnZm9yZ2V0IHRvIGNhbGwgYHN0b3BMb2dnaW5nUHJvZmlsaW5nRXZlbnRzKClgLicpO1xuICAgICAgICBzdG9wTG9nZ2luZ1Byb2ZpbGluZ0V2ZW50cygpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBuZXdFdmVudExvZyA9IG5ldyBJbnQzMkFycmF5KGV2ZW50TG9nU2l6ZSAqIDQpO1xuICAgICAgbmV3RXZlbnRMb2cuc2V0KGV2ZW50TG9nKTtcbiAgICAgIGV2ZW50TG9nQnVmZmVyID0gbmV3RXZlbnRMb2cuYnVmZmVyO1xuICAgICAgZXZlbnRMb2cgPSBuZXdFdmVudExvZztcbiAgICB9XG5cbiAgICBldmVudExvZy5zZXQoZW50cmllcywgb2Zmc2V0KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdGFydExvZ2dpbmdQcm9maWxpbmdFdmVudHMoKSB7XG4gIGV2ZW50TG9nU2l6ZSA9IElOSVRJQUxfRVZFTlRfTE9HX1NJWkU7XG4gIGV2ZW50TG9nQnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKGV2ZW50TG9nU2l6ZSAqIDQpO1xuICBldmVudExvZyA9IG5ldyBJbnQzMkFycmF5KGV2ZW50TG9nQnVmZmVyKTtcbiAgZXZlbnRMb2dJbmRleCA9IDA7XG59XG5mdW5jdGlvbiBzdG9wTG9nZ2luZ1Byb2ZpbGluZ0V2ZW50cygpIHtcbiAgdmFyIGJ1ZmZlciA9IGV2ZW50TG9nQnVmZmVyO1xuICBldmVudExvZ1NpemUgPSAwO1xuICBldmVudExvZ0J1ZmZlciA9IG51bGw7XG4gIGV2ZW50TG9nID0gbnVsbDtcbiAgZXZlbnRMb2dJbmRleCA9IDA7XG4gIHJldHVybiBidWZmZXI7XG59XG5mdW5jdGlvbiBtYXJrVGFza1N0YXJ0KHRhc2ssIG1zKSB7XG4gIGlmIChlbmFibGVQcm9maWxpbmcpIHtcbiAgICBwcm9maWxpbmdTdGF0ZVtRVUVVRV9TSVpFXSsrO1xuXG4gICAgaWYgKGV2ZW50TG9nICE9PSBudWxsKSB7XG4gICAgICAvLyBwZXJmb3JtYW5jZS5ub3cgcmV0dXJucyBhIGZsb2F0LCByZXByZXNlbnRpbmcgbWlsbGlzZWNvbmRzLiBXaGVuIHRoZVxuICAgICAgLy8gZXZlbnQgaXMgbG9nZ2VkLCBpdCdzIGNvZXJjZWQgdG8gYW4gaW50LiBDb252ZXJ0IHRvIG1pY3Jvc2Vjb25kcyB0b1xuICAgICAgLy8gbWFpbnRhaW4gZXh0cmEgZGVncmVlcyBvZiBwcmVjaXNpb24uXG4gICAgICBsb2dFdmVudChbVGFza1N0YXJ0RXZlbnQsIG1zICogMTAwMCwgdGFzay5pZCwgdGFzay5wcmlvcml0eUxldmVsXSk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBtYXJrVGFza0NvbXBsZXRlZCh0YXNrLCBtcykge1xuICBpZiAoZW5hYmxlUHJvZmlsaW5nKSB7XG4gICAgcHJvZmlsaW5nU3RhdGVbUFJJT1JJVFldID0gTm9Qcmlvcml0eTtcbiAgICBwcm9maWxpbmdTdGF0ZVtDVVJSRU5UX1RBU0tfSURdID0gMDtcbiAgICBwcm9maWxpbmdTdGF0ZVtRVUVVRV9TSVpFXS0tO1xuXG4gICAgaWYgKGV2ZW50TG9nICE9PSBudWxsKSB7XG4gICAgICBsb2dFdmVudChbVGFza0NvbXBsZXRlRXZlbnQsIG1zICogMTAwMCwgdGFzay5pZF0pO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gbWFya1Rhc2tDYW5jZWxlZCh0YXNrLCBtcykge1xuICBpZiAoZW5hYmxlUHJvZmlsaW5nKSB7XG4gICAgcHJvZmlsaW5nU3RhdGVbUVVFVUVfU0laRV0tLTtcblxuICAgIGlmIChldmVudExvZyAhPT0gbnVsbCkge1xuICAgICAgbG9nRXZlbnQoW1Rhc2tDYW5jZWxFdmVudCwgbXMgKiAxMDAwLCB0YXNrLmlkXSk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBtYXJrVGFza0Vycm9yZWQodGFzaywgbXMpIHtcbiAgaWYgKGVuYWJsZVByb2ZpbGluZykge1xuICAgIHByb2ZpbGluZ1N0YXRlW1BSSU9SSVRZXSA9IE5vUHJpb3JpdHk7XG4gICAgcHJvZmlsaW5nU3RhdGVbQ1VSUkVOVF9UQVNLX0lEXSA9IDA7XG4gICAgcHJvZmlsaW5nU3RhdGVbUVVFVUVfU0laRV0tLTtcblxuICAgIGlmIChldmVudExvZyAhPT0gbnVsbCkge1xuICAgICAgbG9nRXZlbnQoW1Rhc2tFcnJvckV2ZW50LCBtcyAqIDEwMDAsIHRhc2suaWRdKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIG1hcmtUYXNrUnVuKHRhc2ssIG1zKSB7XG4gIGlmIChlbmFibGVQcm9maWxpbmcpIHtcbiAgICBydW5JZENvdW50ZXIrKztcbiAgICBwcm9maWxpbmdTdGF0ZVtQUklPUklUWV0gPSB0YXNrLnByaW9yaXR5TGV2ZWw7XG4gICAgcHJvZmlsaW5nU3RhdGVbQ1VSUkVOVF9UQVNLX0lEXSA9IHRhc2suaWQ7XG4gICAgcHJvZmlsaW5nU3RhdGVbQ1VSUkVOVF9SVU5fSURdID0gcnVuSWRDb3VudGVyO1xuXG4gICAgaWYgKGV2ZW50TG9nICE9PSBudWxsKSB7XG4gICAgICBsb2dFdmVudChbVGFza1J1bkV2ZW50LCBtcyAqIDEwMDAsIHRhc2suaWQsIHJ1bklkQ291bnRlcl0pO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gbWFya1Rhc2tZaWVsZCh0YXNrLCBtcykge1xuICBpZiAoZW5hYmxlUHJvZmlsaW5nKSB7XG4gICAgcHJvZmlsaW5nU3RhdGVbUFJJT1JJVFldID0gTm9Qcmlvcml0eTtcbiAgICBwcm9maWxpbmdTdGF0ZVtDVVJSRU5UX1RBU0tfSURdID0gMDtcbiAgICBwcm9maWxpbmdTdGF0ZVtDVVJSRU5UX1JVTl9JRF0gPSAwO1xuXG4gICAgaWYgKGV2ZW50TG9nICE9PSBudWxsKSB7XG4gICAgICBsb2dFdmVudChbVGFza1lpZWxkRXZlbnQsIG1zICogMTAwMCwgdGFzay5pZCwgcnVuSWRDb3VudGVyXSk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBtYXJrU2NoZWR1bGVyU3VzcGVuZGVkKG1zKSB7XG4gIGlmIChlbmFibGVQcm9maWxpbmcpIHtcbiAgICBtYWluVGhyZWFkSWRDb3VudGVyKys7XG5cbiAgICBpZiAoZXZlbnRMb2cgIT09IG51bGwpIHtcbiAgICAgIGxvZ0V2ZW50KFtTY2hlZHVsZXJTdXNwZW5kRXZlbnQsIG1zICogMTAwMCwgbWFpblRocmVhZElkQ291bnRlcl0pO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gbWFya1NjaGVkdWxlclVuc3VzcGVuZGVkKG1zKSB7XG4gIGlmIChlbmFibGVQcm9maWxpbmcpIHtcbiAgICBpZiAoZXZlbnRMb2cgIT09IG51bGwpIHtcbiAgICAgIGxvZ0V2ZW50KFtTY2hlZHVsZXJSZXN1bWVFdmVudCwgbXMgKiAxMDAwLCBtYWluVGhyZWFkSWRDb3VudGVyXSk7XG4gICAgfVxuICB9XG59XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXZhciAqL1xuLy8gTWF0aC5wb3coMiwgMzApIC0gMVxuLy8gMGIxMTExMTExMTExMTExMTExMTExMTExMTExMTExMTFcblxudmFyIG1heFNpZ25lZDMxQml0SW50ID0gMTA3Mzc0MTgyMzsgLy8gVGltZXMgb3V0IGltbWVkaWF0ZWx5XG5cbnZhciBJTU1FRElBVEVfUFJJT1JJVFlfVElNRU9VVCA9IC0xOyAvLyBFdmVudHVhbGx5IHRpbWVzIG91dFxuXG52YXIgVVNFUl9CTE9DS0lOR19QUklPUklUWSA9IDI1MDtcbnZhciBOT1JNQUxfUFJJT1JJVFlfVElNRU9VVCA9IDUwMDA7XG52YXIgTE9XX1BSSU9SSVRZX1RJTUVPVVQgPSAxMDAwMDsgLy8gTmV2ZXIgdGltZXMgb3V0XG5cbnZhciBJRExFX1BSSU9SSVRZID0gbWF4U2lnbmVkMzFCaXRJbnQ7IC8vIFRhc2tzIGFyZSBzdG9yZWQgb24gYSBtaW4gaGVhcFxuXG52YXIgdGFza1F1ZXVlID0gW107XG52YXIgdGltZXJRdWV1ZSA9IFtdOyAvLyBJbmNyZW1lbnRpbmcgaWQgY291bnRlci4gVXNlZCB0byBtYWludGFpbiBpbnNlcnRpb24gb3JkZXIuXG5cbnZhciB0YXNrSWRDb3VudGVyID0gMTsgLy8gUGF1c2luZyB0aGUgc2NoZWR1bGVyIGlzIHVzZWZ1bCBmb3IgZGVidWdnaW5nLlxuXG52YXIgaXNTY2hlZHVsZXJQYXVzZWQgPSBmYWxzZTtcbnZhciBjdXJyZW50VGFzayA9IG51bGw7XG52YXIgY3VycmVudFByaW9yaXR5TGV2ZWwgPSBOb3JtYWxQcmlvcml0eTsgLy8gVGhpcyBpcyBzZXQgd2hpbGUgcGVyZm9ybWluZyB3b3JrLCB0byBwcmV2ZW50IHJlLWVudHJhbmN5LlxuXG52YXIgaXNQZXJmb3JtaW5nV29yayA9IGZhbHNlO1xudmFyIGlzSG9zdENhbGxiYWNrU2NoZWR1bGVkID0gZmFsc2U7XG52YXIgaXNIb3N0VGltZW91dFNjaGVkdWxlZCA9IGZhbHNlO1xuXG5mdW5jdGlvbiBhZHZhbmNlVGltZXJzKGN1cnJlbnRUaW1lKSB7XG4gIC8vIENoZWNrIGZvciB0YXNrcyB0aGF0IGFyZSBubyBsb25nZXIgZGVsYXllZCBhbmQgYWRkIHRoZW0gdG8gdGhlIHF1ZXVlLlxuICB2YXIgdGltZXIgPSBwZWVrKHRpbWVyUXVldWUpO1xuXG4gIHdoaWxlICh0aW1lciAhPT0gbnVsbCkge1xuICAgIGlmICh0aW1lci5jYWxsYmFjayA9PT0gbnVsbCkge1xuICAgICAgLy8gVGltZXIgd2FzIGNhbmNlbGxlZC5cbiAgICAgIHBvcCh0aW1lclF1ZXVlKTtcbiAgICB9IGVsc2UgaWYgKHRpbWVyLnN0YXJ0VGltZSA8PSBjdXJyZW50VGltZSkge1xuICAgICAgLy8gVGltZXIgZmlyZWQuIFRyYW5zZmVyIHRvIHRoZSB0YXNrIHF1ZXVlLlxuICAgICAgcG9wKHRpbWVyUXVldWUpO1xuICAgICAgdGltZXIuc29ydEluZGV4ID0gdGltZXIuZXhwaXJhdGlvblRpbWU7XG4gICAgICBwdXNoKHRhc2tRdWV1ZSwgdGltZXIpO1xuXG4gICAgICBpZiAoZW5hYmxlUHJvZmlsaW5nKSB7XG4gICAgICAgIG1hcmtUYXNrU3RhcnQodGltZXIsIGN1cnJlbnRUaW1lKTtcbiAgICAgICAgdGltZXIuaXNRdWV1ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZW1haW5pbmcgdGltZXJzIGFyZSBwZW5kaW5nLlxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRpbWVyID0gcGVlayh0aW1lclF1ZXVlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBoYW5kbGVUaW1lb3V0KGN1cnJlbnRUaW1lKSB7XG4gIGlzSG9zdFRpbWVvdXRTY2hlZHVsZWQgPSBmYWxzZTtcbiAgYWR2YW5jZVRpbWVycyhjdXJyZW50VGltZSk7XG5cbiAgaWYgKCFpc0hvc3RDYWxsYmFja1NjaGVkdWxlZCkge1xuICAgIGlmIChwZWVrKHRhc2tRdWV1ZSkgIT09IG51bGwpIHtcbiAgICAgIGlzSG9zdENhbGxiYWNrU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgIHJlcXVlc3RIb3N0Q2FsbGJhY2soZmx1c2hXb3JrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGZpcnN0VGltZXIgPSBwZWVrKHRpbWVyUXVldWUpO1xuXG4gICAgICBpZiAoZmlyc3RUaW1lciAhPT0gbnVsbCkge1xuICAgICAgICByZXF1ZXN0SG9zdFRpbWVvdXQoaGFuZGxlVGltZW91dCwgZmlyc3RUaW1lci5zdGFydFRpbWUgLSBjdXJyZW50VGltZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGZsdXNoV29yayhoYXNUaW1lUmVtYWluaW5nLCBpbml0aWFsVGltZSkge1xuICBpZiAoZW5hYmxlUHJvZmlsaW5nKSB7XG4gICAgbWFya1NjaGVkdWxlclVuc3VzcGVuZGVkKGluaXRpYWxUaW1lKTtcbiAgfSAvLyBXZSdsbCBuZWVkIGEgaG9zdCBjYWxsYmFjayB0aGUgbmV4dCB0aW1lIHdvcmsgaXMgc2NoZWR1bGVkLlxuXG5cbiAgaXNIb3N0Q2FsbGJhY2tTY2hlZHVsZWQgPSBmYWxzZTtcblxuICBpZiAoaXNIb3N0VGltZW91dFNjaGVkdWxlZCkge1xuICAgIC8vIFdlIHNjaGVkdWxlZCBhIHRpbWVvdXQgYnV0IGl0J3Mgbm8gbG9uZ2VyIG5lZWRlZC4gQ2FuY2VsIGl0LlxuICAgIGlzSG9zdFRpbWVvdXRTY2hlZHVsZWQgPSBmYWxzZTtcbiAgICBjYW5jZWxIb3N0VGltZW91dCgpO1xuICB9XG5cbiAgaXNQZXJmb3JtaW5nV29yayA9IHRydWU7XG4gIHZhciBwcmV2aW91c1ByaW9yaXR5TGV2ZWwgPSBjdXJyZW50UHJpb3JpdHlMZXZlbDtcblxuICB0cnkge1xuICAgIGlmIChlbmFibGVQcm9maWxpbmcpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB3b3JrTG9vcChoYXNUaW1lUmVtYWluaW5nLCBpbml0aWFsVGltZSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBpZiAoY3VycmVudFRhc2sgIT09IG51bGwpIHtcbiAgICAgICAgICB2YXIgY3VycmVudFRpbWUgPSBleHBvcnRzLnVuc3RhYmxlX25vdygpO1xuICAgICAgICAgIG1hcmtUYXNrRXJyb3JlZChjdXJyZW50VGFzaywgY3VycmVudFRpbWUpO1xuICAgICAgICAgIGN1cnJlbnRUYXNrLmlzUXVldWVkID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTm8gY2F0Y2ggaW4gcHJvZCBjb2RlcGF0aC5cbiAgICAgIHJldHVybiB3b3JrTG9vcChoYXNUaW1lUmVtYWluaW5nLCBpbml0aWFsVGltZSk7XG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIGN1cnJlbnRUYXNrID0gbnVsbDtcbiAgICBjdXJyZW50UHJpb3JpdHlMZXZlbCA9IHByZXZpb3VzUHJpb3JpdHlMZXZlbDtcbiAgICBpc1BlcmZvcm1pbmdXb3JrID0gZmFsc2U7XG5cbiAgICBpZiAoZW5hYmxlUHJvZmlsaW5nKSB7XG4gICAgICB2YXIgX2N1cnJlbnRUaW1lID0gZXhwb3J0cy51bnN0YWJsZV9ub3coKTtcblxuICAgICAgbWFya1NjaGVkdWxlclN1c3BlbmRlZChfY3VycmVudFRpbWUpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB3b3JrTG9vcChoYXNUaW1lUmVtYWluaW5nLCBpbml0aWFsVGltZSkge1xuICB2YXIgY3VycmVudFRpbWUgPSBpbml0aWFsVGltZTtcbiAgYWR2YW5jZVRpbWVycyhjdXJyZW50VGltZSk7XG4gIGN1cnJlbnRUYXNrID0gcGVlayh0YXNrUXVldWUpO1xuXG4gIHdoaWxlIChjdXJyZW50VGFzayAhPT0gbnVsbCAmJiAhKGVuYWJsZVNjaGVkdWxlckRlYnVnZ2luZyAmJiBpc1NjaGVkdWxlclBhdXNlZCkpIHtcbiAgICBpZiAoY3VycmVudFRhc2suZXhwaXJhdGlvblRpbWUgPiBjdXJyZW50VGltZSAmJiAoIWhhc1RpbWVSZW1haW5pbmcgfHwgc2hvdWxkWWllbGRUb0hvc3QoKSkpIHtcbiAgICAgIC8vIFRoaXMgY3VycmVudFRhc2sgaGFzbid0IGV4cGlyZWQsIGFuZCB3ZSd2ZSByZWFjaGVkIHRoZSBkZWFkbGluZS5cbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHZhciBjYWxsYmFjayA9IGN1cnJlbnRUYXNrLmNhbGxiYWNrO1xuXG4gICAgaWYgKGNhbGxiYWNrICE9PSBudWxsKSB7XG4gICAgICBjdXJyZW50VGFzay5jYWxsYmFjayA9IG51bGw7XG4gICAgICBjdXJyZW50UHJpb3JpdHlMZXZlbCA9IGN1cnJlbnRUYXNrLnByaW9yaXR5TGV2ZWw7XG4gICAgICB2YXIgZGlkVXNlckNhbGxiYWNrVGltZW91dCA9IGN1cnJlbnRUYXNrLmV4cGlyYXRpb25UaW1lIDw9IGN1cnJlbnRUaW1lO1xuICAgICAgbWFya1Rhc2tSdW4oY3VycmVudFRhc2ssIGN1cnJlbnRUaW1lKTtcbiAgICAgIHZhciBjb250aW51YXRpb25DYWxsYmFjayA9IGNhbGxiYWNrKGRpZFVzZXJDYWxsYmFja1RpbWVvdXQpO1xuICAgICAgY3VycmVudFRpbWUgPSBleHBvcnRzLnVuc3RhYmxlX25vdygpO1xuXG4gICAgICBpZiAodHlwZW9mIGNvbnRpbnVhdGlvbkNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGN1cnJlbnRUYXNrLmNhbGxiYWNrID0gY29udGludWF0aW9uQ2FsbGJhY2s7XG4gICAgICAgIG1hcmtUYXNrWWllbGQoY3VycmVudFRhc2ssIGN1cnJlbnRUaW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChlbmFibGVQcm9maWxpbmcpIHtcbiAgICAgICAgICBtYXJrVGFza0NvbXBsZXRlZChjdXJyZW50VGFzaywgY3VycmVudFRpbWUpO1xuICAgICAgICAgIGN1cnJlbnRUYXNrLmlzUXVldWVkID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY3VycmVudFRhc2sgPT09IHBlZWsodGFza1F1ZXVlKSkge1xuICAgICAgICAgIHBvcCh0YXNrUXVldWUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGFkdmFuY2VUaW1lcnMoY3VycmVudFRpbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwb3AodGFza1F1ZXVlKTtcbiAgICB9XG5cbiAgICBjdXJyZW50VGFzayA9IHBlZWsodGFza1F1ZXVlKTtcbiAgfSAvLyBSZXR1cm4gd2hldGhlciB0aGVyZSdzIGFkZGl0aW9uYWwgd29ya1xuXG5cbiAgaWYgKGN1cnJlbnRUYXNrICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGZpcnN0VGltZXIgPSBwZWVrKHRpbWVyUXVldWUpO1xuXG4gICAgaWYgKGZpcnN0VGltZXIgIT09IG51bGwpIHtcbiAgICAgIHJlcXVlc3RIb3N0VGltZW91dChoYW5kbGVUaW1lb3V0LCBmaXJzdFRpbWVyLnN0YXJ0VGltZSAtIGN1cnJlbnRUaW1lKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gdW5zdGFibGVfcnVuV2l0aFByaW9yaXR5KHByaW9yaXR5TGV2ZWwsIGV2ZW50SGFuZGxlcikge1xuICBzd2l0Y2ggKHByaW9yaXR5TGV2ZWwpIHtcbiAgICBjYXNlIEltbWVkaWF0ZVByaW9yaXR5OlxuICAgIGNhc2UgVXNlckJsb2NraW5nUHJpb3JpdHk6XG4gICAgY2FzZSBOb3JtYWxQcmlvcml0eTpcbiAgICBjYXNlIExvd1ByaW9yaXR5OlxuICAgIGNhc2UgSWRsZVByaW9yaXR5OlxuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcHJpb3JpdHlMZXZlbCA9IE5vcm1hbFByaW9yaXR5O1xuICB9XG5cbiAgdmFyIHByZXZpb3VzUHJpb3JpdHlMZXZlbCA9IGN1cnJlbnRQcmlvcml0eUxldmVsO1xuICBjdXJyZW50UHJpb3JpdHlMZXZlbCA9IHByaW9yaXR5TGV2ZWw7XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gZXZlbnRIYW5kbGVyKCk7XG4gIH0gZmluYWxseSB7XG4gICAgY3VycmVudFByaW9yaXR5TGV2ZWwgPSBwcmV2aW91c1ByaW9yaXR5TGV2ZWw7XG4gIH1cbn1cblxuZnVuY3Rpb24gdW5zdGFibGVfbmV4dChldmVudEhhbmRsZXIpIHtcbiAgdmFyIHByaW9yaXR5TGV2ZWw7XG5cbiAgc3dpdGNoIChjdXJyZW50UHJpb3JpdHlMZXZlbCkge1xuICAgIGNhc2UgSW1tZWRpYXRlUHJpb3JpdHk6XG4gICAgY2FzZSBVc2VyQmxvY2tpbmdQcmlvcml0eTpcbiAgICBjYXNlIE5vcm1hbFByaW9yaXR5OlxuICAgICAgLy8gU2hpZnQgZG93biB0byBub3JtYWwgcHJpb3JpdHlcbiAgICAgIHByaW9yaXR5TGV2ZWwgPSBOb3JtYWxQcmlvcml0eTtcbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIC8vIEFueXRoaW5nIGxvd2VyIHRoYW4gbm9ybWFsIHByaW9yaXR5IHNob3VsZCByZW1haW4gYXQgdGhlIGN1cnJlbnQgbGV2ZWwuXG4gICAgICBwcmlvcml0eUxldmVsID0gY3VycmVudFByaW9yaXR5TGV2ZWw7XG4gICAgICBicmVhaztcbiAgfVxuXG4gIHZhciBwcmV2aW91c1ByaW9yaXR5TGV2ZWwgPSBjdXJyZW50UHJpb3JpdHlMZXZlbDtcbiAgY3VycmVudFByaW9yaXR5TGV2ZWwgPSBwcmlvcml0eUxldmVsO1xuXG4gIHRyeSB7XG4gICAgcmV0dXJuIGV2ZW50SGFuZGxlcigpO1xuICB9IGZpbmFsbHkge1xuICAgIGN1cnJlbnRQcmlvcml0eUxldmVsID0gcHJldmlvdXNQcmlvcml0eUxldmVsO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVuc3RhYmxlX3dyYXBDYWxsYmFjayhjYWxsYmFjaykge1xuICB2YXIgcGFyZW50UHJpb3JpdHlMZXZlbCA9IGN1cnJlbnRQcmlvcml0eUxldmVsO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIC8vIFRoaXMgaXMgYSBmb3JrIG9mIHJ1bldpdGhQcmlvcml0eSwgaW5saW5lZCBmb3IgcGVyZm9ybWFuY2UuXG4gICAgdmFyIHByZXZpb3VzUHJpb3JpdHlMZXZlbCA9IGN1cnJlbnRQcmlvcml0eUxldmVsO1xuICAgIGN1cnJlbnRQcmlvcml0eUxldmVsID0gcGFyZW50UHJpb3JpdHlMZXZlbDtcblxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgY3VycmVudFByaW9yaXR5TGV2ZWwgPSBwcmV2aW91c1ByaW9yaXR5TGV2ZWw7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiB0aW1lb3V0Rm9yUHJpb3JpdHlMZXZlbChwcmlvcml0eUxldmVsKSB7XG4gIHN3aXRjaCAocHJpb3JpdHlMZXZlbCkge1xuICAgIGNhc2UgSW1tZWRpYXRlUHJpb3JpdHk6XG4gICAgICByZXR1cm4gSU1NRURJQVRFX1BSSU9SSVRZX1RJTUVPVVQ7XG5cbiAgICBjYXNlIFVzZXJCbG9ja2luZ1ByaW9yaXR5OlxuICAgICAgcmV0dXJuIFVTRVJfQkxPQ0tJTkdfUFJJT1JJVFk7XG5cbiAgICBjYXNlIElkbGVQcmlvcml0eTpcbiAgICAgIHJldHVybiBJRExFX1BSSU9SSVRZO1xuXG4gICAgY2FzZSBMb3dQcmlvcml0eTpcbiAgICAgIHJldHVybiBMT1dfUFJJT1JJVFlfVElNRU9VVDtcblxuICAgIGNhc2UgTm9ybWFsUHJpb3JpdHk6XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBOT1JNQUxfUFJJT1JJVFlfVElNRU9VVDtcbiAgfVxufVxuXG5mdW5jdGlvbiB1bnN0YWJsZV9zY2hlZHVsZUNhbGxiYWNrKHByaW9yaXR5TGV2ZWwsIGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gIHZhciBjdXJyZW50VGltZSA9IGV4cG9ydHMudW5zdGFibGVfbm93KCk7XG4gIHZhciBzdGFydFRpbWU7XG4gIHZhciB0aW1lb3V0O1xuXG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ29iamVjdCcgJiYgb3B0aW9ucyAhPT0gbnVsbCkge1xuICAgIHZhciBkZWxheSA9IG9wdGlvbnMuZGVsYXk7XG5cbiAgICBpZiAodHlwZW9mIGRlbGF5ID09PSAnbnVtYmVyJyAmJiBkZWxheSA+IDApIHtcbiAgICAgIHN0YXJ0VGltZSA9IGN1cnJlbnRUaW1lICsgZGVsYXk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXJ0VGltZSA9IGN1cnJlbnRUaW1lO1xuICAgIH1cblxuICAgIHRpbWVvdXQgPSB0eXBlb2Ygb3B0aW9ucy50aW1lb3V0ID09PSAnbnVtYmVyJyA/IG9wdGlvbnMudGltZW91dCA6IHRpbWVvdXRGb3JQcmlvcml0eUxldmVsKHByaW9yaXR5TGV2ZWwpO1xuICB9IGVsc2Uge1xuICAgIHRpbWVvdXQgPSB0aW1lb3V0Rm9yUHJpb3JpdHlMZXZlbChwcmlvcml0eUxldmVsKTtcbiAgICBzdGFydFRpbWUgPSBjdXJyZW50VGltZTtcbiAgfVxuXG4gIHZhciBleHBpcmF0aW9uVGltZSA9IHN0YXJ0VGltZSArIHRpbWVvdXQ7XG4gIHZhciBuZXdUYXNrID0ge1xuICAgIGlkOiB0YXNrSWRDb3VudGVyKyssXG4gICAgY2FsbGJhY2s6IGNhbGxiYWNrLFxuICAgIHByaW9yaXR5TGV2ZWw6IHByaW9yaXR5TGV2ZWwsXG4gICAgc3RhcnRUaW1lOiBzdGFydFRpbWUsXG4gICAgZXhwaXJhdGlvblRpbWU6IGV4cGlyYXRpb25UaW1lLFxuICAgIHNvcnRJbmRleDogLTFcbiAgfTtcblxuICBpZiAoZW5hYmxlUHJvZmlsaW5nKSB7XG4gICAgbmV3VGFzay5pc1F1ZXVlZCA9IGZhbHNlO1xuICB9XG5cbiAgaWYgKHN0YXJ0VGltZSA+IGN1cnJlbnRUaW1lKSB7XG4gICAgLy8gVGhpcyBpcyBhIGRlbGF5ZWQgdGFzay5cbiAgICBuZXdUYXNrLnNvcnRJbmRleCA9IHN0YXJ0VGltZTtcbiAgICBwdXNoKHRpbWVyUXVldWUsIG5ld1Rhc2spO1xuXG4gICAgaWYgKHBlZWsodGFza1F1ZXVlKSA9PT0gbnVsbCAmJiBuZXdUYXNrID09PSBwZWVrKHRpbWVyUXVldWUpKSB7XG4gICAgICAvLyBBbGwgdGFza3MgYXJlIGRlbGF5ZWQsIGFuZCB0aGlzIGlzIHRoZSB0YXNrIHdpdGggdGhlIGVhcmxpZXN0IGRlbGF5LlxuICAgICAgaWYgKGlzSG9zdFRpbWVvdXRTY2hlZHVsZWQpIHtcbiAgICAgICAgLy8gQ2FuY2VsIGFuIGV4aXN0aW5nIHRpbWVvdXQuXG4gICAgICAgIGNhbmNlbEhvc3RUaW1lb3V0KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpc0hvc3RUaW1lb3V0U2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgIH0gLy8gU2NoZWR1bGUgYSB0aW1lb3V0LlxuXG5cbiAgICAgIHJlcXVlc3RIb3N0VGltZW91dChoYW5kbGVUaW1lb3V0LCBzdGFydFRpbWUgLSBjdXJyZW50VGltZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG5ld1Rhc2suc29ydEluZGV4ID0gZXhwaXJhdGlvblRpbWU7XG4gICAgcHVzaCh0YXNrUXVldWUsIG5ld1Rhc2spO1xuXG4gICAgaWYgKGVuYWJsZVByb2ZpbGluZykge1xuICAgICAgbWFya1Rhc2tTdGFydChuZXdUYXNrLCBjdXJyZW50VGltZSk7XG4gICAgICBuZXdUYXNrLmlzUXVldWVkID0gdHJ1ZTtcbiAgICB9IC8vIFNjaGVkdWxlIGEgaG9zdCBjYWxsYmFjaywgaWYgbmVlZGVkLiBJZiB3ZSdyZSBhbHJlYWR5IHBlcmZvcm1pbmcgd29yayxcbiAgICAvLyB3YWl0IHVudGlsIHRoZSBuZXh0IHRpbWUgd2UgeWllbGQuXG5cblxuICAgIGlmICghaXNIb3N0Q2FsbGJhY2tTY2hlZHVsZWQgJiYgIWlzUGVyZm9ybWluZ1dvcmspIHtcbiAgICAgIGlzSG9zdENhbGxiYWNrU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgIHJlcXVlc3RIb3N0Q2FsbGJhY2soZmx1c2hXb3JrKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3VGFzaztcbn1cblxuZnVuY3Rpb24gdW5zdGFibGVfcGF1c2VFeGVjdXRpb24oKSB7XG4gIGlzU2NoZWR1bGVyUGF1c2VkID0gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gdW5zdGFibGVfY29udGludWVFeGVjdXRpb24oKSB7XG4gIGlzU2NoZWR1bGVyUGF1c2VkID0gZmFsc2U7XG5cbiAgaWYgKCFpc0hvc3RDYWxsYmFja1NjaGVkdWxlZCAmJiAhaXNQZXJmb3JtaW5nV29yaykge1xuICAgIGlzSG9zdENhbGxiYWNrU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICByZXF1ZXN0SG9zdENhbGxiYWNrKGZsdXNoV29yayk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdW5zdGFibGVfZ2V0Rmlyc3RDYWxsYmFja05vZGUoKSB7XG4gIHJldHVybiBwZWVrKHRhc2tRdWV1ZSk7XG59XG5cbmZ1bmN0aW9uIHVuc3RhYmxlX2NhbmNlbENhbGxiYWNrKHRhc2spIHtcbiAgaWYgKGVuYWJsZVByb2ZpbGluZykge1xuICAgIGlmICh0YXNrLmlzUXVldWVkKSB7XG4gICAgICB2YXIgY3VycmVudFRpbWUgPSBleHBvcnRzLnVuc3RhYmxlX25vdygpO1xuICAgICAgbWFya1Rhc2tDYW5jZWxlZCh0YXNrLCBjdXJyZW50VGltZSk7XG4gICAgICB0YXNrLmlzUXVldWVkID0gZmFsc2U7XG4gICAgfVxuICB9IC8vIE51bGwgb3V0IHRoZSBjYWxsYmFjayB0byBpbmRpY2F0ZSB0aGUgdGFzayBoYXMgYmVlbiBjYW5jZWxlZC4gKENhbid0XG4gIC8vIHJlbW92ZSBmcm9tIHRoZSBxdWV1ZSBiZWNhdXNlIHlvdSBjYW4ndCByZW1vdmUgYXJiaXRyYXJ5IG5vZGVzIGZyb20gYW5cbiAgLy8gYXJyYXkgYmFzZWQgaGVhcCwgb25seSB0aGUgZmlyc3Qgb25lLilcblxuXG4gIHRhc2suY2FsbGJhY2sgPSBudWxsO1xufVxuXG5mdW5jdGlvbiB1bnN0YWJsZV9nZXRDdXJyZW50UHJpb3JpdHlMZXZlbCgpIHtcbiAgcmV0dXJuIGN1cnJlbnRQcmlvcml0eUxldmVsO1xufVxuXG5mdW5jdGlvbiB1bnN0YWJsZV9zaG91bGRZaWVsZCgpIHtcbiAgdmFyIGN1cnJlbnRUaW1lID0gZXhwb3J0cy51bnN0YWJsZV9ub3coKTtcbiAgYWR2YW5jZVRpbWVycyhjdXJyZW50VGltZSk7XG4gIHZhciBmaXJzdFRhc2sgPSBwZWVrKHRhc2tRdWV1ZSk7XG4gIHJldHVybiBmaXJzdFRhc2sgIT09IGN1cnJlbnRUYXNrICYmIGN1cnJlbnRUYXNrICE9PSBudWxsICYmIGZpcnN0VGFzayAhPT0gbnVsbCAmJiBmaXJzdFRhc2suY2FsbGJhY2sgIT09IG51bGwgJiYgZmlyc3RUYXNrLnN0YXJ0VGltZSA8PSBjdXJyZW50VGltZSAmJiBmaXJzdFRhc2suZXhwaXJhdGlvblRpbWUgPCBjdXJyZW50VGFzay5leHBpcmF0aW9uVGltZSB8fCBzaG91bGRZaWVsZFRvSG9zdCgpO1xufVxuXG52YXIgdW5zdGFibGVfcmVxdWVzdFBhaW50ID0gcmVxdWVzdFBhaW50O1xudmFyIHVuc3RhYmxlX1Byb2ZpbGluZyA9IGVuYWJsZVByb2ZpbGluZyA/IHtcbiAgc3RhcnRMb2dnaW5nUHJvZmlsaW5nRXZlbnRzOiBzdGFydExvZ2dpbmdQcm9maWxpbmdFdmVudHMsXG4gIHN0b3BMb2dnaW5nUHJvZmlsaW5nRXZlbnRzOiBzdG9wTG9nZ2luZ1Byb2ZpbGluZ0V2ZW50cyxcbiAgc2hhcmVkUHJvZmlsaW5nQnVmZmVyOiBzaGFyZWRQcm9maWxpbmdCdWZmZXJcbn0gOiBudWxsO1xuXG5leHBvcnRzLnVuc3RhYmxlX0ltbWVkaWF0ZVByaW9yaXR5ID0gSW1tZWRpYXRlUHJpb3JpdHk7XG5leHBvcnRzLnVuc3RhYmxlX1VzZXJCbG9ja2luZ1ByaW9yaXR5ID0gVXNlckJsb2NraW5nUHJpb3JpdHk7XG5leHBvcnRzLnVuc3RhYmxlX05vcm1hbFByaW9yaXR5ID0gTm9ybWFsUHJpb3JpdHk7XG5leHBvcnRzLnVuc3RhYmxlX0lkbGVQcmlvcml0eSA9IElkbGVQcmlvcml0eTtcbmV4cG9ydHMudW5zdGFibGVfTG93UHJpb3JpdHkgPSBMb3dQcmlvcml0eTtcbmV4cG9ydHMudW5zdGFibGVfcnVuV2l0aFByaW9yaXR5ID0gdW5zdGFibGVfcnVuV2l0aFByaW9yaXR5O1xuZXhwb3J0cy51bnN0YWJsZV9uZXh0ID0gdW5zdGFibGVfbmV4dDtcbmV4cG9ydHMudW5zdGFibGVfc2NoZWR1bGVDYWxsYmFjayA9IHVuc3RhYmxlX3NjaGVkdWxlQ2FsbGJhY2s7XG5leHBvcnRzLnVuc3RhYmxlX2NhbmNlbENhbGxiYWNrID0gdW5zdGFibGVfY2FuY2VsQ2FsbGJhY2s7XG5leHBvcnRzLnVuc3RhYmxlX3dyYXBDYWxsYmFjayA9IHVuc3RhYmxlX3dyYXBDYWxsYmFjaztcbmV4cG9ydHMudW5zdGFibGVfZ2V0Q3VycmVudFByaW9yaXR5TGV2ZWwgPSB1bnN0YWJsZV9nZXRDdXJyZW50UHJpb3JpdHlMZXZlbDtcbmV4cG9ydHMudW5zdGFibGVfc2hvdWxkWWllbGQgPSB1bnN0YWJsZV9zaG91bGRZaWVsZDtcbmV4cG9ydHMudW5zdGFibGVfcmVxdWVzdFBhaW50ID0gdW5zdGFibGVfcmVxdWVzdFBhaW50O1xuZXhwb3J0cy51bnN0YWJsZV9jb250aW51ZUV4ZWN1dGlvbiA9IHVuc3RhYmxlX2NvbnRpbnVlRXhlY3V0aW9uO1xuZXhwb3J0cy51bnN0YWJsZV9wYXVzZUV4ZWN1dGlvbiA9IHVuc3RhYmxlX3BhdXNlRXhlY3V0aW9uO1xuZXhwb3J0cy51bnN0YWJsZV9nZXRGaXJzdENhbGxiYWNrTm9kZSA9IHVuc3RhYmxlX2dldEZpcnN0Q2FsbGJhY2tOb2RlO1xuZXhwb3J0cy51bnN0YWJsZV9Qcm9maWxpbmcgPSB1bnN0YWJsZV9Qcm9maWxpbmc7XG4gIH0pKCk7XG59XG4iXSwibmFtZXMiOlsicHJvY2VzcyIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZW5hYmxlU2NoZWR1bGVyRGVidWdnaW5nIiwiZW5hYmxlSXNJbnB1dFBlbmRpbmciLCJlbmFibGVNZXNzYWdlTG9vcEltcGxlbWVudGF0aW9uIiwiZW5hYmxlUHJvZmlsaW5nIiwicmVxdWVzdEhvc3RDYWxsYmFjayIsInJlcXVlc3RIb3N0VGltZW91dCIsImNhbmNlbEhvc3RUaW1lb3V0Iiwic2hvdWxkWWllbGRUb0hvc3QiLCJyZXF1ZXN0UGFpbnQiLCJNZXNzYWdlQ2hhbm5lbCIsIl9jYWxsYmFjayIsIl90aW1lb3V0SUQiLCJfZmx1c2hDYWxsYmFjayIsImN1cnJlbnRUaW1lIiwidW5zdGFibGVfbm93IiwiaGFzUmVtYWluaW5nVGltZSIsImUiLCJzZXRUaW1lb3V0IiwiaW5pdGlhbFRpbWUiLCJEYXRlIiwibm93IiwiY2IiLCJtcyIsImNsZWFyVGltZW91dCIsInVuc3RhYmxlX2ZvcmNlRnJhbWVSYXRlIiwicGVyZm9ybWFuY2UiLCJ3aW5kb3ciLCJfRGF0ZSIsIl9zZXRUaW1lb3V0IiwiX2NsZWFyVGltZW91dCIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwiY29uc29sZSIsImVycm9yIiwiX2luaXRpYWxUaW1lIiwiaXNSQUZMb29wUnVubmluZyIsImlzTWVzc2FnZUxvb3BSdW5uaW5nIiwic2NoZWR1bGVkSG9zdENhbGxiYWNrIiwickFGVGltZW91dElEIiwidGFza1RpbWVvdXRJRCIsImZyYW1lTGVuZ3RoIiwicHJldlJBRlRpbWUiLCJwcmV2UkFGSW50ZXJ2YWwiLCJmcmFtZURlYWRsaW5lIiwiZnBzTG9ja2VkIiwibWF4RnJhbWVMZW5ndGgiLCJuZWVkc1BhaW50IiwibmF2aWdhdG9yIiwidW5kZWZpbmVkIiwic2NoZWR1bGluZyIsImlzSW5wdXRQZW5kaW5nIiwiZnBzIiwiTWF0aCIsImZsb29yIiwicGVyZm9ybVdvcmtVbnRpbERlYWRsaW5lIiwiaGFzVGltZVJlbWFpbmluZyIsImhhc01vcmVXb3JrIiwicG9ydCIsInBvc3RNZXNzYWdlIiwiX2N1cnJlbnRUaW1lIiwiX2hhc1RpbWVSZW1haW5pbmciLCJfaGFzTW9yZVdvcmsiLCJjaGFubmVsIiwicG9ydDIiLCJwb3J0MSIsIm9ubWVzc2FnZSIsIm9uQW5pbWF0aW9uRnJhbWUiLCJyQUZUaW1lIiwibmV4dFJBRlRpbWUiLCJvblRpbWVvdXQiLCJyQUZJbnRlcnZhbCIsImNhbGxiYWNrIiwicHVzaCIsImhlYXAiLCJub2RlIiwiaW5kZXgiLCJsZW5ndGgiLCJzaWZ0VXAiLCJwZWVrIiwiZmlyc3QiLCJwb3AiLCJsYXN0Iiwic2lmdERvd24iLCJpIiwicGFyZW50SW5kZXgiLCJwYXJlbnQiLCJjb21wYXJlIiwibGVmdEluZGV4IiwibGVmdCIsInJpZ2h0SW5kZXgiLCJyaWdodCIsImEiLCJiIiwiZGlmZiIsInNvcnRJbmRleCIsImlkIiwiTm9Qcmlvcml0eSIsIkltbWVkaWF0ZVByaW9yaXR5IiwiVXNlckJsb2NraW5nUHJpb3JpdHkiLCJOb3JtYWxQcmlvcml0eSIsIkxvd1ByaW9yaXR5IiwiSWRsZVByaW9yaXR5IiwicnVuSWRDb3VudGVyIiwibWFpblRocmVhZElkQ291bnRlciIsInByb2ZpbGluZ1N0YXRlU2l6ZSIsInNoYXJlZFByb2ZpbGluZ0J1ZmZlciIsIlNoYXJlZEFycmF5QnVmZmVyIiwiSW50MzJBcnJheSIsIkJZVEVTX1BFUl9FTEVNRU5UIiwiQXJyYXlCdWZmZXIiLCJwcm9maWxpbmdTdGF0ZSIsIlBSSU9SSVRZIiwiQ1VSUkVOVF9UQVNLX0lEIiwiQ1VSUkVOVF9SVU5fSUQiLCJRVUVVRV9TSVpFIiwiSU5JVElBTF9FVkVOVF9MT0dfU0laRSIsIk1BWF9FVkVOVF9MT0dfU0laRSIsImV2ZW50TG9nU2l6ZSIsImV2ZW50TG9nQnVmZmVyIiwiZXZlbnRMb2ciLCJldmVudExvZ0luZGV4IiwiVGFza1N0YXJ0RXZlbnQiLCJUYXNrQ29tcGxldGVFdmVudCIsIlRhc2tFcnJvckV2ZW50IiwiVGFza0NhbmNlbEV2ZW50IiwiVGFza1J1bkV2ZW50IiwiVGFza1lpZWxkRXZlbnQiLCJTY2hlZHVsZXJTdXNwZW5kRXZlbnQiLCJTY2hlZHVsZXJSZXN1bWVFdmVudCIsImxvZ0V2ZW50IiwiZW50cmllcyIsIm9mZnNldCIsInN0b3BMb2dnaW5nUHJvZmlsaW5nRXZlbnRzIiwibmV3RXZlbnRMb2ciLCJzZXQiLCJidWZmZXIiLCJzdGFydExvZ2dpbmdQcm9maWxpbmdFdmVudHMiLCJtYXJrVGFza1N0YXJ0IiwidGFzayIsInByaW9yaXR5TGV2ZWwiLCJtYXJrVGFza0NvbXBsZXRlZCIsIm1hcmtUYXNrQ2FuY2VsZWQiLCJtYXJrVGFza0Vycm9yZWQiLCJtYXJrVGFza1J1biIsIm1hcmtUYXNrWWllbGQiLCJtYXJrU2NoZWR1bGVyU3VzcGVuZGVkIiwibWFya1NjaGVkdWxlclVuc3VzcGVuZGVkIiwibWF4U2lnbmVkMzFCaXRJbnQiLCJJTU1FRElBVEVfUFJJT1JJVFlfVElNRU9VVCIsIlVTRVJfQkxPQ0tJTkdfUFJJT1JJVFkiLCJOT1JNQUxfUFJJT1JJVFlfVElNRU9VVCIsIkxPV19QUklPUklUWV9USU1FT1VUIiwiSURMRV9QUklPUklUWSIsInRhc2tRdWV1ZSIsInRpbWVyUXVldWUiLCJ0YXNrSWRDb3VudGVyIiwiaXNTY2hlZHVsZXJQYXVzZWQiLCJjdXJyZW50VGFzayIsImN1cnJlbnRQcmlvcml0eUxldmVsIiwiaXNQZXJmb3JtaW5nV29yayIsImlzSG9zdENhbGxiYWNrU2NoZWR1bGVkIiwiaXNIb3N0VGltZW91dFNjaGVkdWxlZCIsImFkdmFuY2VUaW1lcnMiLCJ0aW1lciIsInN0YXJ0VGltZSIsImV4cGlyYXRpb25UaW1lIiwiaXNRdWV1ZWQiLCJoYW5kbGVUaW1lb3V0IiwiZmx1c2hXb3JrIiwiZmlyc3RUaW1lciIsInByZXZpb3VzUHJpb3JpdHlMZXZlbCIsIndvcmtMb29wIiwiZGlkVXNlckNhbGxiYWNrVGltZW91dCIsImNvbnRpbnVhdGlvbkNhbGxiYWNrIiwidW5zdGFibGVfcnVuV2l0aFByaW9yaXR5IiwiZXZlbnRIYW5kbGVyIiwidW5zdGFibGVfbmV4dCIsInVuc3RhYmxlX3dyYXBDYWxsYmFjayIsInBhcmVudFByaW9yaXR5TGV2ZWwiLCJhcHBseSIsImFyZ3VtZW50cyIsInRpbWVvdXRGb3JQcmlvcml0eUxldmVsIiwidW5zdGFibGVfc2NoZWR1bGVDYWxsYmFjayIsIm9wdGlvbnMiLCJ0aW1lb3V0IiwiZGVsYXkiLCJuZXdUYXNrIiwidW5zdGFibGVfcGF1c2VFeGVjdXRpb24iLCJ1bnN0YWJsZV9jb250aW51ZUV4ZWN1dGlvbiIsInVuc3RhYmxlX2dldEZpcnN0Q2FsbGJhY2tOb2RlIiwidW5zdGFibGVfY2FuY2VsQ2FsbGJhY2siLCJ1bnN0YWJsZV9nZXRDdXJyZW50UHJpb3JpdHlMZXZlbCIsInVuc3RhYmxlX3Nob3VsZFlpZWxkIiwiZmlyc3RUYXNrIiwidW5zdGFibGVfcmVxdWVzdFBhaW50IiwidW5zdGFibGVfUHJvZmlsaW5nIiwidW5zdGFibGVfSW1tZWRpYXRlUHJpb3JpdHkiLCJ1bnN0YWJsZV9Vc2VyQmxvY2tpbmdQcmlvcml0eSIsInVuc3RhYmxlX05vcm1hbFByaW9yaXR5IiwidW5zdGFibGVfSWRsZVByaW9yaXR5IiwidW5zdGFibGVfTG93UHJpb3JpdHkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/scheduler/cjs/scheduler.development.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/scheduler/index.js":
/*!*****************************************!*\
  !*** ./node_modules/scheduler/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nif (false) {} else {\n    module.exports = __webpack_require__(/*! ./cjs/scheduler.development.js */ \"(ssr)/./node_modules/scheduler/cjs/scheduler.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc2NoZWR1bGVyL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsSUFBSUEsS0FBeUIsRUFBYyxFQUUxQyxNQUFNO0lBQ0xDLHlJQUF5QjtBQUMzQiIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy1lY29tbWVyY2UtdWl0Ly4vbm9kZV9tb2R1bGVzL3NjaGVkdWxlci9pbmRleC5qcz9jN2NjIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9zY2hlZHVsZXIucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvc2NoZWR1bGVyLmRldmVsb3BtZW50LmpzJyk7XG59XG4iXSwibmFtZXMiOlsicHJvY2VzcyIsIm1vZHVsZSIsImV4cG9ydHMiLCJyZXF1aXJlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/scheduler/index.js\n");

/***/ })

};
;