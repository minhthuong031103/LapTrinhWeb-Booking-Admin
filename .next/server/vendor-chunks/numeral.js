"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/numeral";
exports.ids = ["vendor-chunks/numeral"];
exports.modules = {

/***/ "(ssr)/./node_modules/numeral/numeral.js":
/*!*****************************************!*\
  !*** ./node_modules/numeral/numeral.js ***!
  \*****************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;\n/*! @preserve\n * numeral.js\n * version : 2.0.6\n * author : Adam Draper\n * license : MIT\n * http://adamwdraper.github.com/Numeral-js/\n */ (function(global, factory) {\n    if (true) {\n        !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else {}\n})(void 0, function() {\n    /************************************\n        Variables\n    ************************************/ var numeral, _, VERSION = \"2.0.6\", formats = {}, locales = {}, defaults = {\n        currentLocale: \"en\",\n        zeroFormat: null,\n        nullFormat: null,\n        defaultFormat: \"0,0\",\n        scalePercentBy100: true\n    }, options = {\n        currentLocale: defaults.currentLocale,\n        zeroFormat: defaults.zeroFormat,\n        nullFormat: defaults.nullFormat,\n        defaultFormat: defaults.defaultFormat,\n        scalePercentBy100: defaults.scalePercentBy100\n    };\n    /************************************\n        Constructors\n    ************************************/ // Numeral prototype object\n    function Numeral(input, number) {\n        this._input = input;\n        this._value = number;\n    }\n    numeral = function(input) {\n        var value, kind, unformatFunction, regexp;\n        if (numeral.isNumeral(input)) {\n            value = input.value();\n        } else if (input === 0 || typeof input === \"undefined\") {\n            value = 0;\n        } else if (input === null || _.isNaN(input)) {\n            value = null;\n        } else if (typeof input === \"string\") {\n            if (options.zeroFormat && input === options.zeroFormat) {\n                value = 0;\n            } else if (options.nullFormat && input === options.nullFormat || !input.replace(/[^0-9]+/g, \"\").length) {\n                value = null;\n            } else {\n                for(kind in formats){\n                    regexp = typeof formats[kind].regexps.unformat === \"function\" ? formats[kind].regexps.unformat() : formats[kind].regexps.unformat;\n                    if (regexp && input.match(regexp)) {\n                        unformatFunction = formats[kind].unformat;\n                        break;\n                    }\n                }\n                unformatFunction = unformatFunction || numeral._.stringToNumber;\n                value = unformatFunction(input);\n            }\n        } else {\n            value = Number(input) || null;\n        }\n        return new Numeral(input, value);\n    };\n    // version number\n    numeral.version = VERSION;\n    // compare numeral object\n    numeral.isNumeral = function(obj) {\n        return obj instanceof Numeral;\n    };\n    // helper functions\n    numeral._ = _ = {\n        // formats numbers separators, decimals places, signs, abbreviations\n        numberToFormat: function(value, format, roundingFunction) {\n            var locale = locales[numeral.options.currentLocale], negP = false, optDec = false, leadingCount = 0, abbr = \"\", trillion = 1000000000000, billion = 1000000000, million = 1000000, thousand = 1000, decimal = \"\", neg = false, abbrForce, abs, min, max, power, int, precision, signed, thousands, output;\n            // make sure we never format a null value\n            value = value || 0;\n            abs = Math.abs(value);\n            // see if we should use parentheses for negative number or if we should prefix with a sign\n            // if both are present we default to parentheses\n            if (numeral._.includes(format, \"(\")) {\n                negP = true;\n                format = format.replace(/[\\(|\\)]/g, \"\");\n            } else if (numeral._.includes(format, \"+\") || numeral._.includes(format, \"-\")) {\n                signed = numeral._.includes(format, \"+\") ? format.indexOf(\"+\") : value < 0 ? format.indexOf(\"-\") : -1;\n                format = format.replace(/[\\+|\\-]/g, \"\");\n            }\n            // see if abbreviation is wanted\n            if (numeral._.includes(format, \"a\")) {\n                abbrForce = format.match(/a(k|m|b|t)?/);\n                abbrForce = abbrForce ? abbrForce[1] : false;\n                // check for space before abbreviation\n                if (numeral._.includes(format, \" a\")) {\n                    abbr = \" \";\n                }\n                format = format.replace(new RegExp(abbr + \"a[kmbt]?\"), \"\");\n                if (abs >= trillion && !abbrForce || abbrForce === \"t\") {\n                    // trillion\n                    abbr += locale.abbreviations.trillion;\n                    value = value / trillion;\n                } else if (abs < trillion && abs >= billion && !abbrForce || abbrForce === \"b\") {\n                    // billion\n                    abbr += locale.abbreviations.billion;\n                    value = value / billion;\n                } else if (abs < billion && abs >= million && !abbrForce || abbrForce === \"m\") {\n                    // million\n                    abbr += locale.abbreviations.million;\n                    value = value / million;\n                } else if (abs < million && abs >= thousand && !abbrForce || abbrForce === \"k\") {\n                    // thousand\n                    abbr += locale.abbreviations.thousand;\n                    value = value / thousand;\n                }\n            }\n            // check for optional decimals\n            if (numeral._.includes(format, \"[.]\")) {\n                optDec = true;\n                format = format.replace(\"[.]\", \".\");\n            }\n            // break number and format\n            int = value.toString().split(\".\")[0];\n            precision = format.split(\".\")[1];\n            thousands = format.indexOf(\",\");\n            leadingCount = (format.split(\".\")[0].split(\",\")[0].match(/0/g) || []).length;\n            if (precision) {\n                if (numeral._.includes(precision, \"[\")) {\n                    precision = precision.replace(\"]\", \"\");\n                    precision = precision.split(\"[\");\n                    decimal = numeral._.toFixed(value, precision[0].length + precision[1].length, roundingFunction, precision[1].length);\n                } else {\n                    decimal = numeral._.toFixed(value, precision.length, roundingFunction);\n                }\n                int = decimal.split(\".\")[0];\n                if (numeral._.includes(decimal, \".\")) {\n                    decimal = locale.delimiters.decimal + decimal.split(\".\")[1];\n                } else {\n                    decimal = \"\";\n                }\n                if (optDec && Number(decimal.slice(1)) === 0) {\n                    decimal = \"\";\n                }\n            } else {\n                int = numeral._.toFixed(value, 0, roundingFunction);\n            }\n            // check abbreviation again after rounding\n            if (abbr && !abbrForce && Number(int) >= 1000 && abbr !== locale.abbreviations.trillion) {\n                int = String(Number(int) / 1000);\n                switch(abbr){\n                    case locale.abbreviations.thousand:\n                        abbr = locale.abbreviations.million;\n                        break;\n                    case locale.abbreviations.million:\n                        abbr = locale.abbreviations.billion;\n                        break;\n                    case locale.abbreviations.billion:\n                        abbr = locale.abbreviations.trillion;\n                        break;\n                }\n            }\n            // format number\n            if (numeral._.includes(int, \"-\")) {\n                int = int.slice(1);\n                neg = true;\n            }\n            if (int.length < leadingCount) {\n                for(var i = leadingCount - int.length; i > 0; i--){\n                    int = \"0\" + int;\n                }\n            }\n            if (thousands > -1) {\n                int = int.toString().replace(/(\\d)(?=(\\d{3})+(?!\\d))/g, \"$1\" + locale.delimiters.thousands);\n            }\n            if (format.indexOf(\".\") === 0) {\n                int = \"\";\n            }\n            output = int + decimal + (abbr ? abbr : \"\");\n            if (negP) {\n                output = (negP && neg ? \"(\" : \"\") + output + (negP && neg ? \")\" : \"\");\n            } else {\n                if (signed >= 0) {\n                    output = signed === 0 ? (neg ? \"-\" : \"+\") + output : output + (neg ? \"-\" : \"+\");\n                } else if (neg) {\n                    output = \"-\" + output;\n                }\n            }\n            return output;\n        },\n        // unformats numbers separators, decimals places, signs, abbreviations\n        stringToNumber: function(string) {\n            var locale = locales[options.currentLocale], stringOriginal = string, abbreviations = {\n                thousand: 3,\n                million: 6,\n                billion: 9,\n                trillion: 12\n            }, abbreviation, value, i, regexp;\n            if (options.zeroFormat && string === options.zeroFormat) {\n                value = 0;\n            } else if (options.nullFormat && string === options.nullFormat || !string.replace(/[^0-9]+/g, \"\").length) {\n                value = null;\n            } else {\n                value = 1;\n                if (locale.delimiters.decimal !== \".\") {\n                    string = string.replace(/\\./g, \"\").replace(locale.delimiters.decimal, \".\");\n                }\n                for(abbreviation in abbreviations){\n                    regexp = new RegExp(\"[^a-zA-Z]\" + locale.abbreviations[abbreviation] + \"(?:\\\\)|(\\\\\" + locale.currency.symbol + \")?(?:\\\\))?)?$\");\n                    if (stringOriginal.match(regexp)) {\n                        value *= Math.pow(10, abbreviations[abbreviation]);\n                        break;\n                    }\n                }\n                // check for negative number\n                value *= (string.split(\"-\").length + Math.min(string.split(\"(\").length - 1, string.split(\")\").length - 1)) % 2 ? 1 : -1;\n                // remove non numbers\n                string = string.replace(/[^0-9\\.]+/g, \"\");\n                value *= Number(string);\n            }\n            return value;\n        },\n        isNaN: function(value) {\n            return typeof value === \"number\" && isNaN(value);\n        },\n        includes: function(string, search) {\n            return string.indexOf(search) !== -1;\n        },\n        insert: function(string, subString, start) {\n            return string.slice(0, start) + subString + string.slice(start);\n        },\n        reduce: function(array, callback /*, initialValue*/ ) {\n            if (this === null) {\n                throw new TypeError(\"Array.prototype.reduce called on null or undefined\");\n            }\n            if (typeof callback !== \"function\") {\n                throw new TypeError(callback + \" is not a function\");\n            }\n            var t = Object(array), len = t.length >>> 0, k = 0, value;\n            if (arguments.length === 3) {\n                value = arguments[2];\n            } else {\n                while(k < len && !(k in t)){\n                    k++;\n                }\n                if (k >= len) {\n                    throw new TypeError(\"Reduce of empty array with no initial value\");\n                }\n                value = t[k++];\n            }\n            for(; k < len; k++){\n                if (k in t) {\n                    value = callback(value, t[k], k, t);\n                }\n            }\n            return value;\n        },\n        /**\n         * Computes the multiplier necessary to make x >= 1,\n         * effectively eliminating miscalculations caused by\n         * finite precision.\n         */ multiplier: function(x) {\n            var parts = x.toString().split(\".\");\n            return parts.length < 2 ? 1 : Math.pow(10, parts[1].length);\n        },\n        /**\n         * Given a variable number of arguments, returns the maximum\n         * multiplier that must be used to normalize an operation involving\n         * all of them.\n         */ correctionFactor: function() {\n            var args = Array.prototype.slice.call(arguments);\n            return args.reduce(function(accum, next) {\n                var mn = _.multiplier(next);\n                return accum > mn ? accum : mn;\n            }, 1);\n        },\n        /**\n         * Implementation of toFixed() that treats floats more like decimals\n         *\n         * Fixes binary rounding issues (eg. (0.615).toFixed(2) === '0.61') that present\n         * problems for accounting- and finance-related software.\n         */ toFixed: function(value, maxDecimals, roundingFunction, optionals) {\n            var splitValue = value.toString().split(\".\"), minDecimals = maxDecimals - (optionals || 0), boundedPrecision, optionalsRegExp, power, output;\n            // Use the smallest precision value possible to avoid errors from floating point representation\n            if (splitValue.length === 2) {\n                boundedPrecision = Math.min(Math.max(splitValue[1].length, minDecimals), maxDecimals);\n            } else {\n                boundedPrecision = minDecimals;\n            }\n            power = Math.pow(10, boundedPrecision);\n            // Multiply up by precision, round accurately, then divide and use native toFixed():\n            output = (roundingFunction(value + \"e+\" + boundedPrecision) / power).toFixed(boundedPrecision);\n            if (optionals > maxDecimals - boundedPrecision) {\n                optionalsRegExp = new RegExp(\"\\\\.?0{1,\" + (optionals - (maxDecimals - boundedPrecision)) + \"}$\");\n                output = output.replace(optionalsRegExp, \"\");\n            }\n            return output;\n        }\n    };\n    // avaliable options\n    numeral.options = options;\n    // avaliable formats\n    numeral.formats = formats;\n    // avaliable formats\n    numeral.locales = locales;\n    // This function sets the current locale.  If\n    // no arguments are passed in, it will simply return the current global\n    // locale key.\n    numeral.locale = function(key) {\n        if (key) {\n            options.currentLocale = key.toLowerCase();\n        }\n        return options.currentLocale;\n    };\n    // This function provides access to the loaded locale data.  If\n    // no arguments are passed in, it will simply return the current\n    // global locale object.\n    numeral.localeData = function(key) {\n        if (!key) {\n            return locales[options.currentLocale];\n        }\n        key = key.toLowerCase();\n        if (!locales[key]) {\n            throw new Error(\"Unknown locale : \" + key);\n        }\n        return locales[key];\n    };\n    numeral.reset = function() {\n        for(var property in defaults){\n            options[property] = defaults[property];\n        }\n    };\n    numeral.zeroFormat = function(format) {\n        options.zeroFormat = typeof format === \"string\" ? format : null;\n    };\n    numeral.nullFormat = function(format) {\n        options.nullFormat = typeof format === \"string\" ? format : null;\n    };\n    numeral.defaultFormat = function(format) {\n        options.defaultFormat = typeof format === \"string\" ? format : \"0.0\";\n    };\n    numeral.register = function(type, name, format) {\n        name = name.toLowerCase();\n        if (this[type + \"s\"][name]) {\n            throw new TypeError(name + \" \" + type + \" already registered.\");\n        }\n        this[type + \"s\"][name] = format;\n        return format;\n    };\n    numeral.validate = function(val, culture) {\n        var _decimalSep, _thousandSep, _currSymbol, _valArray, _abbrObj, _thousandRegEx, localeData, temp;\n        //coerce val to string\n        if (typeof val !== \"string\") {\n            val += \"\";\n            if (console.warn) {\n                console.warn(\"Numeral.js: Value is not string. It has been co-erced to: \", val);\n            }\n        }\n        //trim whitespaces from either sides\n        val = val.trim();\n        //if val is just digits return true\n        if (!!val.match(/^\\d+$/)) {\n            return true;\n        }\n        //if val is empty return false\n        if (val === \"\") {\n            return false;\n        }\n        //get the decimal and thousands separator from numeral.localeData\n        try {\n            //check if the culture is understood by numeral. if not, default it to current locale\n            localeData = numeral.localeData(culture);\n        } catch (e) {\n            localeData = numeral.localeData(numeral.locale());\n        }\n        //setup the delimiters and currency symbol based on culture/locale\n        _currSymbol = localeData.currency.symbol;\n        _abbrObj = localeData.abbreviations;\n        _decimalSep = localeData.delimiters.decimal;\n        if (localeData.delimiters.thousands === \".\") {\n            _thousandSep = \"\\\\.\";\n        } else {\n            _thousandSep = localeData.delimiters.thousands;\n        }\n        // validating currency symbol\n        temp = val.match(/^[^\\d]+/);\n        if (temp !== null) {\n            val = val.substr(1);\n            if (temp[0] !== _currSymbol) {\n                return false;\n            }\n        }\n        //validating abbreviation symbol\n        temp = val.match(/[^\\d]+$/);\n        if (temp !== null) {\n            val = val.slice(0, -1);\n            if (temp[0] !== _abbrObj.thousand && temp[0] !== _abbrObj.million && temp[0] !== _abbrObj.billion && temp[0] !== _abbrObj.trillion) {\n                return false;\n            }\n        }\n        _thousandRegEx = new RegExp(_thousandSep + \"{2}\");\n        if (!val.match(/[^\\d.,]/g)) {\n            _valArray = val.split(_decimalSep);\n            if (_valArray.length > 2) {\n                return false;\n            } else {\n                if (_valArray.length < 2) {\n                    return !!_valArray[0].match(/^\\d+.*\\d$/) && !_valArray[0].match(_thousandRegEx);\n                } else {\n                    if (_valArray[0].length === 1) {\n                        return !!_valArray[0].match(/^\\d+$/) && !_valArray[0].match(_thousandRegEx) && !!_valArray[1].match(/^\\d+$/);\n                    } else {\n                        return !!_valArray[0].match(/^\\d+.*\\d$/) && !_valArray[0].match(_thousandRegEx) && !!_valArray[1].match(/^\\d+$/);\n                    }\n                }\n            }\n        }\n        return false;\n    };\n    /************************************\n        Numeral Prototype\n    ************************************/ numeral.fn = Numeral.prototype = {\n        clone: function() {\n            return numeral(this);\n        },\n        format: function(inputString, roundingFunction) {\n            var value = this._value, format = inputString || options.defaultFormat, kind, output, formatFunction;\n            // make sure we have a roundingFunction\n            roundingFunction = roundingFunction || Math.round;\n            // format based on value\n            if (value === 0 && options.zeroFormat !== null) {\n                output = options.zeroFormat;\n            } else if (value === null && options.nullFormat !== null) {\n                output = options.nullFormat;\n            } else {\n                for(kind in formats){\n                    if (format.match(formats[kind].regexps.format)) {\n                        formatFunction = formats[kind].format;\n                        break;\n                    }\n                }\n                formatFunction = formatFunction || numeral._.numberToFormat;\n                output = formatFunction(value, format, roundingFunction);\n            }\n            return output;\n        },\n        value: function() {\n            return this._value;\n        },\n        input: function() {\n            return this._input;\n        },\n        set: function(value) {\n            this._value = Number(value);\n            return this;\n        },\n        add: function(value) {\n            var corrFactor = _.correctionFactor.call(null, this._value, value);\n            function cback(accum, curr, currI, O) {\n                return accum + Math.round(corrFactor * curr);\n            }\n            this._value = _.reduce([\n                this._value,\n                value\n            ], cback, 0) / corrFactor;\n            return this;\n        },\n        subtract: function(value) {\n            var corrFactor = _.correctionFactor.call(null, this._value, value);\n            function cback(accum, curr, currI, O) {\n                return accum - Math.round(corrFactor * curr);\n            }\n            this._value = _.reduce([\n                value\n            ], cback, Math.round(this._value * corrFactor)) / corrFactor;\n            return this;\n        },\n        multiply: function(value) {\n            function cback(accum, curr, currI, O) {\n                var corrFactor = _.correctionFactor(accum, curr);\n                return Math.round(accum * corrFactor) * Math.round(curr * corrFactor) / Math.round(corrFactor * corrFactor);\n            }\n            this._value = _.reduce([\n                this._value,\n                value\n            ], cback, 1);\n            return this;\n        },\n        divide: function(value) {\n            function cback(accum, curr, currI, O) {\n                var corrFactor = _.correctionFactor(accum, curr);\n                return Math.round(accum * corrFactor) / Math.round(curr * corrFactor);\n            }\n            this._value = _.reduce([\n                this._value,\n                value\n            ], cback);\n            return this;\n        },\n        difference: function(value) {\n            return Math.abs(numeral(this._value).subtract(value).value());\n        }\n    };\n    /************************************\n        Default Locale && Format\n    ************************************/ numeral.register(\"locale\", \"en\", {\n        delimiters: {\n            thousands: \",\",\n            decimal: \".\"\n        },\n        abbreviations: {\n            thousand: \"k\",\n            million: \"m\",\n            billion: \"b\",\n            trillion: \"t\"\n        },\n        ordinal: function(number) {\n            var b = number % 10;\n            return ~~(number % 100 / 10) === 1 ? \"th\" : b === 1 ? \"st\" : b === 2 ? \"nd\" : b === 3 ? \"rd\" : \"th\";\n        },\n        currency: {\n            symbol: \"$\"\n        }\n    });\n    (function() {\n        numeral.register(\"format\", \"bps\", {\n            regexps: {\n                format: /(BPS)/,\n                unformat: /(BPS)/\n            },\n            format: function(value, format, roundingFunction) {\n                var space = numeral._.includes(format, \" BPS\") ? \" \" : \"\", output;\n                value = value * 10000;\n                // check for space before BPS\n                format = format.replace(/\\s?BPS/, \"\");\n                output = numeral._.numberToFormat(value, format, roundingFunction);\n                if (numeral._.includes(output, \")\")) {\n                    output = output.split(\"\");\n                    output.splice(-1, 0, space + \"BPS\");\n                    output = output.join(\"\");\n                } else {\n                    output = output + space + \"BPS\";\n                }\n                return output;\n            },\n            unformat: function(string) {\n                return +(numeral._.stringToNumber(string) * 0.0001).toFixed(15);\n            }\n        });\n    })();\n    (function() {\n        var decimal = {\n            base: 1000,\n            suffixes: [\n                \"B\",\n                \"KB\",\n                \"MB\",\n                \"GB\",\n                \"TB\",\n                \"PB\",\n                \"EB\",\n                \"ZB\",\n                \"YB\"\n            ]\n        }, binary = {\n            base: 1024,\n            suffixes: [\n                \"B\",\n                \"KiB\",\n                \"MiB\",\n                \"GiB\",\n                \"TiB\",\n                \"PiB\",\n                \"EiB\",\n                \"ZiB\",\n                \"YiB\"\n            ]\n        };\n        var allSuffixes = decimal.suffixes.concat(binary.suffixes.filter(function(item) {\n            return decimal.suffixes.indexOf(item) < 0;\n        }));\n        var unformatRegex = allSuffixes.join(\"|\");\n        // Allow support for BPS (http://www.investopedia.com/terms/b/basispoint.asp)\n        unformatRegex = \"(\" + unformatRegex.replace(\"B\", \"B(?!PS)\") + \")\";\n        numeral.register(\"format\", \"bytes\", {\n            regexps: {\n                format: /([0\\s]i?b)/,\n                unformat: new RegExp(unformatRegex)\n            },\n            format: function(value, format, roundingFunction) {\n                var output, bytes = numeral._.includes(format, \"ib\") ? binary : decimal, suffix = numeral._.includes(format, \" b\") || numeral._.includes(format, \" ib\") ? \" \" : \"\", power, min, max;\n                // check for space before\n                format = format.replace(/\\s?i?b/, \"\");\n                for(power = 0; power <= bytes.suffixes.length; power++){\n                    min = Math.pow(bytes.base, power);\n                    max = Math.pow(bytes.base, power + 1);\n                    if (value === null || value === 0 || value >= min && value < max) {\n                        suffix += bytes.suffixes[power];\n                        if (min > 0) {\n                            value = value / min;\n                        }\n                        break;\n                    }\n                }\n                output = numeral._.numberToFormat(value, format, roundingFunction);\n                return output + suffix;\n            },\n            unformat: function(string) {\n                var value = numeral._.stringToNumber(string), power, bytesMultiplier;\n                if (value) {\n                    for(power = decimal.suffixes.length - 1; power >= 0; power--){\n                        if (numeral._.includes(string, decimal.suffixes[power])) {\n                            bytesMultiplier = Math.pow(decimal.base, power);\n                            break;\n                        }\n                        if (numeral._.includes(string, binary.suffixes[power])) {\n                            bytesMultiplier = Math.pow(binary.base, power);\n                            break;\n                        }\n                    }\n                    value *= bytesMultiplier || 1;\n                }\n                return value;\n            }\n        });\n    })();\n    (function() {\n        numeral.register(\"format\", \"currency\", {\n            regexps: {\n                format: /(\\$)/\n            },\n            format: function(value, format, roundingFunction) {\n                var locale = numeral.locales[numeral.options.currentLocale], symbols = {\n                    before: format.match(/^([\\+|\\-|\\(|\\s|\\$]*)/)[0],\n                    after: format.match(/([\\+|\\-|\\)|\\s|\\$]*)$/)[0]\n                }, output, symbol, i;\n                // strip format of spaces and $\n                format = format.replace(/\\s?\\$\\s?/, \"\");\n                // format the number\n                output = numeral._.numberToFormat(value, format, roundingFunction);\n                // update the before and after based on value\n                if (value >= 0) {\n                    symbols.before = symbols.before.replace(/[\\-\\(]/, \"\");\n                    symbols.after = symbols.after.replace(/[\\-\\)]/, \"\");\n                } else if (value < 0 && !numeral._.includes(symbols.before, \"-\") && !numeral._.includes(symbols.before, \"(\")) {\n                    symbols.before = \"-\" + symbols.before;\n                }\n                // loop through each before symbol\n                for(i = 0; i < symbols.before.length; i++){\n                    symbol = symbols.before[i];\n                    switch(symbol){\n                        case \"$\":\n                            output = numeral._.insert(output, locale.currency.symbol, i);\n                            break;\n                        case \" \":\n                            output = numeral._.insert(output, \" \", i + locale.currency.symbol.length - 1);\n                            break;\n                    }\n                }\n                // loop through each after symbol\n                for(i = symbols.after.length - 1; i >= 0; i--){\n                    symbol = symbols.after[i];\n                    switch(symbol){\n                        case \"$\":\n                            output = i === symbols.after.length - 1 ? output + locale.currency.symbol : numeral._.insert(output, locale.currency.symbol, -(symbols.after.length - (1 + i)));\n                            break;\n                        case \" \":\n                            output = i === symbols.after.length - 1 ? output + \" \" : numeral._.insert(output, \" \", -(symbols.after.length - (1 + i) + locale.currency.symbol.length - 1));\n                            break;\n                    }\n                }\n                return output;\n            }\n        });\n    })();\n    (function() {\n        numeral.register(\"format\", \"exponential\", {\n            regexps: {\n                format: /(e\\+|e-)/,\n                unformat: /(e\\+|e-)/\n            },\n            format: function(value, format, roundingFunction) {\n                var output, exponential = typeof value === \"number\" && !numeral._.isNaN(value) ? value.toExponential() : \"0e+0\", parts = exponential.split(\"e\");\n                format = format.replace(/e[\\+|\\-]{1}0/, \"\");\n                output = numeral._.numberToFormat(Number(parts[0]), format, roundingFunction);\n                return output + \"e\" + parts[1];\n            },\n            unformat: function(string) {\n                var parts = numeral._.includes(string, \"e+\") ? string.split(\"e+\") : string.split(\"e-\"), value = Number(parts[0]), power = Number(parts[1]);\n                power = numeral._.includes(string, \"e-\") ? power *= -1 : power;\n                function cback(accum, curr, currI, O) {\n                    var corrFactor = numeral._.correctionFactor(accum, curr), num = accum * corrFactor * (curr * corrFactor) / (corrFactor * corrFactor);\n                    return num;\n                }\n                return numeral._.reduce([\n                    value,\n                    Math.pow(10, power)\n                ], cback, 1);\n            }\n        });\n    })();\n    (function() {\n        numeral.register(\"format\", \"ordinal\", {\n            regexps: {\n                format: /(o)/\n            },\n            format: function(value, format, roundingFunction) {\n                var locale = numeral.locales[numeral.options.currentLocale], output, ordinal = numeral._.includes(format, \" o\") ? \" \" : \"\";\n                // check for space before\n                format = format.replace(/\\s?o/, \"\");\n                ordinal += locale.ordinal(value);\n                output = numeral._.numberToFormat(value, format, roundingFunction);\n                return output + ordinal;\n            }\n        });\n    })();\n    (function() {\n        numeral.register(\"format\", \"percentage\", {\n            regexps: {\n                format: /(%)/,\n                unformat: /(%)/\n            },\n            format: function(value, format, roundingFunction) {\n                var space = numeral._.includes(format, \" %\") ? \" \" : \"\", output;\n                if (numeral.options.scalePercentBy100) {\n                    value = value * 100;\n                }\n                // check for space before %\n                format = format.replace(/\\s?\\%/, \"\");\n                output = numeral._.numberToFormat(value, format, roundingFunction);\n                if (numeral._.includes(output, \")\")) {\n                    output = output.split(\"\");\n                    output.splice(-1, 0, space + \"%\");\n                    output = output.join(\"\");\n                } else {\n                    output = output + space + \"%\";\n                }\n                return output;\n            },\n            unformat: function(string) {\n                var number = numeral._.stringToNumber(string);\n                if (numeral.options.scalePercentBy100) {\n                    return number * 0.01;\n                }\n                return number;\n            }\n        });\n    })();\n    (function() {\n        numeral.register(\"format\", \"time\", {\n            regexps: {\n                format: /(:)/,\n                unformat: /(:)/\n            },\n            format: function(value, format, roundingFunction) {\n                var hours = Math.floor(value / 60 / 60), minutes = Math.floor((value - hours * 60 * 60) / 60), seconds = Math.round(value - hours * 60 * 60 - minutes * 60);\n                return hours + \":\" + (minutes < 10 ? \"0\" + minutes : minutes) + \":\" + (seconds < 10 ? \"0\" + seconds : seconds);\n            },\n            unformat: function(string) {\n                var timeArray = string.split(\":\"), seconds = 0;\n                // turn hours and minutes into seconds and add them all up\n                if (timeArray.length === 3) {\n                    // hours\n                    seconds = seconds + Number(timeArray[0]) * 60 * 60;\n                    // minutes\n                    seconds = seconds + Number(timeArray[1]) * 60;\n                    // seconds\n                    seconds = seconds + Number(timeArray[2]);\n                } else if (timeArray.length === 2) {\n                    // minutes\n                    seconds = seconds + Number(timeArray[0]) * 60;\n                    // seconds\n                    seconds = seconds + Number(timeArray[1]);\n                }\n                return Number(seconds);\n            }\n        });\n    })();\n    return numeral;\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Ly4vbm9kZV9tb2R1bGVzL251bWVyYWwvbnVtZXJhbC5qcz81YTBhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qISBAcHJlc2VydmVcbiAqIG51bWVyYWwuanNcbiAqIHZlcnNpb24gOiAyLjAuNlxuICogYXV0aG9yIDogQWRhbSBEcmFwZXJcbiAqIGxpY2Vuc2UgOiBNSVRcbiAqIGh0dHA6Ly9hZGFtd2RyYXBlci5naXRodWIuY29tL051bWVyYWwtanMvXG4gKi9cblxuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIGRlZmluZShmYWN0b3J5KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGdsb2JhbC5udW1lcmFsID0gZmFjdG9yeSgpO1xuICAgIH1cbn0odGhpcywgZnVuY3Rpb24gKCkge1xuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgICAgVmFyaWFibGVzXG4gICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgdmFyIG51bWVyYWwsXG4gICAgICAgIF8sXG4gICAgICAgIFZFUlNJT04gPSAnMi4wLjYnLFxuICAgICAgICBmb3JtYXRzID0ge30sXG4gICAgICAgIGxvY2FsZXMgPSB7fSxcbiAgICAgICAgZGVmYXVsdHMgPSB7XG4gICAgICAgICAgICBjdXJyZW50TG9jYWxlOiAnZW4nLFxuICAgICAgICAgICAgemVyb0Zvcm1hdDogbnVsbCxcbiAgICAgICAgICAgIG51bGxGb3JtYXQ6IG51bGwsXG4gICAgICAgICAgICBkZWZhdWx0Rm9ybWF0OiAnMCwwJyxcbiAgICAgICAgICAgIHNjYWxlUGVyY2VudEJ5MTAwOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICBjdXJyZW50TG9jYWxlOiBkZWZhdWx0cy5jdXJyZW50TG9jYWxlLFxuICAgICAgICAgICAgemVyb0Zvcm1hdDogZGVmYXVsdHMuemVyb0Zvcm1hdCxcbiAgICAgICAgICAgIG51bGxGb3JtYXQ6IGRlZmF1bHRzLm51bGxGb3JtYXQsXG4gICAgICAgICAgICBkZWZhdWx0Rm9ybWF0OiBkZWZhdWx0cy5kZWZhdWx0Rm9ybWF0LFxuICAgICAgICAgICAgc2NhbGVQZXJjZW50QnkxMDA6IGRlZmF1bHRzLnNjYWxlUGVyY2VudEJ5MTAwXG4gICAgICAgIH07XG5cblxuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgICAgQ29uc3RydWN0b3JzXG4gICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgLy8gTnVtZXJhbCBwcm90b3R5cGUgb2JqZWN0XG4gICAgZnVuY3Rpb24gTnVtZXJhbChpbnB1dCwgbnVtYmVyKSB7XG4gICAgICAgIHRoaXMuX2lucHV0ID0gaW5wdXQ7XG5cbiAgICAgICAgdGhpcy5fdmFsdWUgPSBudW1iZXI7XG4gICAgfVxuXG4gICAgbnVtZXJhbCA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHZhciB2YWx1ZSxcbiAgICAgICAgICAgIGtpbmQsXG4gICAgICAgICAgICB1bmZvcm1hdEZ1bmN0aW9uLFxuICAgICAgICAgICAgcmVnZXhwO1xuXG4gICAgICAgIGlmIChudW1lcmFsLmlzTnVtZXJhbChpbnB1dCkpIHtcbiAgICAgICAgICAgIHZhbHVlID0gaW5wdXQudmFsdWUoKTtcbiAgICAgICAgfSBlbHNlIGlmIChpbnB1dCA9PT0gMCB8fCB0eXBlb2YgaW5wdXQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAoaW5wdXQgPT09IG51bGwgfHwgXy5pc05hTihpbnB1dCkpIHtcbiAgICAgICAgICAgIHZhbHVlID0gbnVsbDtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy56ZXJvRm9ybWF0ICYmIGlucHV0ID09PSBvcHRpb25zLnplcm9Gb3JtYXQpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IDA7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG9wdGlvbnMubnVsbEZvcm1hdCAmJiBpbnB1dCA9PT0gb3B0aW9ucy5udWxsRm9ybWF0IHx8ICFpbnB1dC5yZXBsYWNlKC9bXjAtOV0rL2csICcnKS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IG51bGw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAoa2luZCBpbiBmb3JtYXRzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlZ2V4cCA9IHR5cGVvZiBmb3JtYXRzW2tpbmRdLnJlZ2V4cHMudW5mb3JtYXQgPT09ICdmdW5jdGlvbicgPyBmb3JtYXRzW2tpbmRdLnJlZ2V4cHMudW5mb3JtYXQoKSA6IGZvcm1hdHNba2luZF0ucmVnZXhwcy51bmZvcm1hdDtcblxuICAgICAgICAgICAgICAgICAgICBpZiAocmVnZXhwICYmIGlucHV0Lm1hdGNoKHJlZ2V4cCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuZm9ybWF0RnVuY3Rpb24gPSBmb3JtYXRzW2tpbmRdLnVuZm9ybWF0O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHVuZm9ybWF0RnVuY3Rpb24gPSB1bmZvcm1hdEZ1bmN0aW9uIHx8IG51bWVyYWwuXy5zdHJpbmdUb051bWJlcjtcblxuICAgICAgICAgICAgICAgIHZhbHVlID0gdW5mb3JtYXRGdW5jdGlvbihpbnB1dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZSA9IE51bWJlcihpbnB1dCl8fCBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ldyBOdW1lcmFsKGlucHV0LCB2YWx1ZSk7XG4gICAgfTtcblxuICAgIC8vIHZlcnNpb24gbnVtYmVyXG4gICAgbnVtZXJhbC52ZXJzaW9uID0gVkVSU0lPTjtcblxuICAgIC8vIGNvbXBhcmUgbnVtZXJhbCBvYmplY3RcbiAgICBudW1lcmFsLmlzTnVtZXJhbCA9IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgTnVtZXJhbDtcbiAgICB9O1xuXG4gICAgLy8gaGVscGVyIGZ1bmN0aW9uc1xuICAgIG51bWVyYWwuXyA9IF8gPSB7XG4gICAgICAgIC8vIGZvcm1hdHMgbnVtYmVycyBzZXBhcmF0b3JzLCBkZWNpbWFscyBwbGFjZXMsIHNpZ25zLCBhYmJyZXZpYXRpb25zXG4gICAgICAgIG51bWJlclRvRm9ybWF0OiBmdW5jdGlvbih2YWx1ZSwgZm9ybWF0LCByb3VuZGluZ0Z1bmN0aW9uKSB7XG4gICAgICAgICAgICB2YXIgbG9jYWxlID0gbG9jYWxlc1tudW1lcmFsLm9wdGlvbnMuY3VycmVudExvY2FsZV0sXG4gICAgICAgICAgICAgICAgbmVnUCA9IGZhbHNlLFxuICAgICAgICAgICAgICAgIG9wdERlYyA9IGZhbHNlLFxuICAgICAgICAgICAgICAgIGxlYWRpbmdDb3VudCA9IDAsXG4gICAgICAgICAgICAgICAgYWJiciA9ICcnLFxuICAgICAgICAgICAgICAgIHRyaWxsaW9uID0gMTAwMDAwMDAwMDAwMCxcbiAgICAgICAgICAgICAgICBiaWxsaW9uID0gMTAwMDAwMDAwMCxcbiAgICAgICAgICAgICAgICBtaWxsaW9uID0gMTAwMDAwMCxcbiAgICAgICAgICAgICAgICB0aG91c2FuZCA9IDEwMDAsXG4gICAgICAgICAgICAgICAgZGVjaW1hbCA9ICcnLFxuICAgICAgICAgICAgICAgIG5lZyA9IGZhbHNlLFxuICAgICAgICAgICAgICAgIGFiYnJGb3JjZSwgLy8gZm9yY2UgYWJicmV2aWF0aW9uXG4gICAgICAgICAgICAgICAgYWJzLFxuICAgICAgICAgICAgICAgIG1pbixcbiAgICAgICAgICAgICAgICBtYXgsXG4gICAgICAgICAgICAgICAgcG93ZXIsXG4gICAgICAgICAgICAgICAgaW50LFxuICAgICAgICAgICAgICAgIHByZWNpc2lvbixcbiAgICAgICAgICAgICAgICBzaWduZWQsXG4gICAgICAgICAgICAgICAgdGhvdXNhbmRzLFxuICAgICAgICAgICAgICAgIG91dHB1dDtcblxuICAgICAgICAgICAgLy8gbWFrZSBzdXJlIHdlIG5ldmVyIGZvcm1hdCBhIG51bGwgdmFsdWVcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgfHwgMDtcblxuICAgICAgICAgICAgYWJzID0gTWF0aC5hYnModmFsdWUpO1xuXG4gICAgICAgICAgICAvLyBzZWUgaWYgd2Ugc2hvdWxkIHVzZSBwYXJlbnRoZXNlcyBmb3IgbmVnYXRpdmUgbnVtYmVyIG9yIGlmIHdlIHNob3VsZCBwcmVmaXggd2l0aCBhIHNpZ25cbiAgICAgICAgICAgIC8vIGlmIGJvdGggYXJlIHByZXNlbnQgd2UgZGVmYXVsdCB0byBwYXJlbnRoZXNlc1xuICAgICAgICAgICAgaWYgKG51bWVyYWwuXy5pbmNsdWRlcyhmb3JtYXQsICcoJykpIHtcbiAgICAgICAgICAgICAgICBuZWdQID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZSgvW1xcKHxcXCldL2csICcnKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobnVtZXJhbC5fLmluY2x1ZGVzKGZvcm1hdCwgJysnKSB8fCBudW1lcmFsLl8uaW5jbHVkZXMoZm9ybWF0LCAnLScpKSB7XG4gICAgICAgICAgICAgICAgc2lnbmVkID0gbnVtZXJhbC5fLmluY2x1ZGVzKGZvcm1hdCwgJysnKSA/IGZvcm1hdC5pbmRleE9mKCcrJykgOiB2YWx1ZSA8IDAgPyBmb3JtYXQuaW5kZXhPZignLScpIDogLTE7XG4gICAgICAgICAgICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoL1tcXCt8XFwtXS9nLCAnJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHNlZSBpZiBhYmJyZXZpYXRpb24gaXMgd2FudGVkXG4gICAgICAgICAgICBpZiAobnVtZXJhbC5fLmluY2x1ZGVzKGZvcm1hdCwgJ2EnKSkge1xuICAgICAgICAgICAgICAgIGFiYnJGb3JjZSA9IGZvcm1hdC5tYXRjaCgvYShrfG18Ynx0KT8vKTtcblxuICAgICAgICAgICAgICAgIGFiYnJGb3JjZSA9IGFiYnJGb3JjZSA/IGFiYnJGb3JjZVsxXSA6IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgZm9yIHNwYWNlIGJlZm9yZSBhYmJyZXZpYXRpb25cbiAgICAgICAgICAgICAgICBpZiAobnVtZXJhbC5fLmluY2x1ZGVzKGZvcm1hdCwgJyBhJykpIHtcbiAgICAgICAgICAgICAgICAgICAgYWJiciA9ICcgJztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZShuZXcgUmVnRXhwKGFiYnIgKyAnYVtrbWJ0XT8nKSwgJycpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGFicyA+PSB0cmlsbGlvbiAmJiAhYWJickZvcmNlIHx8IGFiYnJGb3JjZSA9PT0gJ3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRyaWxsaW9uXG4gICAgICAgICAgICAgICAgICAgIGFiYnIgKz0gbG9jYWxlLmFiYnJldmlhdGlvbnMudHJpbGxpb247XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgLyB0cmlsbGlvbjtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGFicyA8IHRyaWxsaW9uICYmIGFicyA+PSBiaWxsaW9uICYmICFhYmJyRm9yY2UgfHwgYWJickZvcmNlID09PSAnYicpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYmlsbGlvblxuICAgICAgICAgICAgICAgICAgICBhYmJyICs9IGxvY2FsZS5hYmJyZXZpYXRpb25zLmJpbGxpb247XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgLyBiaWxsaW9uO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYWJzIDwgYmlsbGlvbiAmJiBhYnMgPj0gbWlsbGlvbiAmJiAhYWJickZvcmNlIHx8IGFiYnJGb3JjZSA9PT0gJ20nKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG1pbGxpb25cbiAgICAgICAgICAgICAgICAgICAgYWJiciArPSBsb2NhbGUuYWJicmV2aWF0aW9ucy5taWxsaW9uO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlIC8gbWlsbGlvbjtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGFicyA8IG1pbGxpb24gJiYgYWJzID49IHRob3VzYW5kICYmICFhYmJyRm9yY2UgfHwgYWJickZvcmNlID09PSAnaycpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhvdXNhbmRcbiAgICAgICAgICAgICAgICAgICAgYWJiciArPSBsb2NhbGUuYWJicmV2aWF0aW9ucy50aG91c2FuZDtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSAvIHRob3VzYW5kO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gY2hlY2sgZm9yIG9wdGlvbmFsIGRlY2ltYWxzXG4gICAgICAgICAgICBpZiAobnVtZXJhbC5fLmluY2x1ZGVzKGZvcm1hdCwgJ1suXScpKSB7XG4gICAgICAgICAgICAgICAgb3B0RGVjID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZSgnWy5dJywgJy4nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gYnJlYWsgbnVtYmVyIGFuZCBmb3JtYXRcbiAgICAgICAgICAgIGludCA9IHZhbHVlLnRvU3RyaW5nKCkuc3BsaXQoJy4nKVswXTtcbiAgICAgICAgICAgIHByZWNpc2lvbiA9IGZvcm1hdC5zcGxpdCgnLicpWzFdO1xuICAgICAgICAgICAgdGhvdXNhbmRzID0gZm9ybWF0LmluZGV4T2YoJywnKTtcbiAgICAgICAgICAgIGxlYWRpbmdDb3VudCA9IChmb3JtYXQuc3BsaXQoJy4nKVswXS5zcGxpdCgnLCcpWzBdLm1hdGNoKC8wL2cpIHx8IFtdKS5sZW5ndGg7XG5cbiAgICAgICAgICAgIGlmIChwcmVjaXNpb24pIHtcbiAgICAgICAgICAgICAgICBpZiAobnVtZXJhbC5fLmluY2x1ZGVzKHByZWNpc2lvbiwgJ1snKSkge1xuICAgICAgICAgICAgICAgICAgICBwcmVjaXNpb24gPSBwcmVjaXNpb24ucmVwbGFjZSgnXScsICcnKTtcbiAgICAgICAgICAgICAgICAgICAgcHJlY2lzaW9uID0gcHJlY2lzaW9uLnNwbGl0KCdbJyk7XG4gICAgICAgICAgICAgICAgICAgIGRlY2ltYWwgPSBudW1lcmFsLl8udG9GaXhlZCh2YWx1ZSwgKHByZWNpc2lvblswXS5sZW5ndGggKyBwcmVjaXNpb25bMV0ubGVuZ3RoKSwgcm91bmRpbmdGdW5jdGlvbiwgcHJlY2lzaW9uWzFdLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGVjaW1hbCA9IG51bWVyYWwuXy50b0ZpeGVkKHZhbHVlLCBwcmVjaXNpb24ubGVuZ3RoLCByb3VuZGluZ0Z1bmN0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpbnQgPSBkZWNpbWFsLnNwbGl0KCcuJylbMF07XG5cbiAgICAgICAgICAgICAgICBpZiAobnVtZXJhbC5fLmluY2x1ZGVzKGRlY2ltYWwsICcuJykpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVjaW1hbCA9IGxvY2FsZS5kZWxpbWl0ZXJzLmRlY2ltYWwgKyBkZWNpbWFsLnNwbGl0KCcuJylbMV07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGVjaW1hbCA9ICcnO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChvcHREZWMgJiYgTnVtYmVyKGRlY2ltYWwuc2xpY2UoMSkpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlY2ltYWwgPSAnJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGludCA9IG51bWVyYWwuXy50b0ZpeGVkKHZhbHVlLCAwLCByb3VuZGluZ0Z1bmN0aW9uKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gY2hlY2sgYWJicmV2aWF0aW9uIGFnYWluIGFmdGVyIHJvdW5kaW5nXG4gICAgICAgICAgICBpZiAoYWJiciAmJiAhYWJickZvcmNlICYmIE51bWJlcihpbnQpID49IDEwMDAgJiYgYWJiciAhPT0gbG9jYWxlLmFiYnJldmlhdGlvbnMudHJpbGxpb24pIHtcbiAgICAgICAgICAgICAgICBpbnQgPSBTdHJpbmcoTnVtYmVyKGludCkgLyAxMDAwKTtcblxuICAgICAgICAgICAgICAgIHN3aXRjaCAoYWJicikge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIGxvY2FsZS5hYmJyZXZpYXRpb25zLnRob3VzYW5kOlxuICAgICAgICAgICAgICAgICAgICAgICAgYWJiciA9IGxvY2FsZS5hYmJyZXZpYXRpb25zLm1pbGxpb247XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBsb2NhbGUuYWJicmV2aWF0aW9ucy5taWxsaW9uOlxuICAgICAgICAgICAgICAgICAgICAgICAgYWJiciA9IGxvY2FsZS5hYmJyZXZpYXRpb25zLmJpbGxpb247XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBsb2NhbGUuYWJicmV2aWF0aW9ucy5iaWxsaW9uOlxuICAgICAgICAgICAgICAgICAgICAgICAgYWJiciA9IGxvY2FsZS5hYmJyZXZpYXRpb25zLnRyaWxsaW9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgIC8vIGZvcm1hdCBudW1iZXJcbiAgICAgICAgICAgIGlmIChudW1lcmFsLl8uaW5jbHVkZXMoaW50LCAnLScpKSB7XG4gICAgICAgICAgICAgICAgaW50ID0gaW50LnNsaWNlKDEpO1xuICAgICAgICAgICAgICAgIG5lZyA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpbnQubGVuZ3RoIDwgbGVhZGluZ0NvdW50KSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IGxlYWRpbmdDb3VudCAtIGludC5sZW5ndGg7IGkgPiAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgaW50ID0gJzAnICsgaW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRob3VzYW5kcyA+IC0xKSB7XG4gICAgICAgICAgICAgICAgaW50ID0gaW50LnRvU3RyaW5nKCkucmVwbGFjZSgvKFxcZCkoPz0oXFxkezN9KSsoPyFcXGQpKS9nLCAnJDEnICsgbG9jYWxlLmRlbGltaXRlcnMudGhvdXNhbmRzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGZvcm1hdC5pbmRleE9mKCcuJykgPT09IDApIHtcbiAgICAgICAgICAgICAgICBpbnQgPSAnJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgb3V0cHV0ID0gaW50ICsgZGVjaW1hbCArIChhYmJyID8gYWJiciA6ICcnKTtcblxuICAgICAgICAgICAgaWYgKG5lZ1ApIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSAobmVnUCAmJiBuZWcgPyAnKCcgOiAnJykgKyBvdXRwdXQgKyAobmVnUCAmJiBuZWcgPyAnKScgOiAnJyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChzaWduZWQgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQgPSBzaWduZWQgPT09IDAgPyAobmVnID8gJy0nIDogJysnKSArIG91dHB1dCA6IG91dHB1dCArIChuZWcgPyAnLScgOiAnKycpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobmVnKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dCA9ICctJyArIG91dHB1dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIHVuZm9ybWF0cyBudW1iZXJzIHNlcGFyYXRvcnMsIGRlY2ltYWxzIHBsYWNlcywgc2lnbnMsIGFiYnJldmlhdGlvbnNcbiAgICAgICAgc3RyaW5nVG9OdW1iZXI6IGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAgICAgICAgdmFyIGxvY2FsZSA9IGxvY2FsZXNbb3B0aW9ucy5jdXJyZW50TG9jYWxlXSxcbiAgICAgICAgICAgICAgICBzdHJpbmdPcmlnaW5hbCA9IHN0cmluZyxcbiAgICAgICAgICAgICAgICBhYmJyZXZpYXRpb25zID0ge1xuICAgICAgICAgICAgICAgICAgICB0aG91c2FuZDogMyxcbiAgICAgICAgICAgICAgICAgICAgbWlsbGlvbjogNixcbiAgICAgICAgICAgICAgICAgICAgYmlsbGlvbjogOSxcbiAgICAgICAgICAgICAgICAgICAgdHJpbGxpb246IDEyXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBhYmJyZXZpYXRpb24sXG4gICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgaSxcbiAgICAgICAgICAgICAgICByZWdleHA7XG5cbiAgICAgICAgICAgIGlmIChvcHRpb25zLnplcm9Gb3JtYXQgJiYgc3RyaW5nID09PSBvcHRpb25zLnplcm9Gb3JtYXQpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IDA7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG9wdGlvbnMubnVsbEZvcm1hdCAmJiBzdHJpbmcgPT09IG9wdGlvbnMubnVsbEZvcm1hdCB8fCAhc3RyaW5nLnJlcGxhY2UoL1teMC05XSsvZywgJycpLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSAxO1xuXG4gICAgICAgICAgICAgICAgaWYgKGxvY2FsZS5kZWxpbWl0ZXJzLmRlY2ltYWwgIT09ICcuJykge1xuICAgICAgICAgICAgICAgICAgICBzdHJpbmcgPSBzdHJpbmcucmVwbGFjZSgvXFwuL2csICcnKS5yZXBsYWNlKGxvY2FsZS5kZWxpbWl0ZXJzLmRlY2ltYWwsICcuJyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZm9yIChhYmJyZXZpYXRpb24gaW4gYWJicmV2aWF0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICByZWdleHAgPSBuZXcgUmVnRXhwKCdbXmEtekEtWl0nICsgbG9jYWxlLmFiYnJldmlhdGlvbnNbYWJicmV2aWF0aW9uXSArICcoPzpcXFxcKXwoXFxcXCcgKyBsb2NhbGUuY3VycmVuY3kuc3ltYm9sICsgJyk/KD86XFxcXCkpPyk/JCcpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdHJpbmdPcmlnaW5hbC5tYXRjaChyZWdleHApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSAqPSBNYXRoLnBvdygxMCwgYWJicmV2aWF0aW9uc1thYmJyZXZpYXRpb25dKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgZm9yIG5lZ2F0aXZlIG51bWJlclxuICAgICAgICAgICAgICAgIHZhbHVlICo9IChzdHJpbmcuc3BsaXQoJy0nKS5sZW5ndGggKyBNYXRoLm1pbihzdHJpbmcuc3BsaXQoJygnKS5sZW5ndGggLSAxLCBzdHJpbmcuc3BsaXQoJyknKS5sZW5ndGggLSAxKSkgJSAyID8gMSA6IC0xO1xuXG4gICAgICAgICAgICAgICAgLy8gcmVtb3ZlIG5vbiBudW1iZXJzXG4gICAgICAgICAgICAgICAgc3RyaW5nID0gc3RyaW5nLnJlcGxhY2UoL1teMC05XFwuXSsvZywgJycpO1xuXG4gICAgICAgICAgICAgICAgdmFsdWUgKj0gTnVtYmVyKHN0cmluZyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgaXNOYU46IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiBpc05hTih2YWx1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGluY2x1ZGVzOiBmdW5jdGlvbihzdHJpbmcsIHNlYXJjaCkge1xuICAgICAgICAgICAgcmV0dXJuIHN0cmluZy5pbmRleE9mKHNlYXJjaCkgIT09IC0xO1xuICAgICAgICB9LFxuICAgICAgICBpbnNlcnQ6IGZ1bmN0aW9uKHN0cmluZywgc3ViU3RyaW5nLCBzdGFydCkge1xuICAgICAgICAgICAgcmV0dXJuIHN0cmluZy5zbGljZSgwLCBzdGFydCkgKyBzdWJTdHJpbmcgKyBzdHJpbmcuc2xpY2Uoc3RhcnQpO1xuICAgICAgICB9LFxuICAgICAgICByZWR1Y2U6IGZ1bmN0aW9uKGFycmF5LCBjYWxsYmFjayAvKiwgaW5pdGlhbFZhbHVlKi8pIHtcbiAgICAgICAgICAgIGlmICh0aGlzID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJyYXkucHJvdG90eXBlLnJlZHVjZSBjYWxsZWQgb24gbnVsbCBvciB1bmRlZmluZWQnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoY2FsbGJhY2sgKyAnIGlzIG5vdCBhIGZ1bmN0aW9uJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB0ID0gT2JqZWN0KGFycmF5KSxcbiAgICAgICAgICAgICAgICBsZW4gPSB0Lmxlbmd0aCA+Pj4gMCxcbiAgICAgICAgICAgICAgICBrID0gMCxcbiAgICAgICAgICAgICAgICB2YWx1ZTtcblxuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGFyZ3VtZW50c1syXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGsgPCBsZW4gJiYgIShrIGluIHQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGsrKztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoayA+PSBsZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUmVkdWNlIG9mIGVtcHR5IGFycmF5IHdpdGggbm8gaW5pdGlhbCB2YWx1ZScpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhbHVlID0gdFtrKytdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICg7IGsgPCBsZW47IGsrKykge1xuICAgICAgICAgICAgICAgIGlmIChrIGluIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBjYWxsYmFjayh2YWx1ZSwgdFtrXSwgaywgdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQ29tcHV0ZXMgdGhlIG11bHRpcGxpZXIgbmVjZXNzYXJ5IHRvIG1ha2UgeCA+PSAxLFxuICAgICAgICAgKiBlZmZlY3RpdmVseSBlbGltaW5hdGluZyBtaXNjYWxjdWxhdGlvbnMgY2F1c2VkIGJ5XG4gICAgICAgICAqIGZpbml0ZSBwcmVjaXNpb24uXG4gICAgICAgICAqL1xuICAgICAgICBtdWx0aXBsaWVyOiBmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgdmFyIHBhcnRzID0geC50b1N0cmluZygpLnNwbGl0KCcuJyk7XG5cbiAgICAgICAgICAgIHJldHVybiBwYXJ0cy5sZW5ndGggPCAyID8gMSA6IE1hdGgucG93KDEwLCBwYXJ0c1sxXS5sZW5ndGgpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogR2l2ZW4gYSB2YXJpYWJsZSBudW1iZXIgb2YgYXJndW1lbnRzLCByZXR1cm5zIHRoZSBtYXhpbXVtXG4gICAgICAgICAqIG11bHRpcGxpZXIgdGhhdCBtdXN0IGJlIHVzZWQgdG8gbm9ybWFsaXplIGFuIG9wZXJhdGlvbiBpbnZvbHZpbmdcbiAgICAgICAgICogYWxsIG9mIHRoZW0uXG4gICAgICAgICAqL1xuICAgICAgICBjb3JyZWN0aW9uRmFjdG9yOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG5cbiAgICAgICAgICAgIHJldHVybiBhcmdzLnJlZHVjZShmdW5jdGlvbihhY2N1bSwgbmV4dCkge1xuICAgICAgICAgICAgICAgIHZhciBtbiA9IF8ubXVsdGlwbGllcihuZXh0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjdW0gPiBtbiA/IGFjY3VtIDogbW47XG4gICAgICAgICAgICB9LCAxKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEltcGxlbWVudGF0aW9uIG9mIHRvRml4ZWQoKSB0aGF0IHRyZWF0cyBmbG9hdHMgbW9yZSBsaWtlIGRlY2ltYWxzXG4gICAgICAgICAqXG4gICAgICAgICAqIEZpeGVzIGJpbmFyeSByb3VuZGluZyBpc3N1ZXMgKGVnLiAoMC42MTUpLnRvRml4ZWQoMikgPT09ICcwLjYxJykgdGhhdCBwcmVzZW50XG4gICAgICAgICAqIHByb2JsZW1zIGZvciBhY2NvdW50aW5nLSBhbmQgZmluYW5jZS1yZWxhdGVkIHNvZnR3YXJlLlxuICAgICAgICAgKi9cbiAgICAgICAgdG9GaXhlZDogZnVuY3Rpb24odmFsdWUsIG1heERlY2ltYWxzLCByb3VuZGluZ0Z1bmN0aW9uLCBvcHRpb25hbHMpIHtcbiAgICAgICAgICAgIHZhciBzcGxpdFZhbHVlID0gdmFsdWUudG9TdHJpbmcoKS5zcGxpdCgnLicpLFxuICAgICAgICAgICAgICAgIG1pbkRlY2ltYWxzID0gbWF4RGVjaW1hbHMgLSAob3B0aW9uYWxzIHx8IDApLFxuICAgICAgICAgICAgICAgIGJvdW5kZWRQcmVjaXNpb24sXG4gICAgICAgICAgICAgICAgb3B0aW9uYWxzUmVnRXhwLFxuICAgICAgICAgICAgICAgIHBvd2VyLFxuICAgICAgICAgICAgICAgIG91dHB1dDtcblxuICAgICAgICAgICAgLy8gVXNlIHRoZSBzbWFsbGVzdCBwcmVjaXNpb24gdmFsdWUgcG9zc2libGUgdG8gYXZvaWQgZXJyb3JzIGZyb20gZmxvYXRpbmcgcG9pbnQgcmVwcmVzZW50YXRpb25cbiAgICAgICAgICAgIGlmIChzcGxpdFZhbHVlLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgICBib3VuZGVkUHJlY2lzaW9uID0gTWF0aC5taW4oTWF0aC5tYXgoc3BsaXRWYWx1ZVsxXS5sZW5ndGgsIG1pbkRlY2ltYWxzKSwgbWF4RGVjaW1hbHMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYm91bmRlZFByZWNpc2lvbiA9IG1pbkRlY2ltYWxzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwb3dlciA9IE1hdGgucG93KDEwLCBib3VuZGVkUHJlY2lzaW9uKTtcblxuICAgICAgICAgICAgLy8gTXVsdGlwbHkgdXAgYnkgcHJlY2lzaW9uLCByb3VuZCBhY2N1cmF0ZWx5LCB0aGVuIGRpdmlkZSBhbmQgdXNlIG5hdGl2ZSB0b0ZpeGVkKCk6XG4gICAgICAgICAgICBvdXRwdXQgPSAocm91bmRpbmdGdW5jdGlvbih2YWx1ZSArICdlKycgKyBib3VuZGVkUHJlY2lzaW9uKSAvIHBvd2VyKS50b0ZpeGVkKGJvdW5kZWRQcmVjaXNpb24pO1xuXG4gICAgICAgICAgICBpZiAob3B0aW9uYWxzID4gbWF4RGVjaW1hbHMgLSBib3VuZGVkUHJlY2lzaW9uKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9uYWxzUmVnRXhwID0gbmV3IFJlZ0V4cCgnXFxcXC4/MHsxLCcgKyAob3B0aW9uYWxzIC0gKG1heERlY2ltYWxzIC0gYm91bmRlZFByZWNpc2lvbikpICsgJ30kJyk7XG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gb3V0cHV0LnJlcGxhY2Uob3B0aW9uYWxzUmVnRXhwLCAnJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gYXZhbGlhYmxlIG9wdGlvbnNcbiAgICBudW1lcmFsLm9wdGlvbnMgPSBvcHRpb25zO1xuXG4gICAgLy8gYXZhbGlhYmxlIGZvcm1hdHNcbiAgICBudW1lcmFsLmZvcm1hdHMgPSBmb3JtYXRzO1xuXG4gICAgLy8gYXZhbGlhYmxlIGZvcm1hdHNcbiAgICBudW1lcmFsLmxvY2FsZXMgPSBsb2NhbGVzO1xuXG4gICAgLy8gVGhpcyBmdW5jdGlvbiBzZXRzIHRoZSBjdXJyZW50IGxvY2FsZS4gIElmXG4gICAgLy8gbm8gYXJndW1lbnRzIGFyZSBwYXNzZWQgaW4sIGl0IHdpbGwgc2ltcGx5IHJldHVybiB0aGUgY3VycmVudCBnbG9iYWxcbiAgICAvLyBsb2NhbGUga2V5LlxuICAgIG51bWVyYWwubG9jYWxlID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuY3VycmVudExvY2FsZSA9IGtleS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG9wdGlvbnMuY3VycmVudExvY2FsZTtcbiAgICB9O1xuXG4gICAgLy8gVGhpcyBmdW5jdGlvbiBwcm92aWRlcyBhY2Nlc3MgdG8gdGhlIGxvYWRlZCBsb2NhbGUgZGF0YS4gIElmXG4gICAgLy8gbm8gYXJndW1lbnRzIGFyZSBwYXNzZWQgaW4sIGl0IHdpbGwgc2ltcGx5IHJldHVybiB0aGUgY3VycmVudFxuICAgIC8vIGdsb2JhbCBsb2NhbGUgb2JqZWN0LlxuICAgIG51bWVyYWwubG9jYWxlRGF0YSA9IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICBpZiAoIWtleSkge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsZXNbb3B0aW9ucy5jdXJyZW50TG9jYWxlXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGtleSA9IGtleS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICAgIGlmICghbG9jYWxlc1trZXldKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gbG9jYWxlIDogJyArIGtleSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbG9jYWxlc1trZXldO1xuICAgIH07XG5cbiAgICBudW1lcmFsLnJlc2V0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGZvciAodmFyIHByb3BlcnR5IGluIGRlZmF1bHRzKSB7XG4gICAgICAgICAgICBvcHRpb25zW3Byb3BlcnR5XSA9IGRlZmF1bHRzW3Byb3BlcnR5XTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBudW1lcmFsLnplcm9Gb3JtYXQgPSBmdW5jdGlvbihmb3JtYXQpIHtcbiAgICAgICAgb3B0aW9ucy56ZXJvRm9ybWF0ID0gdHlwZW9mKGZvcm1hdCkgPT09ICdzdHJpbmcnID8gZm9ybWF0IDogbnVsbDtcbiAgICB9O1xuXG4gICAgbnVtZXJhbC5udWxsRm9ybWF0ID0gZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgICBvcHRpb25zLm51bGxGb3JtYXQgPSB0eXBlb2YoZm9ybWF0KSA9PT0gJ3N0cmluZycgPyBmb3JtYXQgOiBudWxsO1xuICAgIH07XG5cbiAgICBudW1lcmFsLmRlZmF1bHRGb3JtYXQgPSBmdW5jdGlvbihmb3JtYXQpIHtcbiAgICAgICAgb3B0aW9ucy5kZWZhdWx0Rm9ybWF0ID0gdHlwZW9mKGZvcm1hdCkgPT09ICdzdHJpbmcnID8gZm9ybWF0IDogJzAuMCc7XG4gICAgfTtcblxuICAgIG51bWVyYWwucmVnaXN0ZXIgPSBmdW5jdGlvbih0eXBlLCBuYW1lLCBmb3JtYXQpIHtcbiAgICAgICAgbmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcblxuICAgICAgICBpZiAodGhpc1t0eXBlICsgJ3MnXVtuYW1lXSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihuYW1lICsgJyAnICsgdHlwZSArICcgYWxyZWFkeSByZWdpc3RlcmVkLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpc1t0eXBlICsgJ3MnXVtuYW1lXSA9IGZvcm1hdDtcblxuICAgICAgICByZXR1cm4gZm9ybWF0O1xuICAgIH07XG5cblxuICAgIG51bWVyYWwudmFsaWRhdGUgPSBmdW5jdGlvbih2YWwsIGN1bHR1cmUpIHtcbiAgICAgICAgdmFyIF9kZWNpbWFsU2VwLFxuICAgICAgICAgICAgX3Rob3VzYW5kU2VwLFxuICAgICAgICAgICAgX2N1cnJTeW1ib2wsXG4gICAgICAgICAgICBfdmFsQXJyYXksXG4gICAgICAgICAgICBfYWJick9iaixcbiAgICAgICAgICAgIF90aG91c2FuZFJlZ0V4LFxuICAgICAgICAgICAgbG9jYWxlRGF0YSxcbiAgICAgICAgICAgIHRlbXA7XG5cbiAgICAgICAgLy9jb2VyY2UgdmFsIHRvIHN0cmluZ1xuICAgICAgICBpZiAodHlwZW9mIHZhbCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHZhbCArPSAnJztcblxuICAgICAgICAgICAgaWYgKGNvbnNvbGUud2Fybikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignTnVtZXJhbC5qczogVmFsdWUgaXMgbm90IHN0cmluZy4gSXQgaGFzIGJlZW4gY28tZXJjZWQgdG86ICcsIHZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvL3RyaW0gd2hpdGVzcGFjZXMgZnJvbSBlaXRoZXIgc2lkZXNcbiAgICAgICAgdmFsID0gdmFsLnRyaW0oKTtcblxuICAgICAgICAvL2lmIHZhbCBpcyBqdXN0IGRpZ2l0cyByZXR1cm4gdHJ1ZVxuICAgICAgICBpZiAoISF2YWwubWF0Y2goL15cXGQrJC8pKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vaWYgdmFsIGlzIGVtcHR5IHJldHVybiBmYWxzZVxuICAgICAgICBpZiAodmFsID09PSAnJykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9nZXQgdGhlIGRlY2ltYWwgYW5kIHRob3VzYW5kcyBzZXBhcmF0b3IgZnJvbSBudW1lcmFsLmxvY2FsZURhdGFcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vY2hlY2sgaWYgdGhlIGN1bHR1cmUgaXMgdW5kZXJzdG9vZCBieSBudW1lcmFsLiBpZiBub3QsIGRlZmF1bHQgaXQgdG8gY3VycmVudCBsb2NhbGVcbiAgICAgICAgICAgIGxvY2FsZURhdGEgPSBudW1lcmFsLmxvY2FsZURhdGEoY3VsdHVyZSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGxvY2FsZURhdGEgPSBudW1lcmFsLmxvY2FsZURhdGEobnVtZXJhbC5sb2NhbGUoKSk7XG4gICAgICAgIH1cblxuICAgICAgICAvL3NldHVwIHRoZSBkZWxpbWl0ZXJzIGFuZCBjdXJyZW5jeSBzeW1ib2wgYmFzZWQgb24gY3VsdHVyZS9sb2NhbGVcbiAgICAgICAgX2N1cnJTeW1ib2wgPSBsb2NhbGVEYXRhLmN1cnJlbmN5LnN5bWJvbDtcbiAgICAgICAgX2FiYnJPYmogPSBsb2NhbGVEYXRhLmFiYnJldmlhdGlvbnM7XG4gICAgICAgIF9kZWNpbWFsU2VwID0gbG9jYWxlRGF0YS5kZWxpbWl0ZXJzLmRlY2ltYWw7XG4gICAgICAgIGlmIChsb2NhbGVEYXRhLmRlbGltaXRlcnMudGhvdXNhbmRzID09PSAnLicpIHtcbiAgICAgICAgICAgIF90aG91c2FuZFNlcCA9ICdcXFxcLic7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBfdGhvdXNhbmRTZXAgPSBsb2NhbGVEYXRhLmRlbGltaXRlcnMudGhvdXNhbmRzO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdmFsaWRhdGluZyBjdXJyZW5jeSBzeW1ib2xcbiAgICAgICAgdGVtcCA9IHZhbC5tYXRjaCgvXlteXFxkXSsvKTtcbiAgICAgICAgaWYgKHRlbXAgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhbCA9IHZhbC5zdWJzdHIoMSk7XG4gICAgICAgICAgICBpZiAodGVtcFswXSAhPT0gX2N1cnJTeW1ib2wpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvL3ZhbGlkYXRpbmcgYWJicmV2aWF0aW9uIHN5bWJvbFxuICAgICAgICB0ZW1wID0gdmFsLm1hdGNoKC9bXlxcZF0rJC8pO1xuICAgICAgICBpZiAodGVtcCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFsID0gdmFsLnNsaWNlKDAsIC0xKTtcbiAgICAgICAgICAgIGlmICh0ZW1wWzBdICE9PSBfYWJick9iai50aG91c2FuZCAmJiB0ZW1wWzBdICE9PSBfYWJick9iai5taWxsaW9uICYmIHRlbXBbMF0gIT09IF9hYmJyT2JqLmJpbGxpb24gJiYgdGVtcFswXSAhPT0gX2FiYnJPYmoudHJpbGxpb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBfdGhvdXNhbmRSZWdFeCA9IG5ldyBSZWdFeHAoX3Rob3VzYW5kU2VwICsgJ3syfScpO1xuXG4gICAgICAgIGlmICghdmFsLm1hdGNoKC9bXlxcZC4sXS9nKSkge1xuICAgICAgICAgICAgX3ZhbEFycmF5ID0gdmFsLnNwbGl0KF9kZWNpbWFsU2VwKTtcbiAgICAgICAgICAgIGlmIChfdmFsQXJyYXkubGVuZ3RoID4gMikge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKF92YWxBcnJheS5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoICEhIF92YWxBcnJheVswXS5tYXRjaCgvXlxcZCsuKlxcZCQvKSAmJiAhX3ZhbEFycmF5WzBdLm1hdGNoKF90aG91c2FuZFJlZ0V4KSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF92YWxBcnJheVswXS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoICEhIF92YWxBcnJheVswXS5tYXRjaCgvXlxcZCskLykgJiYgIV92YWxBcnJheVswXS5tYXRjaChfdGhvdXNhbmRSZWdFeCkgJiYgISEgX3ZhbEFycmF5WzFdLm1hdGNoKC9eXFxkKyQvKSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKCAhISBfdmFsQXJyYXlbMF0ubWF0Y2goL15cXGQrLipcXGQkLykgJiYgIV92YWxBcnJheVswXS5tYXRjaChfdGhvdXNhbmRSZWdFeCkgJiYgISEgX3ZhbEFycmF5WzFdLm1hdGNoKC9eXFxkKyQvKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuXG4gICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAgICBOdW1lcmFsIFByb3RvdHlwZVxuICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgIG51bWVyYWwuZm4gPSBOdW1lcmFsLnByb3RvdHlwZSA9IHtcbiAgICAgICAgY2xvbmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bWVyYWwodGhpcyk7XG4gICAgICAgIH0sXG4gICAgICAgIGZvcm1hdDogZnVuY3Rpb24oaW5wdXRTdHJpbmcsIHJvdW5kaW5nRnVuY3Rpb24pIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuX3ZhbHVlLFxuICAgICAgICAgICAgICAgIGZvcm1hdCA9IGlucHV0U3RyaW5nIHx8IG9wdGlvbnMuZGVmYXVsdEZvcm1hdCxcbiAgICAgICAgICAgICAgICBraW5kLFxuICAgICAgICAgICAgICAgIG91dHB1dCxcbiAgICAgICAgICAgICAgICBmb3JtYXRGdW5jdGlvbjtcblxuICAgICAgICAgICAgLy8gbWFrZSBzdXJlIHdlIGhhdmUgYSByb3VuZGluZ0Z1bmN0aW9uXG4gICAgICAgICAgICByb3VuZGluZ0Z1bmN0aW9uID0gcm91bmRpbmdGdW5jdGlvbiB8fCBNYXRoLnJvdW5kO1xuXG4gICAgICAgICAgICAvLyBmb3JtYXQgYmFzZWQgb24gdmFsdWVcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gMCAmJiBvcHRpb25zLnplcm9Gb3JtYXQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSBvcHRpb25zLnplcm9Gb3JtYXQ7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlID09PSBudWxsICYmIG9wdGlvbnMubnVsbEZvcm1hdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIG91dHB1dCA9IG9wdGlvbnMubnVsbEZvcm1hdDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yIChraW5kIGluIGZvcm1hdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZvcm1hdC5tYXRjaChmb3JtYXRzW2tpbmRdLnJlZ2V4cHMuZm9ybWF0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0RnVuY3Rpb24gPSBmb3JtYXRzW2tpbmRdLmZvcm1hdDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmb3JtYXRGdW5jdGlvbiA9IGZvcm1hdEZ1bmN0aW9uIHx8IG51bWVyYWwuXy5udW1iZXJUb0Zvcm1hdDtcblxuICAgICAgICAgICAgICAgIG91dHB1dCA9IGZvcm1hdEZ1bmN0aW9uKHZhbHVlLCBmb3JtYXQsIHJvdW5kaW5nRnVuY3Rpb24pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgICAgICB9LFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIGlucHV0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pbnB1dDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fdmFsdWUgPSBOdW1iZXIodmFsdWUpO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgYWRkOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIGNvcnJGYWN0b3IgPSBfLmNvcnJlY3Rpb25GYWN0b3IuY2FsbChudWxsLCB0aGlzLl92YWx1ZSwgdmFsdWUpO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBjYmFjayhhY2N1bSwgY3VyciwgY3VyckksIE8pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjdW0gKyBNYXRoLnJvdW5kKGNvcnJGYWN0b3IgKiBjdXJyKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fdmFsdWUgPSBfLnJlZHVjZShbdGhpcy5fdmFsdWUsIHZhbHVlXSwgY2JhY2ssIDApIC8gY29yckZhY3RvcjtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIHN1YnRyYWN0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIGNvcnJGYWN0b3IgPSBfLmNvcnJlY3Rpb25GYWN0b3IuY2FsbChudWxsLCB0aGlzLl92YWx1ZSwgdmFsdWUpO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBjYmFjayhhY2N1bSwgY3VyciwgY3VyckksIE8pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjdW0gLSBNYXRoLnJvdW5kKGNvcnJGYWN0b3IgKiBjdXJyKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fdmFsdWUgPSBfLnJlZHVjZShbdmFsdWVdLCBjYmFjaywgTWF0aC5yb3VuZCh0aGlzLl92YWx1ZSAqIGNvcnJGYWN0b3IpKSAvIGNvcnJGYWN0b3I7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICBtdWx0aXBseTogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGNiYWNrKGFjY3VtLCBjdXJyLCBjdXJySSwgTykge1xuICAgICAgICAgICAgICAgIHZhciBjb3JyRmFjdG9yID0gXy5jb3JyZWN0aW9uRmFjdG9yKGFjY3VtLCBjdXJyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5yb3VuZChhY2N1bSAqIGNvcnJGYWN0b3IpICogTWF0aC5yb3VuZChjdXJyICogY29yckZhY3RvcikgLyBNYXRoLnJvdW5kKGNvcnJGYWN0b3IgKiBjb3JyRmFjdG9yKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fdmFsdWUgPSBfLnJlZHVjZShbdGhpcy5fdmFsdWUsIHZhbHVlXSwgY2JhY2ssIDEpO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgZGl2aWRlOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgZnVuY3Rpb24gY2JhY2soYWNjdW0sIGN1cnIsIGN1cnJJLCBPKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvcnJGYWN0b3IgPSBfLmNvcnJlY3Rpb25GYWN0b3IoYWNjdW0sIGN1cnIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLnJvdW5kKGFjY3VtICogY29yckZhY3RvcikgLyBNYXRoLnJvdW5kKGN1cnIgKiBjb3JyRmFjdG9yKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fdmFsdWUgPSBfLnJlZHVjZShbdGhpcy5fdmFsdWUsIHZhbHVlXSwgY2JhY2spO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgZGlmZmVyZW5jZTogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmFicyhudW1lcmFsKHRoaXMuX3ZhbHVlKS5zdWJ0cmFjdCh2YWx1ZSkudmFsdWUoKSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAgICBEZWZhdWx0IExvY2FsZSAmJiBGb3JtYXRcbiAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICBudW1lcmFsLnJlZ2lzdGVyKCdsb2NhbGUnLCAnZW4nLCB7XG4gICAgICAgIGRlbGltaXRlcnM6IHtcbiAgICAgICAgICAgIHRob3VzYW5kczogJywnLFxuICAgICAgICAgICAgZGVjaW1hbDogJy4nXG4gICAgICAgIH0sXG4gICAgICAgIGFiYnJldmlhdGlvbnM6IHtcbiAgICAgICAgICAgIHRob3VzYW5kOiAnaycsXG4gICAgICAgICAgICBtaWxsaW9uOiAnbScsXG4gICAgICAgICAgICBiaWxsaW9uOiAnYicsXG4gICAgICAgICAgICB0cmlsbGlvbjogJ3QnXG4gICAgICAgIH0sXG4gICAgICAgIG9yZGluYWw6IGZ1bmN0aW9uKG51bWJlcikge1xuICAgICAgICAgICAgdmFyIGIgPSBudW1iZXIgJSAxMDtcbiAgICAgICAgICAgIHJldHVybiAofn4obnVtYmVyICUgMTAwIC8gMTApID09PSAxKSA/ICd0aCcgOlxuICAgICAgICAgICAgICAgIChiID09PSAxKSA/ICdzdCcgOlxuICAgICAgICAgICAgICAgIChiID09PSAyKSA/ICduZCcgOlxuICAgICAgICAgICAgICAgIChiID09PSAzKSA/ICdyZCcgOiAndGgnO1xuICAgICAgICB9LFxuICAgICAgICBjdXJyZW5jeToge1xuICAgICAgICAgICAgc3ltYm9sOiAnJCdcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgXG5cbihmdW5jdGlvbigpIHtcbiAgICAgICAgbnVtZXJhbC5yZWdpc3RlcignZm9ybWF0JywgJ2JwcycsIHtcbiAgICAgICAgICAgIHJlZ2V4cHM6IHtcbiAgICAgICAgICAgICAgICBmb3JtYXQ6IC8oQlBTKS8sXG4gICAgICAgICAgICAgICAgdW5mb3JtYXQ6IC8oQlBTKS9cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmb3JtYXQ6IGZ1bmN0aW9uKHZhbHVlLCBmb3JtYXQsIHJvdW5kaW5nRnVuY3Rpb24pIHtcbiAgICAgICAgICAgICAgICB2YXIgc3BhY2UgPSBudW1lcmFsLl8uaW5jbHVkZXMoZm9ybWF0LCAnIEJQUycpID8gJyAnIDogJycsXG4gICAgICAgICAgICAgICAgICAgIG91dHB1dDtcblxuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgKiAxMDAwMDtcblxuICAgICAgICAgICAgICAgIC8vIGNoZWNrIGZvciBzcGFjZSBiZWZvcmUgQlBTXG4gICAgICAgICAgICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoL1xccz9CUFMvLCAnJyk7XG5cbiAgICAgICAgICAgICAgICBvdXRwdXQgPSBudW1lcmFsLl8ubnVtYmVyVG9Gb3JtYXQodmFsdWUsIGZvcm1hdCwgcm91bmRpbmdGdW5jdGlvbik7XG5cbiAgICAgICAgICAgICAgICBpZiAobnVtZXJhbC5fLmluY2x1ZGVzKG91dHB1dCwgJyknKSkge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQgPSBvdXRwdXQuc3BsaXQoJycpO1xuXG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5zcGxpY2UoLTEsIDAsIHNwYWNlICsgJ0JQUycpO1xuXG4gICAgICAgICAgICAgICAgICAgIG91dHB1dCA9IG91dHB1dC5qb2luKCcnKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQgPSBvdXRwdXQgKyBzcGFjZSArICdCUFMnO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdW5mb3JtYXQ6IGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAgICAgICAgICAgIHJldHVybiArKG51bWVyYWwuXy5zdHJpbmdUb051bWJlcihzdHJpbmcpICogMC4wMDAxKS50b0ZpeGVkKDE1KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG59KSgpO1xuXG5cbihmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGRlY2ltYWwgPSB7XG4gICAgICAgICAgICBiYXNlOiAxMDAwLFxuICAgICAgICAgICAgc3VmZml4ZXM6IFsnQicsICdLQicsICdNQicsICdHQicsICdUQicsICdQQicsICdFQicsICdaQicsICdZQiddXG4gICAgICAgIH0sXG4gICAgICAgIGJpbmFyeSA9IHtcbiAgICAgICAgICAgIGJhc2U6IDEwMjQsXG4gICAgICAgICAgICBzdWZmaXhlczogWydCJywgJ0tpQicsICdNaUInLCAnR2lCJywgJ1RpQicsICdQaUInLCAnRWlCJywgJ1ppQicsICdZaUInXVxuICAgICAgICB9O1xuXG4gICAgdmFyIGFsbFN1ZmZpeGVzID0gIGRlY2ltYWwuc3VmZml4ZXMuY29uY2F0KGJpbmFyeS5zdWZmaXhlcy5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgIHJldHVybiBkZWNpbWFsLnN1ZmZpeGVzLmluZGV4T2YoaXRlbSkgPCAwO1xuICAgICAgICB9KSk7XG4gICAgICAgIHZhciB1bmZvcm1hdFJlZ2V4ID0gYWxsU3VmZml4ZXMuam9pbignfCcpO1xuICAgICAgICAvLyBBbGxvdyBzdXBwb3J0IGZvciBCUFMgKGh0dHA6Ly93d3cuaW52ZXN0b3BlZGlhLmNvbS90ZXJtcy9iL2Jhc2lzcG9pbnQuYXNwKVxuICAgICAgICB1bmZvcm1hdFJlZ2V4ID0gJygnICsgdW5mb3JtYXRSZWdleC5yZXBsYWNlKCdCJywgJ0IoPyFQUyknKSArICcpJztcblxuICAgIG51bWVyYWwucmVnaXN0ZXIoJ2Zvcm1hdCcsICdieXRlcycsIHtcbiAgICAgICAgcmVnZXhwczoge1xuICAgICAgICAgICAgZm9ybWF0OiAvKFswXFxzXWk/YikvLFxuICAgICAgICAgICAgdW5mb3JtYXQ6IG5ldyBSZWdFeHAodW5mb3JtYXRSZWdleClcbiAgICAgICAgfSxcbiAgICAgICAgZm9ybWF0OiBmdW5jdGlvbih2YWx1ZSwgZm9ybWF0LCByb3VuZGluZ0Z1bmN0aW9uKSB7XG4gICAgICAgICAgICB2YXIgb3V0cHV0LFxuICAgICAgICAgICAgICAgIGJ5dGVzID0gbnVtZXJhbC5fLmluY2x1ZGVzKGZvcm1hdCwgJ2liJykgPyBiaW5hcnkgOiBkZWNpbWFsLFxuICAgICAgICAgICAgICAgIHN1ZmZpeCA9IG51bWVyYWwuXy5pbmNsdWRlcyhmb3JtYXQsICcgYicpIHx8IG51bWVyYWwuXy5pbmNsdWRlcyhmb3JtYXQsICcgaWInKSA/ICcgJyA6ICcnLFxuICAgICAgICAgICAgICAgIHBvd2VyLFxuICAgICAgICAgICAgICAgIG1pbixcbiAgICAgICAgICAgICAgICBtYXg7XG5cbiAgICAgICAgICAgIC8vIGNoZWNrIGZvciBzcGFjZSBiZWZvcmVcbiAgICAgICAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKC9cXHM/aT9iLywgJycpO1xuXG4gICAgICAgICAgICBmb3IgKHBvd2VyID0gMDsgcG93ZXIgPD0gYnl0ZXMuc3VmZml4ZXMubGVuZ3RoOyBwb3dlcisrKSB7XG4gICAgICAgICAgICAgICAgbWluID0gTWF0aC5wb3coYnl0ZXMuYmFzZSwgcG93ZXIpO1xuICAgICAgICAgICAgICAgIG1heCA9IE1hdGgucG93KGJ5dGVzLmJhc2UsIHBvd2VyICsgMSk7XG5cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IDAgfHwgdmFsdWUgPj0gbWluICYmIHZhbHVlIDwgbWF4KSB7XG4gICAgICAgICAgICAgICAgICAgIHN1ZmZpeCArPSBieXRlcy5zdWZmaXhlc1twb3dlcl07XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG1pbiA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgLyBtaW47XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG91dHB1dCA9IG51bWVyYWwuXy5udW1iZXJUb0Zvcm1hdCh2YWx1ZSwgZm9ybWF0LCByb3VuZGluZ0Z1bmN0aW9uKTtcblxuICAgICAgICAgICAgcmV0dXJuIG91dHB1dCArIHN1ZmZpeDtcbiAgICAgICAgfSxcbiAgICAgICAgdW5mb3JtYXQ6IGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gbnVtZXJhbC5fLnN0cmluZ1RvTnVtYmVyKHN0cmluZyksXG4gICAgICAgICAgICAgICAgcG93ZXIsXG4gICAgICAgICAgICAgICAgYnl0ZXNNdWx0aXBsaWVyO1xuXG4gICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHBvd2VyID0gZGVjaW1hbC5zdWZmaXhlcy5sZW5ndGggLSAxOyBwb3dlciA+PSAwOyBwb3dlci0tKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChudW1lcmFsLl8uaW5jbHVkZXMoc3RyaW5nLCBkZWNpbWFsLnN1ZmZpeGVzW3Bvd2VyXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ5dGVzTXVsdGlwbGllciA9IE1hdGgucG93KGRlY2ltYWwuYmFzZSwgcG93ZXIpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChudW1lcmFsLl8uaW5jbHVkZXMoc3RyaW5nLCBiaW5hcnkuc3VmZml4ZXNbcG93ZXJdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnl0ZXNNdWx0aXBsaWVyID0gTWF0aC5wb3coYmluYXJ5LmJhc2UsIHBvd2VyKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YWx1ZSAqPSAoYnl0ZXNNdWx0aXBsaWVyIHx8IDEpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9KTtcbn0pKCk7XG5cblxuKGZ1bmN0aW9uKCkge1xuICAgICAgICBudW1lcmFsLnJlZ2lzdGVyKCdmb3JtYXQnLCAnY3VycmVuY3knLCB7XG4gICAgICAgIHJlZ2V4cHM6IHtcbiAgICAgICAgICAgIGZvcm1hdDogLyhcXCQpL1xuICAgICAgICB9LFxuICAgICAgICBmb3JtYXQ6IGZ1bmN0aW9uKHZhbHVlLCBmb3JtYXQsIHJvdW5kaW5nRnVuY3Rpb24pIHtcbiAgICAgICAgICAgIHZhciBsb2NhbGUgPSBudW1lcmFsLmxvY2FsZXNbbnVtZXJhbC5vcHRpb25zLmN1cnJlbnRMb2NhbGVdLFxuICAgICAgICAgICAgICAgIHN5bWJvbHMgPSB7XG4gICAgICAgICAgICAgICAgICAgIGJlZm9yZTogZm9ybWF0Lm1hdGNoKC9eKFtcXCt8XFwtfFxcKHxcXHN8XFwkXSopLylbMF0sXG4gICAgICAgICAgICAgICAgICAgIGFmdGVyOiBmb3JtYXQubWF0Y2goLyhbXFwrfFxcLXxcXCl8XFxzfFxcJF0qKSQvKVswXVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgb3V0cHV0LFxuICAgICAgICAgICAgICAgIHN5bWJvbCxcbiAgICAgICAgICAgICAgICBpO1xuXG4gICAgICAgICAgICAvLyBzdHJpcCBmb3JtYXQgb2Ygc3BhY2VzIGFuZCAkXG4gICAgICAgICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZSgvXFxzP1xcJFxccz8vLCAnJyk7XG5cbiAgICAgICAgICAgIC8vIGZvcm1hdCB0aGUgbnVtYmVyXG4gICAgICAgICAgICBvdXRwdXQgPSBudW1lcmFsLl8ubnVtYmVyVG9Gb3JtYXQodmFsdWUsIGZvcm1hdCwgcm91bmRpbmdGdW5jdGlvbik7XG5cbiAgICAgICAgICAgIC8vIHVwZGF0ZSB0aGUgYmVmb3JlIGFuZCBhZnRlciBiYXNlZCBvbiB2YWx1ZVxuICAgICAgICAgICAgaWYgKHZhbHVlID49IDApIHtcbiAgICAgICAgICAgICAgICBzeW1ib2xzLmJlZm9yZSA9IHN5bWJvbHMuYmVmb3JlLnJlcGxhY2UoL1tcXC1cXChdLywgJycpO1xuICAgICAgICAgICAgICAgIHN5bWJvbHMuYWZ0ZXIgPSBzeW1ib2xzLmFmdGVyLnJlcGxhY2UoL1tcXC1cXCldLywgJycpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSA8IDAgJiYgKCFudW1lcmFsLl8uaW5jbHVkZXMoc3ltYm9scy5iZWZvcmUsICctJykgJiYgIW51bWVyYWwuXy5pbmNsdWRlcyhzeW1ib2xzLmJlZm9yZSwgJygnKSkpIHtcbiAgICAgICAgICAgICAgICBzeW1ib2xzLmJlZm9yZSA9ICctJyArIHN5bWJvbHMuYmVmb3JlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBsb29wIHRocm91Z2ggZWFjaCBiZWZvcmUgc3ltYm9sXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc3ltYm9scy5iZWZvcmUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBzeW1ib2wgPSBzeW1ib2xzLmJlZm9yZVtpXTtcblxuICAgICAgICAgICAgICAgIHN3aXRjaCAoc3ltYm9sKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJyQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0ID0gbnVtZXJhbC5fLmluc2VydChvdXRwdXQsIGxvY2FsZS5jdXJyZW5jeS5zeW1ib2wsIGkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJyAnOlxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0ID0gbnVtZXJhbC5fLmluc2VydChvdXRwdXQsICcgJywgaSArIGxvY2FsZS5jdXJyZW5jeS5zeW1ib2wubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGxvb3AgdGhyb3VnaCBlYWNoIGFmdGVyIHN5bWJvbFxuICAgICAgICAgICAgZm9yIChpID0gc3ltYm9scy5hZnRlci5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgIHN5bWJvbCA9IHN5bWJvbHMuYWZ0ZXJbaV07XG5cbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHN5bWJvbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICckJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dCA9IGkgPT09IHN5bWJvbHMuYWZ0ZXIubGVuZ3RoIC0gMSA/IG91dHB1dCArIGxvY2FsZS5jdXJyZW5jeS5zeW1ib2wgOiBudW1lcmFsLl8uaW5zZXJ0KG91dHB1dCwgbG9jYWxlLmN1cnJlbmN5LnN5bWJvbCwgLShzeW1ib2xzLmFmdGVyLmxlbmd0aCAtICgxICsgaSkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICcgJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dCA9IGkgPT09IHN5bWJvbHMuYWZ0ZXIubGVuZ3RoIC0gMSA/IG91dHB1dCArICcgJyA6IG51bWVyYWwuXy5pbnNlcnQob3V0cHV0LCAnICcsIC0oc3ltYm9scy5hZnRlci5sZW5ndGggLSAoMSArIGkpICsgbG9jYWxlLmN1cnJlbmN5LnN5bWJvbC5sZW5ndGggLSAxKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICAgICAgfVxuICAgIH0pO1xufSkoKTtcblxuXG4oZnVuY3Rpb24oKSB7XG4gICAgICAgIG51bWVyYWwucmVnaXN0ZXIoJ2Zvcm1hdCcsICdleHBvbmVudGlhbCcsIHtcbiAgICAgICAgcmVnZXhwczoge1xuICAgICAgICAgICAgZm9ybWF0OiAvKGVcXCt8ZS0pLyxcbiAgICAgICAgICAgIHVuZm9ybWF0OiAvKGVcXCt8ZS0pL1xuICAgICAgICB9LFxuICAgICAgICBmb3JtYXQ6IGZ1bmN0aW9uKHZhbHVlLCBmb3JtYXQsIHJvdW5kaW5nRnVuY3Rpb24pIHtcbiAgICAgICAgICAgIHZhciBvdXRwdXQsXG4gICAgICAgICAgICAgICAgZXhwb25lbnRpYWwgPSB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmICFudW1lcmFsLl8uaXNOYU4odmFsdWUpID8gdmFsdWUudG9FeHBvbmVudGlhbCgpIDogJzBlKzAnLFxuICAgICAgICAgICAgICAgIHBhcnRzID0gZXhwb25lbnRpYWwuc3BsaXQoJ2UnKTtcblxuICAgICAgICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoL2VbXFwrfFxcLV17MX0wLywgJycpO1xuXG4gICAgICAgICAgICBvdXRwdXQgPSBudW1lcmFsLl8ubnVtYmVyVG9Gb3JtYXQoTnVtYmVyKHBhcnRzWzBdKSwgZm9ybWF0LCByb3VuZGluZ0Z1bmN0aW9uKTtcblxuICAgICAgICAgICAgcmV0dXJuIG91dHB1dCArICdlJyArIHBhcnRzWzFdO1xuICAgICAgICB9LFxuICAgICAgICB1bmZvcm1hdDogZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgICAgICAgICB2YXIgcGFydHMgPSBudW1lcmFsLl8uaW5jbHVkZXMoc3RyaW5nLCAnZSsnKSA/IHN0cmluZy5zcGxpdCgnZSsnKSA6IHN0cmluZy5zcGxpdCgnZS0nKSxcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IE51bWJlcihwYXJ0c1swXSksXG4gICAgICAgICAgICAgICAgcG93ZXIgPSBOdW1iZXIocGFydHNbMV0pO1xuXG4gICAgICAgICAgICBwb3dlciA9IG51bWVyYWwuXy5pbmNsdWRlcyhzdHJpbmcsICdlLScpID8gcG93ZXIgKj0gLTEgOiBwb3dlcjtcblxuICAgICAgICAgICAgZnVuY3Rpb24gY2JhY2soYWNjdW0sIGN1cnIsIGN1cnJJLCBPKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvcnJGYWN0b3IgPSBudW1lcmFsLl8uY29ycmVjdGlvbkZhY3RvcihhY2N1bSwgY3VyciksXG4gICAgICAgICAgICAgICAgICAgIG51bSA9IChhY2N1bSAqIGNvcnJGYWN0b3IpICogKGN1cnIgKiBjb3JyRmFjdG9yKSAvIChjb3JyRmFjdG9yICogY29yckZhY3Rvcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG51bWVyYWwuXy5yZWR1Y2UoW3ZhbHVlLCBNYXRoLnBvdygxMCwgcG93ZXIpXSwgY2JhY2ssIDEpO1xuICAgICAgICB9XG4gICAgfSk7XG59KSgpO1xuXG5cbihmdW5jdGlvbigpIHtcbiAgICAgICAgbnVtZXJhbC5yZWdpc3RlcignZm9ybWF0JywgJ29yZGluYWwnLCB7XG4gICAgICAgIHJlZ2V4cHM6IHtcbiAgICAgICAgICAgIGZvcm1hdDogLyhvKS9cbiAgICAgICAgfSxcbiAgICAgICAgZm9ybWF0OiBmdW5jdGlvbih2YWx1ZSwgZm9ybWF0LCByb3VuZGluZ0Z1bmN0aW9uKSB7XG4gICAgICAgICAgICB2YXIgbG9jYWxlID0gbnVtZXJhbC5sb2NhbGVzW251bWVyYWwub3B0aW9ucy5jdXJyZW50TG9jYWxlXSxcbiAgICAgICAgICAgICAgICBvdXRwdXQsXG4gICAgICAgICAgICAgICAgb3JkaW5hbCA9IG51bWVyYWwuXy5pbmNsdWRlcyhmb3JtYXQsICcgbycpID8gJyAnIDogJyc7XG5cbiAgICAgICAgICAgIC8vIGNoZWNrIGZvciBzcGFjZSBiZWZvcmVcbiAgICAgICAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKC9cXHM/by8sICcnKTtcblxuICAgICAgICAgICAgb3JkaW5hbCArPSBsb2NhbGUub3JkaW5hbCh2YWx1ZSk7XG5cbiAgICAgICAgICAgIG91dHB1dCA9IG51bWVyYWwuXy5udW1iZXJUb0Zvcm1hdCh2YWx1ZSwgZm9ybWF0LCByb3VuZGluZ0Z1bmN0aW9uKTtcblxuICAgICAgICAgICAgcmV0dXJuIG91dHB1dCArIG9yZGluYWw7XG4gICAgICAgIH1cbiAgICB9KTtcbn0pKCk7XG5cblxuKGZ1bmN0aW9uKCkge1xuICAgICAgICBudW1lcmFsLnJlZ2lzdGVyKCdmb3JtYXQnLCAncGVyY2VudGFnZScsIHtcbiAgICAgICAgcmVnZXhwczoge1xuICAgICAgICAgICAgZm9ybWF0OiAvKCUpLyxcbiAgICAgICAgICAgIHVuZm9ybWF0OiAvKCUpL1xuICAgICAgICB9LFxuICAgICAgICBmb3JtYXQ6IGZ1bmN0aW9uKHZhbHVlLCBmb3JtYXQsIHJvdW5kaW5nRnVuY3Rpb24pIHtcbiAgICAgICAgICAgIHZhciBzcGFjZSA9IG51bWVyYWwuXy5pbmNsdWRlcyhmb3JtYXQsICcgJScpID8gJyAnIDogJycsXG4gICAgICAgICAgICAgICAgb3V0cHV0O1xuXG4gICAgICAgICAgICBpZiAobnVtZXJhbC5vcHRpb25zLnNjYWxlUGVyY2VudEJ5MTAwKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSAqIDEwMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gY2hlY2sgZm9yIHNwYWNlIGJlZm9yZSAlXG4gICAgICAgICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZSgvXFxzP1xcJS8sICcnKTtcblxuICAgICAgICAgICAgb3V0cHV0ID0gbnVtZXJhbC5fLm51bWJlclRvRm9ybWF0KHZhbHVlLCBmb3JtYXQsIHJvdW5kaW5nRnVuY3Rpb24pO1xuXG4gICAgICAgICAgICBpZiAobnVtZXJhbC5fLmluY2x1ZGVzKG91dHB1dCwgJyknKSkge1xuICAgICAgICAgICAgICAgIG91dHB1dCA9IG91dHB1dC5zcGxpdCgnJyk7XG5cbiAgICAgICAgICAgICAgICBvdXRwdXQuc3BsaWNlKC0xLCAwLCBzcGFjZSArICclJyk7XG5cbiAgICAgICAgICAgICAgICBvdXRwdXQgPSBvdXRwdXQuam9pbignJyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG91dHB1dCA9IG91dHB1dCArIHNwYWNlICsgJyUnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgICAgICB9LFxuICAgICAgICB1bmZvcm1hdDogZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgICAgICAgICB2YXIgbnVtYmVyID0gbnVtZXJhbC5fLnN0cmluZ1RvTnVtYmVyKHN0cmluZyk7XG4gICAgICAgICAgICBpZiAobnVtZXJhbC5vcHRpb25zLnNjYWxlUGVyY2VudEJ5MTAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bWJlciAqIDAuMDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVtYmVyO1xuICAgICAgICB9XG4gICAgfSk7XG59KSgpO1xuXG5cbihmdW5jdGlvbigpIHtcbiAgICAgICAgbnVtZXJhbC5yZWdpc3RlcignZm9ybWF0JywgJ3RpbWUnLCB7XG4gICAgICAgIHJlZ2V4cHM6IHtcbiAgICAgICAgICAgIGZvcm1hdDogLyg6KS8sXG4gICAgICAgICAgICB1bmZvcm1hdDogLyg6KS9cbiAgICAgICAgfSxcbiAgICAgICAgZm9ybWF0OiBmdW5jdGlvbih2YWx1ZSwgZm9ybWF0LCByb3VuZGluZ0Z1bmN0aW9uKSB7XG4gICAgICAgICAgICB2YXIgaG91cnMgPSBNYXRoLmZsb29yKHZhbHVlIC8gNjAgLyA2MCksXG4gICAgICAgICAgICAgICAgbWludXRlcyA9IE1hdGguZmxvb3IoKHZhbHVlIC0gKGhvdXJzICogNjAgKiA2MCkpIC8gNjApLFxuICAgICAgICAgICAgICAgIHNlY29uZHMgPSBNYXRoLnJvdW5kKHZhbHVlIC0gKGhvdXJzICogNjAgKiA2MCkgLSAobWludXRlcyAqIDYwKSk7XG5cbiAgICAgICAgICAgIHJldHVybiBob3VycyArICc6JyArIChtaW51dGVzIDwgMTAgPyAnMCcgKyBtaW51dGVzIDogbWludXRlcykgKyAnOicgKyAoc2Vjb25kcyA8IDEwID8gJzAnICsgc2Vjb25kcyA6IHNlY29uZHMpO1xuICAgICAgICB9LFxuICAgICAgICB1bmZvcm1hdDogZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgICAgICAgICB2YXIgdGltZUFycmF5ID0gc3RyaW5nLnNwbGl0KCc6JyksXG4gICAgICAgICAgICAgICAgc2Vjb25kcyA9IDA7XG5cbiAgICAgICAgICAgIC8vIHR1cm4gaG91cnMgYW5kIG1pbnV0ZXMgaW50byBzZWNvbmRzIGFuZCBhZGQgdGhlbSBhbGwgdXBcbiAgICAgICAgICAgIGlmICh0aW1lQXJyYXkubGVuZ3RoID09PSAzKSB7XG4gICAgICAgICAgICAgICAgLy8gaG91cnNcbiAgICAgICAgICAgICAgICBzZWNvbmRzID0gc2Vjb25kcyArIChOdW1iZXIodGltZUFycmF5WzBdKSAqIDYwICogNjApO1xuICAgICAgICAgICAgICAgIC8vIG1pbnV0ZXNcbiAgICAgICAgICAgICAgICBzZWNvbmRzID0gc2Vjb25kcyArIChOdW1iZXIodGltZUFycmF5WzFdKSAqIDYwKTtcbiAgICAgICAgICAgICAgICAvLyBzZWNvbmRzXG4gICAgICAgICAgICAgICAgc2Vjb25kcyA9IHNlY29uZHMgKyBOdW1iZXIodGltZUFycmF5WzJdKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGltZUFycmF5Lmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgICAgIC8vIG1pbnV0ZXNcbiAgICAgICAgICAgICAgICBzZWNvbmRzID0gc2Vjb25kcyArIChOdW1iZXIodGltZUFycmF5WzBdKSAqIDYwKTtcbiAgICAgICAgICAgICAgICAvLyBzZWNvbmRzXG4gICAgICAgICAgICAgICAgc2Vjb25kcyA9IHNlY29uZHMgKyBOdW1iZXIodGltZUFycmF5WzFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBOdW1iZXIoc2Vjb25kcyk7XG4gICAgICAgIH1cbiAgICB9KTtcbn0pKCk7XG5cbnJldHVybiBudW1lcmFsO1xufSkpO1xuIl0sIm5hbWVzIjpbImdsb2JhbCIsImZhY3RvcnkiLCJkZWZpbmUiLCJhbWQiLCJtb2R1bGUiLCJleHBvcnRzIiwibnVtZXJhbCIsIl8iLCJWRVJTSU9OIiwiZm9ybWF0cyIsImxvY2FsZXMiLCJkZWZhdWx0cyIsImN1cnJlbnRMb2NhbGUiLCJ6ZXJvRm9ybWF0IiwibnVsbEZvcm1hdCIsImRlZmF1bHRGb3JtYXQiLCJzY2FsZVBlcmNlbnRCeTEwMCIsIm9wdGlvbnMiLCJOdW1lcmFsIiwiaW5wdXQiLCJudW1iZXIiLCJfaW5wdXQiLCJfdmFsdWUiLCJ2YWx1ZSIsImtpbmQiLCJ1bmZvcm1hdEZ1bmN0aW9uIiwicmVnZXhwIiwiaXNOdW1lcmFsIiwiaXNOYU4iLCJyZXBsYWNlIiwibGVuZ3RoIiwicmVnZXhwcyIsInVuZm9ybWF0IiwibWF0Y2giLCJzdHJpbmdUb051bWJlciIsIk51bWJlciIsInZlcnNpb24iLCJvYmoiLCJudW1iZXJUb0Zvcm1hdCIsImZvcm1hdCIsInJvdW5kaW5nRnVuY3Rpb24iLCJsb2NhbGUiLCJuZWdQIiwib3B0RGVjIiwibGVhZGluZ0NvdW50IiwiYWJiciIsInRyaWxsaW9uIiwiYmlsbGlvbiIsIm1pbGxpb24iLCJ0aG91c2FuZCIsImRlY2ltYWwiLCJuZWciLCJhYmJyRm9yY2UiLCJhYnMiLCJtaW4iLCJtYXgiLCJwb3dlciIsImludCIsInByZWNpc2lvbiIsInNpZ25lZCIsInRob3VzYW5kcyIsIm91dHB1dCIsIk1hdGgiLCJpbmNsdWRlcyIsImluZGV4T2YiLCJSZWdFeHAiLCJhYmJyZXZpYXRpb25zIiwidG9TdHJpbmciLCJzcGxpdCIsInRvRml4ZWQiLCJkZWxpbWl0ZXJzIiwic2xpY2UiLCJTdHJpbmciLCJpIiwic3RyaW5nIiwic3RyaW5nT3JpZ2luYWwiLCJhYmJyZXZpYXRpb24iLCJjdXJyZW5jeSIsInN5bWJvbCIsInBvdyIsInNlYXJjaCIsImluc2VydCIsInN1YlN0cmluZyIsInN0YXJ0IiwicmVkdWNlIiwiYXJyYXkiLCJjYWxsYmFjayIsIlR5cGVFcnJvciIsInQiLCJPYmplY3QiLCJsZW4iLCJrIiwiYXJndW1lbnRzIiwibXVsdGlwbGllciIsIngiLCJwYXJ0cyIsImNvcnJlY3Rpb25GYWN0b3IiLCJhcmdzIiwiQXJyYXkiLCJwcm90b3R5cGUiLCJjYWxsIiwiYWNjdW0iLCJuZXh0IiwibW4iLCJtYXhEZWNpbWFscyIsIm9wdGlvbmFscyIsInNwbGl0VmFsdWUiLCJtaW5EZWNpbWFscyIsImJvdW5kZWRQcmVjaXNpb24iLCJvcHRpb25hbHNSZWdFeHAiLCJrZXkiLCJ0b0xvd2VyQ2FzZSIsImxvY2FsZURhdGEiLCJFcnJvciIsInJlc2V0IiwicHJvcGVydHkiLCJyZWdpc3RlciIsInR5cGUiLCJuYW1lIiwidmFsaWRhdGUiLCJ2YWwiLCJjdWx0dXJlIiwiX2RlY2ltYWxTZXAiLCJfdGhvdXNhbmRTZXAiLCJfY3VyclN5bWJvbCIsIl92YWxBcnJheSIsIl9hYmJyT2JqIiwiX3Rob3VzYW5kUmVnRXgiLCJ0ZW1wIiwiY29uc29sZSIsIndhcm4iLCJ0cmltIiwiZSIsInN1YnN0ciIsImZuIiwiY2xvbmUiLCJpbnB1dFN0cmluZyIsImZvcm1hdEZ1bmN0aW9uIiwicm91bmQiLCJzZXQiLCJhZGQiLCJjb3JyRmFjdG9yIiwiY2JhY2siLCJjdXJyIiwiY3VyckkiLCJPIiwic3VidHJhY3QiLCJtdWx0aXBseSIsImRpdmlkZSIsImRpZmZlcmVuY2UiLCJvcmRpbmFsIiwiYiIsInNwYWNlIiwic3BsaWNlIiwiam9pbiIsImJhc2UiLCJzdWZmaXhlcyIsImJpbmFyeSIsImFsbFN1ZmZpeGVzIiwiY29uY2F0IiwiZmlsdGVyIiwiaXRlbSIsInVuZm9ybWF0UmVnZXgiLCJieXRlcyIsInN1ZmZpeCIsImJ5dGVzTXVsdGlwbGllciIsInN5bWJvbHMiLCJiZWZvcmUiLCJhZnRlciIsImV4cG9uZW50aWFsIiwidG9FeHBvbmVudGlhbCIsIm51bSIsImhvdXJzIiwiZmxvb3IiLCJtaW51dGVzIiwic2Vjb25kcyIsInRpbWVBcnJheSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/numeral/numeral.js\n");

/***/ })

};
;