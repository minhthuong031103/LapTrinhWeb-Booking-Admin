"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/clone";
exports.ids = ["vendor-chunks/clone"];
exports.modules = {

/***/ "(ssr)/./node_modules/clone/clone.js":
/*!*************************************!*\
  !*** ./node_modules/clone/clone.js ***!
  \*************************************/
/***/ ((module) => {

eval("\nvar clone = function() {\n    \"use strict\";\n    function _instanceof(obj, type) {\n        return type != null && obj instanceof type;\n    }\n    var nativeMap;\n    try {\n        nativeMap = Map;\n    } catch (_) {\n        // maybe a reference error because no `Map`. Give it a dummy value that no\n        // value will ever be an instanceof.\n        nativeMap = function() {};\n    }\n    var nativeSet;\n    try {\n        nativeSet = Set;\n    } catch (_) {\n        nativeSet = function() {};\n    }\n    var nativePromise;\n    try {\n        nativePromise = Promise;\n    } catch (_) {\n        nativePromise = function() {};\n    }\n    /**\n * Clones (copies) an Object using deep copying.\n *\n * This function supports circular references by default, but if you are certain\n * there are no circular references in your object, you can save some CPU time\n * by calling clone(obj, false).\n *\n * Caution: if `circular` is false and `parent` contains circular references,\n * your program may enter an infinite loop and crash.\n *\n * @param `parent` - the object to be cloned\n * @param `circular` - set to true if the object to be cloned may contain\n *    circular references. (optional - true by default)\n * @param `depth` - set to a number if the object is only to be cloned to\n *    a particular depth. (optional - defaults to Infinity)\n * @param `prototype` - sets the prototype to be used when cloning an object.\n *    (optional - defaults to parent prototype).\n * @param `includeNonEnumerable` - set to true if the non-enumerable properties\n *    should be cloned as well. Non-enumerable properties on the prototype\n *    chain will be ignored. (optional - false by default)\n*/ function clone(parent, circular, depth, prototype, includeNonEnumerable) {\n        if (typeof circular === \"object\") {\n            depth = circular.depth;\n            prototype = circular.prototype;\n            includeNonEnumerable = circular.includeNonEnumerable;\n            circular = circular.circular;\n        }\n        // maintain two arrays for circular references, where corresponding parents\n        // and children have the same index\n        var allParents = [];\n        var allChildren = [];\n        var useBuffer = typeof Buffer != \"undefined\";\n        if (typeof circular == \"undefined\") circular = true;\n        if (typeof depth == \"undefined\") depth = Infinity;\n        // recurse this function so we don't reset allParents and allChildren\n        function _clone(parent, depth) {\n            // cloning null always returns null\n            if (parent === null) return null;\n            if (depth === 0) return parent;\n            var child;\n            var proto;\n            if (typeof parent != \"object\") {\n                return parent;\n            }\n            if (_instanceof(parent, nativeMap)) {\n                child = new nativeMap();\n            } else if (_instanceof(parent, nativeSet)) {\n                child = new nativeSet();\n            } else if (_instanceof(parent, nativePromise)) {\n                child = new nativePromise(function(resolve, reject) {\n                    parent.then(function(value) {\n                        resolve(_clone(value, depth - 1));\n                    }, function(err) {\n                        reject(_clone(err, depth - 1));\n                    });\n                });\n            } else if (clone.__isArray(parent)) {\n                child = [];\n            } else if (clone.__isRegExp(parent)) {\n                child = new RegExp(parent.source, __getRegExpFlags(parent));\n                if (parent.lastIndex) child.lastIndex = parent.lastIndex;\n            } else if (clone.__isDate(parent)) {\n                child = new Date(parent.getTime());\n            } else if (useBuffer && Buffer.isBuffer(parent)) {\n                if (Buffer.allocUnsafe) {\n                    // Node.js >= 4.5.0\n                    child = Buffer.allocUnsafe(parent.length);\n                } else {\n                    // Older Node.js versions\n                    child = new Buffer(parent.length);\n                }\n                parent.copy(child);\n                return child;\n            } else if (_instanceof(parent, Error)) {\n                child = Object.create(parent);\n            } else {\n                if (typeof prototype == \"undefined\") {\n                    proto = Object.getPrototypeOf(parent);\n                    child = Object.create(proto);\n                } else {\n                    child = Object.create(prototype);\n                    proto = prototype;\n                }\n            }\n            if (circular) {\n                var index = allParents.indexOf(parent);\n                if (index != -1) {\n                    return allChildren[index];\n                }\n                allParents.push(parent);\n                allChildren.push(child);\n            }\n            if (_instanceof(parent, nativeMap)) {\n                parent.forEach(function(value, key) {\n                    var keyChild = _clone(key, depth - 1);\n                    var valueChild = _clone(value, depth - 1);\n                    child.set(keyChild, valueChild);\n                });\n            }\n            if (_instanceof(parent, nativeSet)) {\n                parent.forEach(function(value) {\n                    var entryChild = _clone(value, depth - 1);\n                    child.add(entryChild);\n                });\n            }\n            for(var i in parent){\n                var attrs;\n                if (proto) {\n                    attrs = Object.getOwnPropertyDescriptor(proto, i);\n                }\n                if (attrs && attrs.set == null) {\n                    continue;\n                }\n                child[i] = _clone(parent[i], depth - 1);\n            }\n            if (Object.getOwnPropertySymbols) {\n                var symbols = Object.getOwnPropertySymbols(parent);\n                for(var i = 0; i < symbols.length; i++){\n                    // Don't need to worry about cloning a symbol because it is a primitive,\n                    // like a number or string.\n                    var symbol = symbols[i];\n                    var descriptor = Object.getOwnPropertyDescriptor(parent, symbol);\n                    if (descriptor && !descriptor.enumerable && !includeNonEnumerable) {\n                        continue;\n                    }\n                    child[symbol] = _clone(parent[symbol], depth - 1);\n                    if (!descriptor.enumerable) {\n                        Object.defineProperty(child, symbol, {\n                            enumerable: false\n                        });\n                    }\n                }\n            }\n            if (includeNonEnumerable) {\n                var allPropertyNames = Object.getOwnPropertyNames(parent);\n                for(var i = 0; i < allPropertyNames.length; i++){\n                    var propertyName = allPropertyNames[i];\n                    var descriptor = Object.getOwnPropertyDescriptor(parent, propertyName);\n                    if (descriptor && descriptor.enumerable) {\n                        continue;\n                    }\n                    child[propertyName] = _clone(parent[propertyName], depth - 1);\n                    Object.defineProperty(child, propertyName, {\n                        enumerable: false\n                    });\n                }\n            }\n            return child;\n        }\n        return _clone(parent, depth);\n    }\n    /**\n * Simple flat clone using prototype, accepts only objects, usefull for property\n * override on FLAT configuration object (no nested props).\n *\n * USE WITH CAUTION! This may not behave as you wish if you do not know how this\n * works.\n */ clone.clonePrototype = function clonePrototype(parent) {\n        if (parent === null) return null;\n        var c = function() {};\n        c.prototype = parent;\n        return new c();\n    };\n    // private utility functions\n    function __objToStr(o) {\n        return Object.prototype.toString.call(o);\n    }\n    clone.__objToStr = __objToStr;\n    function __isDate(o) {\n        return typeof o === \"object\" && __objToStr(o) === \"[object Date]\";\n    }\n    clone.__isDate = __isDate;\n    function __isArray(o) {\n        return typeof o === \"object\" && __objToStr(o) === \"[object Array]\";\n    }\n    clone.__isArray = __isArray;\n    function __isRegExp(o) {\n        return typeof o === \"object\" && __objToStr(o) === \"[object RegExp]\";\n    }\n    clone.__isRegExp = __isRegExp;\n    function __getRegExpFlags(re) {\n        var flags = \"\";\n        if (re.global) flags += \"g\";\n        if (re.ignoreCase) flags += \"i\";\n        if (re.multiline) flags += \"m\";\n        return flags;\n    }\n    clone.__getRegExpFlags = __getRegExpFlags;\n    return clone;\n}();\nif ( true && module.exports) {\n    module.exports = clone;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Z0JBQWdCLEdBQUdBO0lBRXpCLE9BQU9qQztBQUNQO0FBRUEsSUFBSSxLQUFrQixJQUFZK0UsT0FBT0MsT0FBTyxFQUFFO0lBQ2hERCxPQUFPQyxPQUFPLEdBQUdoRjtBQUNuQiIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy1lY29tbWVyY2UtdWl0Ly4vbm9kZV9tb2R1bGVzL2Nsb25lL2Nsb25lLmpzPzFkYzkiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGNsb25lID0gKGZ1bmN0aW9uKCkge1xuJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBfaW5zdGFuY2VvZihvYmosIHR5cGUpIHtcbiAgcmV0dXJuIHR5cGUgIT0gbnVsbCAmJiBvYmogaW5zdGFuY2VvZiB0eXBlO1xufVxuXG52YXIgbmF0aXZlTWFwO1xudHJ5IHtcbiAgbmF0aXZlTWFwID0gTWFwO1xufSBjYXRjaChfKSB7XG4gIC8vIG1heWJlIGEgcmVmZXJlbmNlIGVycm9yIGJlY2F1c2Ugbm8gYE1hcGAuIEdpdmUgaXQgYSBkdW1teSB2YWx1ZSB0aGF0IG5vXG4gIC8vIHZhbHVlIHdpbGwgZXZlciBiZSBhbiBpbnN0YW5jZW9mLlxuICBuYXRpdmVNYXAgPSBmdW5jdGlvbigpIHt9O1xufVxuXG52YXIgbmF0aXZlU2V0O1xudHJ5IHtcbiAgbmF0aXZlU2V0ID0gU2V0O1xufSBjYXRjaChfKSB7XG4gIG5hdGl2ZVNldCA9IGZ1bmN0aW9uKCkge307XG59XG5cbnZhciBuYXRpdmVQcm9taXNlO1xudHJ5IHtcbiAgbmF0aXZlUHJvbWlzZSA9IFByb21pc2U7XG59IGNhdGNoKF8pIHtcbiAgbmF0aXZlUHJvbWlzZSA9IGZ1bmN0aW9uKCkge307XG59XG5cbi8qKlxuICogQ2xvbmVzIChjb3BpZXMpIGFuIE9iamVjdCB1c2luZyBkZWVwIGNvcHlpbmcuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBzdXBwb3J0cyBjaXJjdWxhciByZWZlcmVuY2VzIGJ5IGRlZmF1bHQsIGJ1dCBpZiB5b3UgYXJlIGNlcnRhaW5cbiAqIHRoZXJlIGFyZSBubyBjaXJjdWxhciByZWZlcmVuY2VzIGluIHlvdXIgb2JqZWN0LCB5b3UgY2FuIHNhdmUgc29tZSBDUFUgdGltZVxuICogYnkgY2FsbGluZyBjbG9uZShvYmosIGZhbHNlKS5cbiAqXG4gKiBDYXV0aW9uOiBpZiBgY2lyY3VsYXJgIGlzIGZhbHNlIGFuZCBgcGFyZW50YCBjb250YWlucyBjaXJjdWxhciByZWZlcmVuY2VzLFxuICogeW91ciBwcm9ncmFtIG1heSBlbnRlciBhbiBpbmZpbml0ZSBsb29wIGFuZCBjcmFzaC5cbiAqXG4gKiBAcGFyYW0gYHBhcmVudGAgLSB0aGUgb2JqZWN0IHRvIGJlIGNsb25lZFxuICogQHBhcmFtIGBjaXJjdWxhcmAgLSBzZXQgdG8gdHJ1ZSBpZiB0aGUgb2JqZWN0IHRvIGJlIGNsb25lZCBtYXkgY29udGFpblxuICogICAgY2lyY3VsYXIgcmVmZXJlbmNlcy4gKG9wdGlvbmFsIC0gdHJ1ZSBieSBkZWZhdWx0KVxuICogQHBhcmFtIGBkZXB0aGAgLSBzZXQgdG8gYSBudW1iZXIgaWYgdGhlIG9iamVjdCBpcyBvbmx5IHRvIGJlIGNsb25lZCB0b1xuICogICAgYSBwYXJ0aWN1bGFyIGRlcHRoLiAob3B0aW9uYWwgLSBkZWZhdWx0cyB0byBJbmZpbml0eSlcbiAqIEBwYXJhbSBgcHJvdG90eXBlYCAtIHNldHMgdGhlIHByb3RvdHlwZSB0byBiZSB1c2VkIHdoZW4gY2xvbmluZyBhbiBvYmplY3QuXG4gKiAgICAob3B0aW9uYWwgLSBkZWZhdWx0cyB0byBwYXJlbnQgcHJvdG90eXBlKS5cbiAqIEBwYXJhbSBgaW5jbHVkZU5vbkVudW1lcmFibGVgIC0gc2V0IHRvIHRydWUgaWYgdGhlIG5vbi1lbnVtZXJhYmxlIHByb3BlcnRpZXNcbiAqICAgIHNob3VsZCBiZSBjbG9uZWQgYXMgd2VsbC4gTm9uLWVudW1lcmFibGUgcHJvcGVydGllcyBvbiB0aGUgcHJvdG90eXBlXG4gKiAgICBjaGFpbiB3aWxsIGJlIGlnbm9yZWQuIChvcHRpb25hbCAtIGZhbHNlIGJ5IGRlZmF1bHQpXG4qL1xuZnVuY3Rpb24gY2xvbmUocGFyZW50LCBjaXJjdWxhciwgZGVwdGgsIHByb3RvdHlwZSwgaW5jbHVkZU5vbkVudW1lcmFibGUpIHtcbiAgaWYgKHR5cGVvZiBjaXJjdWxhciA9PT0gJ29iamVjdCcpIHtcbiAgICBkZXB0aCA9IGNpcmN1bGFyLmRlcHRoO1xuICAgIHByb3RvdHlwZSA9IGNpcmN1bGFyLnByb3RvdHlwZTtcbiAgICBpbmNsdWRlTm9uRW51bWVyYWJsZSA9IGNpcmN1bGFyLmluY2x1ZGVOb25FbnVtZXJhYmxlO1xuICAgIGNpcmN1bGFyID0gY2lyY3VsYXIuY2lyY3VsYXI7XG4gIH1cbiAgLy8gbWFpbnRhaW4gdHdvIGFycmF5cyBmb3IgY2lyY3VsYXIgcmVmZXJlbmNlcywgd2hlcmUgY29ycmVzcG9uZGluZyBwYXJlbnRzXG4gIC8vIGFuZCBjaGlsZHJlbiBoYXZlIHRoZSBzYW1lIGluZGV4XG4gIHZhciBhbGxQYXJlbnRzID0gW107XG4gIHZhciBhbGxDaGlsZHJlbiA9IFtdO1xuXG4gIHZhciB1c2VCdWZmZXIgPSB0eXBlb2YgQnVmZmVyICE9ICd1bmRlZmluZWQnO1xuXG4gIGlmICh0eXBlb2YgY2lyY3VsYXIgPT0gJ3VuZGVmaW5lZCcpXG4gICAgY2lyY3VsYXIgPSB0cnVlO1xuXG4gIGlmICh0eXBlb2YgZGVwdGggPT0gJ3VuZGVmaW5lZCcpXG4gICAgZGVwdGggPSBJbmZpbml0eTtcblxuICAvLyByZWN1cnNlIHRoaXMgZnVuY3Rpb24gc28gd2UgZG9uJ3QgcmVzZXQgYWxsUGFyZW50cyBhbmQgYWxsQ2hpbGRyZW5cbiAgZnVuY3Rpb24gX2Nsb25lKHBhcmVudCwgZGVwdGgpIHtcbiAgICAvLyBjbG9uaW5nIG51bGwgYWx3YXlzIHJldHVybnMgbnVsbFxuICAgIGlmIChwYXJlbnQgPT09IG51bGwpXG4gICAgICByZXR1cm4gbnVsbDtcblxuICAgIGlmIChkZXB0aCA9PT0gMClcbiAgICAgIHJldHVybiBwYXJlbnQ7XG5cbiAgICB2YXIgY2hpbGQ7XG4gICAgdmFyIHByb3RvO1xuICAgIGlmICh0eXBlb2YgcGFyZW50ICE9ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm4gcGFyZW50O1xuICAgIH1cblxuICAgIGlmIChfaW5zdGFuY2VvZihwYXJlbnQsIG5hdGl2ZU1hcCkpIHtcbiAgICAgIGNoaWxkID0gbmV3IG5hdGl2ZU1hcCgpO1xuICAgIH0gZWxzZSBpZiAoX2luc3RhbmNlb2YocGFyZW50LCBuYXRpdmVTZXQpKSB7XG4gICAgICBjaGlsZCA9IG5ldyBuYXRpdmVTZXQoKTtcbiAgICB9IGVsc2UgaWYgKF9pbnN0YW5jZW9mKHBhcmVudCwgbmF0aXZlUHJvbWlzZSkpIHtcbiAgICAgIGNoaWxkID0gbmV3IG5hdGl2ZVByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBwYXJlbnQudGhlbihmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgIHJlc29sdmUoX2Nsb25lKHZhbHVlLCBkZXB0aCAtIDEpKTtcbiAgICAgICAgfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgcmVqZWN0KF9jbG9uZShlcnIsIGRlcHRoIC0gMSkpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoY2xvbmUuX19pc0FycmF5KHBhcmVudCkpIHtcbiAgICAgIGNoaWxkID0gW107XG4gICAgfSBlbHNlIGlmIChjbG9uZS5fX2lzUmVnRXhwKHBhcmVudCkpIHtcbiAgICAgIGNoaWxkID0gbmV3IFJlZ0V4cChwYXJlbnQuc291cmNlLCBfX2dldFJlZ0V4cEZsYWdzKHBhcmVudCkpO1xuICAgICAgaWYgKHBhcmVudC5sYXN0SW5kZXgpIGNoaWxkLmxhc3RJbmRleCA9IHBhcmVudC5sYXN0SW5kZXg7XG4gICAgfSBlbHNlIGlmIChjbG9uZS5fX2lzRGF0ZShwYXJlbnQpKSB7XG4gICAgICBjaGlsZCA9IG5ldyBEYXRlKHBhcmVudC5nZXRUaW1lKCkpO1xuICAgIH0gZWxzZSBpZiAodXNlQnVmZmVyICYmIEJ1ZmZlci5pc0J1ZmZlcihwYXJlbnQpKSB7XG4gICAgICBpZiAoQnVmZmVyLmFsbG9jVW5zYWZlKSB7XG4gICAgICAgIC8vIE5vZGUuanMgPj0gNC41LjBcbiAgICAgICAgY2hpbGQgPSBCdWZmZXIuYWxsb2NVbnNhZmUocGFyZW50Lmxlbmd0aCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBPbGRlciBOb2RlLmpzIHZlcnNpb25zXG4gICAgICAgIGNoaWxkID0gbmV3IEJ1ZmZlcihwYXJlbnQubGVuZ3RoKTtcbiAgICAgIH1cbiAgICAgIHBhcmVudC5jb3B5KGNoaWxkKTtcbiAgICAgIHJldHVybiBjaGlsZDtcbiAgICB9IGVsc2UgaWYgKF9pbnN0YW5jZW9mKHBhcmVudCwgRXJyb3IpKSB7XG4gICAgICBjaGlsZCA9IE9iamVjdC5jcmVhdGUocGFyZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHR5cGVvZiBwcm90b3R5cGUgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YocGFyZW50KTtcbiAgICAgICAgY2hpbGQgPSBPYmplY3QuY3JlYXRlKHByb3RvKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBjaGlsZCA9IE9iamVjdC5jcmVhdGUocHJvdG90eXBlKTtcbiAgICAgICAgcHJvdG8gPSBwcm90b3R5cGU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNpcmN1bGFyKSB7XG4gICAgICB2YXIgaW5kZXggPSBhbGxQYXJlbnRzLmluZGV4T2YocGFyZW50KTtcblxuICAgICAgaWYgKGluZGV4ICE9IC0xKSB7XG4gICAgICAgIHJldHVybiBhbGxDaGlsZHJlbltpbmRleF07XG4gICAgICB9XG4gICAgICBhbGxQYXJlbnRzLnB1c2gocGFyZW50KTtcbiAgICAgIGFsbENoaWxkcmVuLnB1c2goY2hpbGQpO1xuICAgIH1cblxuICAgIGlmIChfaW5zdGFuY2VvZihwYXJlbnQsIG5hdGl2ZU1hcCkpIHtcbiAgICAgIHBhcmVudC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgdmFyIGtleUNoaWxkID0gX2Nsb25lKGtleSwgZGVwdGggLSAxKTtcbiAgICAgICAgdmFyIHZhbHVlQ2hpbGQgPSBfY2xvbmUodmFsdWUsIGRlcHRoIC0gMSk7XG4gICAgICAgIGNoaWxkLnNldChrZXlDaGlsZCwgdmFsdWVDaGlsZCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKF9pbnN0YW5jZW9mKHBhcmVudCwgbmF0aXZlU2V0KSkge1xuICAgICAgcGFyZW50LmZvckVhY2goZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgdmFyIGVudHJ5Q2hpbGQgPSBfY2xvbmUodmFsdWUsIGRlcHRoIC0gMSk7XG4gICAgICAgIGNoaWxkLmFkZChlbnRyeUNoaWxkKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgaW4gcGFyZW50KSB7XG4gICAgICB2YXIgYXR0cnM7XG4gICAgICBpZiAocHJvdG8pIHtcbiAgICAgICAgYXR0cnMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHByb3RvLCBpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGF0dHJzICYmIGF0dHJzLnNldCA9PSBudWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY2hpbGRbaV0gPSBfY2xvbmUocGFyZW50W2ldLCBkZXB0aCAtIDEpO1xuICAgIH1cblxuICAgIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgICB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocGFyZW50KTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3ltYm9scy5sZW5ndGg7IGkrKykge1xuICAgICAgICAvLyBEb24ndCBuZWVkIHRvIHdvcnJ5IGFib3V0IGNsb25pbmcgYSBzeW1ib2wgYmVjYXVzZSBpdCBpcyBhIHByaW1pdGl2ZSxcbiAgICAgICAgLy8gbGlrZSBhIG51bWJlciBvciBzdHJpbmcuXG4gICAgICAgIHZhciBzeW1ib2wgPSBzeW1ib2xzW2ldO1xuICAgICAgICB2YXIgZGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocGFyZW50LCBzeW1ib2wpO1xuICAgICAgICBpZiAoZGVzY3JpcHRvciAmJiAhZGVzY3JpcHRvci5lbnVtZXJhYmxlICYmICFpbmNsdWRlTm9uRW51bWVyYWJsZSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNoaWxkW3N5bWJvbF0gPSBfY2xvbmUocGFyZW50W3N5bWJvbF0sIGRlcHRoIC0gMSk7XG4gICAgICAgIGlmICghZGVzY3JpcHRvci5lbnVtZXJhYmxlKSB7XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNoaWxkLCBzeW1ib2wsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaW5jbHVkZU5vbkVudW1lcmFibGUpIHtcbiAgICAgIHZhciBhbGxQcm9wZXJ0eU5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMocGFyZW50KTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWxsUHJvcGVydHlOYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcHJvcGVydHlOYW1lID0gYWxsUHJvcGVydHlOYW1lc1tpXTtcbiAgICAgICAgdmFyIGRlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHBhcmVudCwgcHJvcGVydHlOYW1lKTtcbiAgICAgICAgaWYgKGRlc2NyaXB0b3IgJiYgZGVzY3JpcHRvci5lbnVtZXJhYmxlKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY2hpbGRbcHJvcGVydHlOYW1lXSA9IF9jbG9uZShwYXJlbnRbcHJvcGVydHlOYW1lXSwgZGVwdGggLSAxKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNoaWxkLCBwcm9wZXJ0eU5hbWUsIHtcbiAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY2hpbGQ7XG4gIH1cblxuICByZXR1cm4gX2Nsb25lKHBhcmVudCwgZGVwdGgpO1xufVxuXG4vKipcbiAqIFNpbXBsZSBmbGF0IGNsb25lIHVzaW5nIHByb3RvdHlwZSwgYWNjZXB0cyBvbmx5IG9iamVjdHMsIHVzZWZ1bGwgZm9yIHByb3BlcnR5XG4gKiBvdmVycmlkZSBvbiBGTEFUIGNvbmZpZ3VyYXRpb24gb2JqZWN0IChubyBuZXN0ZWQgcHJvcHMpLlxuICpcbiAqIFVTRSBXSVRIIENBVVRJT04hIFRoaXMgbWF5IG5vdCBiZWhhdmUgYXMgeW91IHdpc2ggaWYgeW91IGRvIG5vdCBrbm93IGhvdyB0aGlzXG4gKiB3b3Jrcy5cbiAqL1xuY2xvbmUuY2xvbmVQcm90b3R5cGUgPSBmdW5jdGlvbiBjbG9uZVByb3RvdHlwZShwYXJlbnQpIHtcbiAgaWYgKHBhcmVudCA9PT0gbnVsbClcbiAgICByZXR1cm4gbnVsbDtcblxuICB2YXIgYyA9IGZ1bmN0aW9uICgpIHt9O1xuICBjLnByb3RvdHlwZSA9IHBhcmVudDtcbiAgcmV0dXJuIG5ldyBjKCk7XG59O1xuXG4vLyBwcml2YXRlIHV0aWxpdHkgZnVuY3Rpb25zXG5cbmZ1bmN0aW9uIF9fb2JqVG9TdHIobykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pO1xufVxuY2xvbmUuX19vYmpUb1N0ciA9IF9fb2JqVG9TdHI7XG5cbmZ1bmN0aW9uIF9faXNEYXRlKG8pIHtcbiAgcmV0dXJuIHR5cGVvZiBvID09PSAnb2JqZWN0JyAmJiBfX29ialRvU3RyKG8pID09PSAnW29iamVjdCBEYXRlXSc7XG59XG5jbG9uZS5fX2lzRGF0ZSA9IF9faXNEYXRlO1xuXG5mdW5jdGlvbiBfX2lzQXJyYXkobykge1xuICByZXR1cm4gdHlwZW9mIG8gPT09ICdvYmplY3QnICYmIF9fb2JqVG9TdHIobykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59XG5jbG9uZS5fX2lzQXJyYXkgPSBfX2lzQXJyYXk7XG5cbmZ1bmN0aW9uIF9faXNSZWdFeHAobykge1xuICByZXR1cm4gdHlwZW9mIG8gPT09ICdvYmplY3QnICYmIF9fb2JqVG9TdHIobykgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xufVxuY2xvbmUuX19pc1JlZ0V4cCA9IF9faXNSZWdFeHA7XG5cbmZ1bmN0aW9uIF9fZ2V0UmVnRXhwRmxhZ3MocmUpIHtcbiAgdmFyIGZsYWdzID0gJyc7XG4gIGlmIChyZS5nbG9iYWwpIGZsYWdzICs9ICdnJztcbiAgaWYgKHJlLmlnbm9yZUNhc2UpIGZsYWdzICs9ICdpJztcbiAgaWYgKHJlLm11bHRpbGluZSkgZmxhZ3MgKz0gJ20nO1xuICByZXR1cm4gZmxhZ3M7XG59XG5jbG9uZS5fX2dldFJlZ0V4cEZsYWdzID0gX19nZXRSZWdFeHBGbGFncztcblxucmV0dXJuIGNsb25lO1xufSkoKTtcblxuaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gY2xvbmU7XG59XG4iXSwibmFtZXMiOlsiY2xvbmUiLCJfaW5zdGFuY2VvZiIsIm9iaiIsInR5cGUiLCJuYXRpdmVNYXAiLCJNYXAiLCJfIiwibmF0aXZlU2V0IiwiU2V0IiwibmF0aXZlUHJvbWlzZSIsIlByb21pc2UiLCJwYXJlbnQiLCJjaXJjdWxhciIsImRlcHRoIiwicHJvdG90eXBlIiwiaW5jbHVkZU5vbkVudW1lcmFibGUiLCJhbGxQYXJlbnRzIiwiYWxsQ2hpbGRyZW4iLCJ1c2VCdWZmZXIiLCJCdWZmZXIiLCJJbmZpbml0eSIsIl9jbG9uZSIsImNoaWxkIiwicHJvdG8iLCJyZXNvbHZlIiwicmVqZWN0IiwidGhlbiIsInZhbHVlIiwiZXJyIiwiX19pc0FycmF5IiwiX19pc1JlZ0V4cCIsIlJlZ0V4cCIsInNvdXJjZSIsIl9fZ2V0UmVnRXhwRmxhZ3MiLCJsYXN0SW5kZXgiLCJfX2lzRGF0ZSIsIkRhdGUiLCJnZXRUaW1lIiwiaXNCdWZmZXIiLCJhbGxvY1Vuc2FmZSIsImxlbmd0aCIsImNvcHkiLCJFcnJvciIsIk9iamVjdCIsImNyZWF0ZSIsImdldFByb3RvdHlwZU9mIiwiaW5kZXgiLCJpbmRleE9mIiwicHVzaCIsImZvckVhY2giLCJrZXkiLCJrZXlDaGlsZCIsInZhbHVlQ2hpbGQiLCJzZXQiLCJlbnRyeUNoaWxkIiwiYWRkIiwiaSIsImF0dHJzIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwic3ltYm9scyIsInN5bWJvbCIsImRlc2NyaXB0b3IiLCJlbnVtZXJhYmxlIiwiZGVmaW5lUHJvcGVydHkiLCJhbGxQcm9wZXJ0eU5hbWVzIiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsInByb3BlcnR5TmFtZSIsImNsb25lUHJvdG90eXBlIiwiYyIsIl9fb2JqVG9TdHIiLCJvIiwidG9TdHJpbmciLCJjYWxsIiwicmUiLCJmbGFncyIsImdsb2JhbCIsImlnbm9yZUNhc2UiLCJtdWx0aWxpbmUiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/clone/clone.js\n");

/***/ })

};
;